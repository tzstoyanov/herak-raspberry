From 588bf99273b302b7450008a30168561e62fb61be Mon Sep 17 00:00:00 2001
From: Tzvetomir Stoyanov <tz.stoyanov@gmail.com>
Date: Fri, 27 Jun 2025 06:37:43 +0300
Subject: [PATCH] Upgraded to upstream version 2.11 of littlefs.

The pico littlefs-lib is based on littlefs v2.0. There are a lot of
bug fixes, optimizations and improvements in v2.11.

Signed-off-by: Tzvetomir Stoyanov <tz.stoyanov@gmail.com>
---
 CMakeLists.txt |    1 +
 lfs.c          | 4961 ++++++++++++++++++++++++++++++++++--------------
 lfs.h          |  343 +++-
 lfs_util.c     |   37 +
 lfs_util.h     |  118 +-
 pico_hal.c     |  106 +-
 6 files changed, 3950 insertions(+), 1616 deletions(-)
 create mode 100644 lfs_util.c

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 181a7cb..d085f2c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -3,6 +3,7 @@ target_include_directories(littlefs-lib INTERFACE ${CMAKE_CURRENT_LIST_DIR})
 target_link_libraries(littlefs-lib INTERFACE hardware_flash)
 target_sources(littlefs-lib INTERFACE
     ${CMAKE_CURRENT_LIST_DIR}/lfs.c
+    ${CMAKE_CURRENT_LIST_DIR}/lfs_util.c
     ${CMAKE_CURRENT_LIST_DIR}/lfs.h
     ${CMAKE_CURRENT_LIST_DIR}/lfs_util.h
     ${CMAKE_CURRENT_LIST_DIR}/pico_hal.c
diff --git a/lfs.c b/lfs.c
index ad9de99..c0b0ba3 100644
--- a/lfs.c
+++ b/lfs.c
@@ -1,35 +1,53 @@
 /*
  * The little filesystem
  *
+ * Copyright (c) 2022, The littlefs authors.
  * Copyright (c) 2017, Arm Limited. All rights reserved.
  * SPDX-License-Identifier: BSD-3-Clause
  */
 #include "lfs.h"
 #include "lfs_util.h"
 
-lfs_t lfs;
 
+// some constants used throughout the code
 #define LFS_BLOCK_NULL ((lfs_block_t)-1)
 #define LFS_BLOCK_INLINE ((lfs_block_t)-2)
 
+enum {
+    LFS_OK_RELOCATED = 1,
+    LFS_OK_DROPPED   = 2,
+    LFS_OK_ORPHANED  = 3,
+};
+
+enum {
+    LFS_CMP_EQ = 0,
+    LFS_CMP_LT = 1,
+    LFS_CMP_GT = 2,
+};
+
+
 /// Caching block device operations ///
-static inline void lfs_cache_drop(lfs_cache_t* rcache) {
+
+static inline void lfs_cache_drop(lfs_t *lfs, lfs_cache_t *rcache) {
     // do not zero, cheaper if cache is readonly or only going to be
     // written with identical data (during relocates)
     (void)lfs;
     rcache->block = LFS_BLOCK_NULL;
 }
 
-static inline void lfs_cache_zero(lfs_cache_t* pcache) {
+static inline void lfs_cache_zero(lfs_t *lfs, lfs_cache_t *pcache) {
     // zero to avoid information leak
-    memset(pcache->buffer, 0xff, lfs.cfg->cache_size);
+    memset(pcache->buffer, 0xff, lfs->cfg->cache_size);
     pcache->block = LFS_BLOCK_NULL;
 }
 
-static int lfs_bd_read(const lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_size_t hint,
-                       lfs_block_t block, lfs_off_t off, void* buffer, lfs_size_t size) {
+static int lfs_bd_read(lfs_t *lfs,
+        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,
+        lfs_block_t block, lfs_off_t off,
+        void *buffer, lfs_size_t size) {
     uint8_t *data = buffer;
-    if (block >= lfs.cfg->block_count || off + size > lfs.cfg->block_size) {
+    if (off+size > lfs->cfg->block_size
+            || (lfs->block_count && block >= lfs->block_count)) {
         return LFS_ERR_CORRUPT;
     }
 
@@ -70,10 +88,11 @@ static int lfs_bd_read(const lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_size_
             diff = lfs_min(diff, rcache->off-off);
         }
 
-        if (size >= hint && off % lfs.cfg->read_size == 0 && size >= lfs.cfg->read_size) {
+        if (size >= hint && off % lfs->cfg->read_size == 0 &&
+                size >= lfs->cfg->read_size) {
             // bypass cache?
-            diff = lfs_aligndown(diff, lfs.cfg->read_size);
-            int err = lfs.cfg->read(block, off, data, diff);
+            diff = lfs_aligndown(diff, lfs->cfg->read_size);
+            int err = lfs->cfg->read(lfs->cfg, block, off, data, diff);
             if (err) {
                 return err;
             }
@@ -85,30 +104,30 @@ static int lfs_bd_read(const lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_size_
         }
 
         // load to cache, first condition can no longer fail
-        LFS_ASSERT(block < lfs.cfg->block_count);
+        LFS_ASSERT(!lfs->block_count || block < lfs->block_count);
         rcache->block = block;
-        rcache->off = lfs_aligndown(off, lfs.cfg->read_size);
+        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);
         rcache->size = lfs_min(
-            lfs_min(lfs_alignup(off + hint, lfs.cfg->read_size), lfs.cfg->block_size) - rcache->off,
-            lfs.cfg->cache_size);
-        int err = lfs.cfg->read(rcache->block, rcache->off, rcache->buffer, rcache->size);
+                lfs_min(
+                    lfs_alignup(off+hint, lfs->cfg->read_size),
+                    lfs->cfg->block_size)
+                - rcache->off,
+                lfs->cfg->cache_size);
+        int err = lfs->cfg->read(lfs->cfg, rcache->block,
+                rcache->off, rcache->buffer, rcache->size);
         LFS_ASSERT(err <= 0);
         if (err) {
             return err;
         }
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 
-enum {
-    LFS_CMP_EQ = 0,
-    LFS_CMP_LT = 1,
-    LFS_CMP_GT = 2,
-};
-
-static int lfs_bd_cmp(const lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_size_t hint,
-                      lfs_block_t block, lfs_off_t off, const void* buffer, lfs_size_t size) {
+static int lfs_bd_cmp(lfs_t *lfs,
+        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,
+        lfs_block_t block, lfs_off_t off,
+        const void *buffer, lfs_size_t size) {
     const uint8_t *data = buffer;
     lfs_size_t diff = 0;
 
@@ -116,12 +135,14 @@ static int lfs_bd_cmp(const lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_size_t
         uint8_t dat[8];
 
         diff = lfs_min(size-i, sizeof(dat));
-        int res = lfs_bd_read(pcache, rcache, hint - i, block, off + i, &dat, diff);
-        if (res) {
-            return res;
+        int err = lfs_bd_read(lfs,
+                pcache, rcache, hint-i,
+                block, off+i, &dat, diff);
+        if (err) {
+            return err;
         }
 
-        res = memcmp(dat, data + i, diff);
+        int res = memcmp(dat, data + i, diff);
         if (res) {
             return res < 0 ? LFS_CMP_LT : LFS_CMP_GT;
         }
@@ -130,12 +151,35 @@ static int lfs_bd_cmp(const lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_size_t
     return LFS_CMP_EQ;
 }
 
+static int lfs_bd_crc(lfs_t *lfs,
+        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,
+        lfs_block_t block, lfs_off_t off, lfs_size_t size, uint32_t *crc) {
+    lfs_size_t diff = 0;
+
+    for (lfs_off_t i = 0; i < size; i += diff) {
+        uint8_t dat[8];
+        diff = lfs_min(size-i, sizeof(dat));
+        int err = lfs_bd_read(lfs,
+                pcache, rcache, hint-i,
+                block, off+i, &dat, diff);
+        if (err) {
+            return err;
+        }
+
+        *crc = lfs_crc(*crc, &dat, diff);
+    }
+
+    return 0;
+}
+
 #ifndef LFS_READONLY
-static int lfs_bd_flush(lfs_cache_t* pcache, lfs_cache_t* rcache, bool validate) {
+static int lfs_bd_flush(lfs_t *lfs,
+        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate) {
     if (pcache->block != LFS_BLOCK_NULL && pcache->block != LFS_BLOCK_INLINE) {
-        LFS_ASSERT(pcache->block < lfs.cfg->block_count);
-        lfs_size_t diff = lfs_alignup(pcache->size, lfs.cfg->prog_size);
-        int err = lfs.cfg->prog(pcache->block, pcache->off, pcache->buffer, diff);
+        LFS_ASSERT(pcache->block < lfs->block_count);
+        lfs_size_t diff = lfs_alignup(pcache->size, lfs->cfg->prog_size);
+        int err = lfs->cfg->prog(lfs->cfg, pcache->block,
+                pcache->off, pcache->buffer, diff);
         LFS_ASSERT(err <= 0);
         if (err) {
             return err;
@@ -143,9 +187,10 @@ static int lfs_bd_flush(lfs_cache_t* pcache, lfs_cache_t* rcache, bool validate)
 
         if (validate) {
             // check data on disk
-            lfs_cache_drop(rcache);
-            int res =
-                lfs_bd_cmp(NULL, rcache, diff, pcache->block, pcache->off, pcache->buffer, diff);
+            lfs_cache_drop(lfs, rcache);
+            int res = lfs_bd_cmp(lfs,
+                    NULL, rcache, diff,
+                    pcache->block, pcache->off, pcache->buffer, diff);
             if (res < 0) {
                 return res;
             }
@@ -155,32 +200,45 @@ static int lfs_bd_flush(lfs_cache_t* pcache, lfs_cache_t* rcache, bool validate)
             }
         }
 
-        lfs_cache_zero(pcache);
+        lfs_cache_zero(lfs, pcache);
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_bd_sync(lfs_cache_t* pcache, lfs_cache_t* rcache, bool validate) {
-    lfs_cache_drop(rcache);
-    return lfs_bd_flush(pcache, rcache, validate);
+static int lfs_bd_sync(lfs_t *lfs,
+        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate) {
+    lfs_cache_drop(lfs, rcache);
+
+    int err = lfs_bd_flush(lfs, pcache, rcache, validate);
+    if (err) {
+        return err;
+    }
+
+    err = lfs->cfg->sync(lfs->cfg);
+    LFS_ASSERT(err <= 0);
+    return err;
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_bd_prog(lfs_cache_t* pcache, lfs_cache_t* rcache, bool validate, lfs_block_t block,
-                       lfs_off_t off, const void* buffer, lfs_size_t size) {
+static int lfs_bd_prog(lfs_t *lfs,
+        lfs_cache_t *pcache, lfs_cache_t *rcache, bool validate,
+        lfs_block_t block, lfs_off_t off,
+        const void *buffer, lfs_size_t size) {
     const uint8_t *data = buffer;
-    LFS_ASSERT(block == LFS_BLOCK_INLINE || block < lfs.cfg->block_count);
-    LFS_ASSERT(off + size <= lfs.cfg->block_size);
+    LFS_ASSERT(block == LFS_BLOCK_INLINE || block < lfs->block_count);
+    LFS_ASSERT(off + size <= lfs->cfg->block_size);
 
     while (size > 0) {
-        if (block == pcache->block && off >= pcache->off &&
-            off < pcache->off + lfs.cfg->cache_size) {
+        if (block == pcache->block &&
+                off >= pcache->off &&
+                off < pcache->off + lfs->cfg->cache_size) {
             // already fits in pcache?
-            lfs_size_t diff = lfs_min(size, lfs.cfg->cache_size - (off - pcache->off));
+            lfs_size_t diff = lfs_min(size,
+                    lfs->cfg->cache_size - (off-pcache->off));
             memcpy(&pcache->buffer[off-pcache->off], data, diff);
 
             data += diff;
@@ -188,9 +246,9 @@ static int lfs_bd_prog(lfs_cache_t* pcache, lfs_cache_t* rcache, bool validate,
             size -= diff;
 
             pcache->size = lfs_max(pcache->size, off - pcache->off);
-            if (pcache->size == lfs.cfg->cache_size) {
+            if (pcache->size == lfs->cfg->cache_size) {
                 // eagerly flush out pcache if we fill up
-                int err = lfs_bd_flush(pcache, rcache, validate);
+                int err = lfs_bd_flush(lfs, pcache, rcache, validate);
                 if (err) {
                     return err;
                 }
@@ -205,18 +263,18 @@ static int lfs_bd_prog(lfs_cache_t* pcache, lfs_cache_t* rcache, bool validate,
 
         // prepare pcache, first condition can no longer fail
         pcache->block = block;
-        pcache->off = lfs_aligndown(off, lfs.cfg->prog_size);
+        pcache->off = lfs_aligndown(off, lfs->cfg->prog_size);
         pcache->size = 0;
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_bd_erase(lfs_block_t block) {
-    LFS_ASSERT(block < lfs.cfg->block_count);
-    int err = lfs.cfg->erase(block);
+static int lfs_bd_erase(lfs_t *lfs, lfs_block_t block) {
+    LFS_ASSERT(block < lfs->block_count);
+    int err = lfs->cfg->erase(lfs->cfg, block);
     LFS_ASSERT(err <= 0);
     return err;
 }
@@ -224,6 +282,21 @@ static int lfs_bd_erase(lfs_block_t block) {
 
 
 /// Small type-level utilities ///
+
+// some operations on paths
+static inline lfs_size_t lfs_path_namelen(const char *path) {
+    return strcspn(path, "/");
+}
+
+static inline bool lfs_path_islast(const char *path) {
+    lfs_size_t namelen = lfs_path_namelen(path);
+    return path[namelen + strspn(path + namelen, "/")] == '\0';
+}
+
+static inline bool lfs_path_isdir(const char *path) {
+    return path[lfs_path_namelen(path)] != '\0';
+}
+
 // operations on block pairs
 static inline void lfs_pair_swap(lfs_block_t pair[2]) {
     lfs_block_t t = pair[0];
@@ -242,7 +315,7 @@ static inline int lfs_pair_cmp(
              paira[0] == pairb[1] || paira[1] == pairb[0]);
 }
 
-static inline bool lfs_pair_sync(
+static inline bool lfs_pair_issync(
         const lfs_block_t paira[2],
         const lfs_block_t pairb[2]) {
     return (paira[0] == pairb[0] && paira[1] == pairb[1]) ||
@@ -254,10 +327,12 @@ static inline void lfs_pair_fromle32(lfs_block_t pair[2]) {
     pair[1] = lfs_fromle32(pair[1]);
 }
 
+#ifndef LFS_READONLY
 static inline void lfs_pair_tole32(lfs_block_t pair[2]) {
     pair[0] = lfs_tole32(pair[0]);
     pair[1] = lfs_tole32(pair[1]);
 }
+#endif
 
 // operations on 32-bit entry tags
 typedef uint32_t lfs_tag_t;
@@ -284,6 +359,10 @@ static inline uint16_t lfs_tag_type1(lfs_tag_t tag) {
     return (tag & 0x70000000) >> 20;
 }
 
+static inline uint16_t lfs_tag_type2(lfs_tag_t tag) {
+    return (tag & 0x78000000) >> 20;
+}
+
 static inline uint16_t lfs_tag_type3(lfs_tag_t tag) {
     return (tag & 0x7ff00000) >> 20;
 }
@@ -325,31 +404,34 @@ struct lfs_diskoff {
 
 // operations on global state
 static inline void lfs_gstate_xor(lfs_gstate_t *a, const lfs_gstate_t *b) {
-    for (int i = 0; i < 3; i++) {
-        ((uint32_t*)a)[i] ^= ((const uint32_t*)b)[i];
-    }
+    a->tag ^= b->tag;
+    a->pair[0] ^= b->pair[0];
+    a->pair[1] ^= b->pair[1];
 }
 
 static inline bool lfs_gstate_iszero(const lfs_gstate_t *a) {
-    for (int i = 0; i < 3; i++) {
-        if (((uint32_t*)a)[i] != 0) {
-            return false;
-        }
-    }
-    return true;
+    return a->tag == 0
+            && a->pair[0] == 0
+            && a->pair[1] == 0;
 }
 
+#ifndef LFS_READONLY
 static inline bool lfs_gstate_hasorphans(const lfs_gstate_t *a) {
     return lfs_tag_size(a->tag);
 }
 
 static inline uint8_t lfs_gstate_getorphans(const lfs_gstate_t *a) {
-    return lfs_tag_size(a->tag);
+    return lfs_tag_size(a->tag) & 0x1ff;
 }
 
 static inline bool lfs_gstate_hasmove(const lfs_gstate_t *a) {
     return lfs_tag_type1(a->tag);
 }
+#endif
+
+static inline bool lfs_gstate_needssuperblock(const lfs_gstate_t *a) {
+    return lfs_tag_size(a->tag) >> 9;
+}
 
 static inline bool lfs_gstate_hasmovehere(const lfs_gstate_t *a,
         const lfs_block_t *pair) {
@@ -362,11 +444,31 @@ static inline void lfs_gstate_fromle32(lfs_gstate_t *a) {
     a->pair[1] = lfs_fromle32(a->pair[1]);
 }
 
+#ifndef LFS_READONLY
 static inline void lfs_gstate_tole32(lfs_gstate_t *a) {
     a->tag     = lfs_tole32(a->tag);
     a->pair[0] = lfs_tole32(a->pair[0]);
     a->pair[1] = lfs_tole32(a->pair[1]);
 }
+#endif
+
+// operations on forward-CRCs used to track erased state
+struct lfs_fcrc {
+    lfs_size_t size;
+    uint32_t crc;
+};
+
+static void lfs_fcrc_fromle32(struct lfs_fcrc *fcrc) {
+    fcrc->size = lfs_fromle32(fcrc->size);
+    fcrc->crc = lfs_fromle32(fcrc->crc);
+}
+
+#ifndef LFS_READONLY
+static void lfs_fcrc_tole32(struct lfs_fcrc *fcrc) {
+    fcrc->size = lfs_tole32(fcrc->size);
+    fcrc->crc = lfs_tole32(fcrc->crc);
+}
+#endif
 
 // other endianness operations
 static void lfs_ctz_fromle32(struct lfs_ctz *ctz) {
@@ -390,6 +492,7 @@ static inline void lfs_superblock_fromle32(lfs_superblock_t *superblock) {
     superblock->attr_max    = lfs_fromle32(superblock->attr_max);
 }
 
+#ifndef LFS_READONLY
 static inline void lfs_superblock_tole32(lfs_superblock_t *superblock) {
     superblock->version     = lfs_tole32(superblock->version);
     superblock->block_size  = lfs_tole32(superblock->block_size);
@@ -398,6 +501,7 @@ static inline void lfs_superblock_tole32(lfs_superblock_t *superblock) {
     superblock->file_max    = lfs_tole32(superblock->file_max);
     superblock->attr_max    = lfs_tole32(superblock->attr_max);
 }
+#endif
 
 #ifndef LFS_NO_ASSERT
 static bool lfs_mlist_isopen(struct lfs_mlist *head,
@@ -412,8 +516,8 @@ static bool lfs_mlist_isopen(struct lfs_mlist *head,
 }
 #endif
 
-static void lfs_mlist_remove(struct lfs_mlist* mlist) {
-    for (struct lfs_mlist** p = &lfs.mlist; *p; p = &(*p)->next) {
+static void lfs_mlist_remove(lfs_t *lfs, struct lfs_mlist *mlist) {
+    for (struct lfs_mlist **p = &lfs->mlist; *p; p = &(*p)->next) {
         if (*p == mlist) {
             *p = (*p)->next;
             break;
@@ -421,109 +525,189 @@ static void lfs_mlist_remove(struct lfs_mlist* mlist) {
     }
 }
 
-static void lfs_mlist_append(struct lfs_mlist* mlist) {
-    mlist->next = lfs.mlist;
-    lfs.mlist = mlist;
+static void lfs_mlist_append(lfs_t *lfs, struct lfs_mlist *mlist) {
+    mlist->next = lfs->mlist;
+    lfs->mlist = mlist;
+}
+
+// some other filesystem operations
+static uint32_t lfs_fs_disk_version(lfs_t *lfs) {
+    (void)lfs;
+#ifdef LFS_MULTIVERSION
+    if (lfs->cfg->disk_version) {
+        return lfs->cfg->disk_version;
+    } else
+#endif
+    {
+        return LFS_DISK_VERSION;
+    }
+}
+
+static uint16_t lfs_fs_disk_version_major(lfs_t *lfs) {
+    return 0xffff & (lfs_fs_disk_version(lfs) >> 16);
+
+}
+
+static uint16_t lfs_fs_disk_version_minor(lfs_t *lfs) {
+    return 0xffff & (lfs_fs_disk_version(lfs) >> 0);
 }
 
+
 /// Internal operations predeclared here ///
 #ifndef LFS_READONLY
-static int lfs_dir_commit(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int attrcount);
-static int lfs_dir_compact(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int attrcount,
-                           lfs_mdir_t* source, uint16_t begin, uint16_t end);
-
-static lfs_ssize_t lfs_file_rawwrite(lfs_file_t* file, const void* buffer, lfs_size_t size);
-static int lfs_file_rawsync(lfs_file_t* file);
-static int lfs_file_outline(lfs_file_t* file);
-static int lfs_file_flush(lfs_file_t* file);
-
-static int lfs_fs_preporphans(int8_t orphans);
-static void lfs_fs_prepmove(uint16_t id, const lfs_block_t pair[2]);
-static int lfs_fs_pred(const lfs_block_t dir[2], lfs_mdir_t* pdir);
-static lfs_stag_t lfs_fs_parent(const lfs_block_t dir[2], lfs_mdir_t* parent);
-static int lfs_fs_relocate(const lfs_block_t oldpair[2], lfs_block_t newpair[2]);
-static int lfs_fs_forceconsistency(void);
+static int lfs_dir_commit(lfs_t *lfs, lfs_mdir_t *dir,
+        const struct lfs_mattr *attrs, int attrcount);
+static int lfs_dir_compact(lfs_t *lfs,
+        lfs_mdir_t *dir, const struct lfs_mattr *attrs, int attrcount,
+        lfs_mdir_t *source, uint16_t begin, uint16_t end);
+static lfs_ssize_t lfs_file_flushedwrite(lfs_t *lfs, lfs_file_t *file,
+        const void *buffer, lfs_size_t size);
+static lfs_ssize_t lfs_file_write_(lfs_t *lfs, lfs_file_t *file,
+        const void *buffer, lfs_size_t size);
+static int lfs_file_sync_(lfs_t *lfs, lfs_file_t *file);
+static int lfs_file_outline(lfs_t *lfs, lfs_file_t *file);
+static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file);
+
+static int lfs_fs_deorphan(lfs_t *lfs, bool powerloss);
+static int lfs_fs_preporphans(lfs_t *lfs, int8_t orphans);
+static void lfs_fs_prepmove(lfs_t *lfs,
+        uint16_t id, const lfs_block_t pair[2]);
+static int lfs_fs_pred(lfs_t *lfs, const lfs_block_t dir[2],
+        lfs_mdir_t *pdir);
+static lfs_stag_t lfs_fs_parent(lfs_t *lfs, const lfs_block_t dir[2],
+        lfs_mdir_t *parent);
+static int lfs_fs_forceconsistency(lfs_t *lfs);
+#endif
+
+static void lfs_fs_prepsuperblock(lfs_t *lfs, bool needssuperblock);
+
+#ifdef LFS_MIGRATE
+static int lfs1_traverse(lfs_t *lfs,
+        int (*cb)(void*, lfs_block_t), void *data);
 #endif
 
-static int lfs_dir_rawrewind(lfs_dir_t* dir);
+static int lfs_dir_rewind_(lfs_t *lfs, lfs_dir_t *dir);
 
-static lfs_ssize_t lfs_file_rawread(lfs_file_t* file, void* buffer, lfs_size_t size);
-static int lfs_file_rawclose(lfs_file_t* file);
-static lfs_soff_t lfs_file_rawsize(lfs_file_t* file);
+static lfs_ssize_t lfs_file_flushedread(lfs_t *lfs, lfs_file_t *file,
+        void *buffer, lfs_size_t size);
+static lfs_ssize_t lfs_file_read_(lfs_t *lfs, lfs_file_t *file,
+        void *buffer, lfs_size_t size);
+static int lfs_file_close_(lfs_t *lfs, lfs_file_t *file);
+static lfs_soff_t lfs_file_size_(lfs_t *lfs, lfs_file_t *file);
 
-static lfs_ssize_t lfs_fs_rawsize(void);
-static int lfs_fs_rawtraverse(int (*cb)(void* data, lfs_block_t block), void* data,
-                              bool includeorphans);
+static lfs_ssize_t lfs_fs_size_(lfs_t *lfs);
+static int lfs_fs_traverse_(lfs_t *lfs,
+        int (*cb)(void *data, lfs_block_t block), void *data,
+        bool includeorphans);
+
+static int lfs_deinit(lfs_t *lfs);
+static int lfs_unmount_(lfs_t *lfs);
 
-static int lfs_deinit(void);
-static int lfs_rawunmount(void);
 
 /// Block allocator ///
+
+// allocations should call this when all allocated blocks are committed to
+// the filesystem
+//
+// after a checkpoint, the block allocator may realloc any untracked blocks
+static void lfs_alloc_ckpoint(lfs_t *lfs) {
+    lfs->lookahead.ckpoint = lfs->block_count;
+}
+
+// drop the lookahead buffer, this is done during mounting and failed
+// traversals in order to avoid invalid lookahead state
+static void lfs_alloc_drop(lfs_t *lfs) {
+    lfs->lookahead.size = 0;
+    lfs->lookahead.next = 0;
+    lfs_alloc_ckpoint(lfs);
+}
+
 #ifndef LFS_READONLY
 static int lfs_alloc_lookahead(void *p, lfs_block_t block) {
     lfs_t *lfs = (lfs_t*)p;
-    lfs_block_t off = ((block - lfs->free.off) + lfs->cfg->block_count) % lfs->cfg->block_count;
+    lfs_block_t off = ((block - lfs->lookahead.start)
+            + lfs->block_count) % lfs->block_count;
 
-    if (off < lfs->free.size) {
-        lfs->free.buffer[off / 32] |= 1U << (off % 32);
+    if (off < lfs->lookahead.size) {
+        lfs->lookahead.buffer[off / 8] |= 1U << (off % 8);
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
-// indicate allocated blocks have been committed into the filesystem, this
-// is to prevent blocks from being garbage collected in the middle of a
-// commit operation
-static void lfs_alloc_ack(void) { lfs.free.ack = lfs.cfg->block_count; }
+#ifndef LFS_READONLY
+static int lfs_alloc_scan(lfs_t *lfs) {
+    // move lookahead buffer to the first unused block
+    //
+    // note we limit the lookahead buffer to at most the amount of blocks
+    // checkpointed, this prevents the math in lfs_alloc from underflowing
+    lfs->lookahead.start = (lfs->lookahead.start + lfs->lookahead.next) 
+            % lfs->block_count;
+    lfs->lookahead.next = 0;
+    lfs->lookahead.size = lfs_min(
+            8*lfs->cfg->lookahead_size,
+            lfs->lookahead.ckpoint);
+
+    // find mask of free blocks from tree
+    memset(lfs->lookahead.buffer, 0, lfs->cfg->lookahead_size);
+    int err = lfs_fs_traverse_(lfs, lfs_alloc_lookahead, lfs, true);
+    if (err) {
+        lfs_alloc_drop(lfs);
+        return err;
+    }
 
-// drop the lookahead buffer, this is done during mounting and failed
-// traversals in order to avoid invalid lookahead state
-static void lfs_alloc_drop(void) {
-    lfs.free.size = 0;
-    lfs.free.i = 0;
-    lfs_alloc_ack();
+    return 0;
 }
+#endif
 
 #ifndef LFS_READONLY
-static int lfs_alloc(lfs_block_t* block) {
+static int lfs_alloc(lfs_t *lfs, lfs_block_t *block) {
     while (true) {
-        while (lfs.free.i != lfs.free.size) {
-            lfs_block_t off = lfs.free.i;
-            lfs.free.i += 1;
-            lfs.free.ack -= 1;
-
-            if (!(lfs.free.buffer[off / 32] & (1U << (off % 32)))) {
+        // scan our lookahead buffer for free blocks
+        while (lfs->lookahead.next < lfs->lookahead.size) {
+            if (!(lfs->lookahead.buffer[lfs->lookahead.next / 8]
+                    & (1U << (lfs->lookahead.next % 8)))) {
                 // found a free block
-                *block = (lfs.free.off + off) % lfs.cfg->block_count;
-
-                // eagerly find next off so an alloc ack can
-                // discredit old lookahead blocks
-                while (lfs.free.i != lfs.free.size &&
-                       (lfs.free.buffer[lfs.free.i / 32] & (1U << (lfs.free.i % 32)))) {
-                    lfs.free.i += 1;
-                    lfs.free.ack -= 1;
+                *block = (lfs->lookahead.start + lfs->lookahead.next)
+                        % lfs->block_count;
+
+                // eagerly find next free block to maximize how many blocks
+                // lfs_alloc_ckpoint makes available for scanning
+                while (true) {
+                    lfs->lookahead.next += 1;
+                    lfs->lookahead.ckpoint -= 1;
+
+                    if (lfs->lookahead.next >= lfs->lookahead.size
+                            || !(lfs->lookahead.buffer[lfs->lookahead.next / 8]
+                                & (1U << (lfs->lookahead.next % 8)))) {
+                        return 0;
+                    }
                 }
-
-                return LFS_ERR_OK;
             }
-        }
 
-        // check if we have looked at all blocks since last ack
-        if (lfs.free.ack == 0) {
-            LFS_ERROR("No more free space %" PRIu32, lfs.free.i + lfs.free.off);
+            lfs->lookahead.next += 1;
+            lfs->lookahead.ckpoint -= 1;
+        }
+
+        // In order to keep our block allocator from spinning forever when our
+        // filesystem is full, we mark points where there are no in-flight
+        // allocations with a checkpoint before starting a set of allocations.
+        //
+        // If we've looked at all blocks since the last checkpoint, we report
+        // the filesystem as out of storage.
+        //
+        if (lfs->lookahead.ckpoint <= 0) {
+            LFS_ERROR("No more free space 0x%"PRIx32,
+                    (lfs->lookahead.start + lfs->lookahead.next)
+                        % lfs->block_count);
             return LFS_ERR_NOSPC;
         }
 
-        lfs.free.off = (lfs.free.off + lfs.free.size) % lfs.cfg->block_count;
-        lfs.free.size = lfs_min(8 * lfs.cfg->lookahead_size, lfs.free.ack);
-        lfs.free.i = 0;
-
-        // find mask of free blocks from tree
-        memset(lfs.free.buffer, 0, lfs.cfg->lookahead_size);
-        int err = lfs_fs_rawtraverse(lfs_alloc_lookahead, &lfs, true);
-        if (err) {
-            lfs_alloc_drop();
+        // No blocks in our lookahead buffer, we need to scan the filesystem for
+        // unused blocks in the next lookahead window.
+        int err = lfs_alloc_scan(lfs);
+        if(err) {
             return err;
         }
     }
@@ -531,24 +715,30 @@ static int lfs_alloc(lfs_block_t* block) {
 #endif
 
 /// Metadata pair and directory operations ///
-static lfs_stag_t lfs_dir_getslice(const lfs_mdir_t* dir, lfs_tag_t gmask, lfs_tag_t gtag,
-                                   lfs_off_t goff, void* gbuffer, lfs_size_t gsize) {
+static lfs_stag_t lfs_dir_getslice(lfs_t *lfs, const lfs_mdir_t *dir,
+        lfs_tag_t gmask, lfs_tag_t gtag,
+        lfs_off_t goff, void *gbuffer, lfs_size_t gsize) {
     lfs_off_t off = dir->off;
     lfs_tag_t ntag = dir->etag;
     lfs_stag_t gdiff = 0;
 
-    if (lfs_gstate_hasmovehere(&lfs.gdisk, dir->pair) && lfs_tag_id(gmask) != 0 &&
-        lfs_tag_id(lfs.gdisk.tag) <= lfs_tag_id(gtag)) {
-        // synthetic moves
-        gdiff -= LFS_MKTAG(0, 1, 0);
+    // synthetic moves
+    if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair) &&
+            lfs_tag_id(gmask) != 0) {
+        if (lfs_tag_id(lfs->gdisk.tag) == lfs_tag_id(gtag)) {
+            return LFS_ERR_NOENT;
+        } else if (lfs_tag_id(lfs->gdisk.tag) < lfs_tag_id(gtag)) {
+            gdiff -= LFS_MKTAG(0, 1, 0);
+        }
     }
 
     // iterate over dir block backwards (for faster lookups)
     while (off >= sizeof(lfs_tag_t) + lfs_tag_dsize(ntag)) {
         off -= lfs_tag_dsize(ntag);
         lfs_tag_t tag = ntag;
-        int err =
-            lfs_bd_read(NULL, &lfs.rcache, sizeof(ntag), dir->pair[0], off, &ntag, sizeof(ntag));
+        int err = lfs_bd_read(lfs,
+                NULL, &lfs->rcache, sizeof(ntag),
+                dir->pair[0], off, &ntag, sizeof(ntag));
         if (err) {
             return err;
         }
@@ -574,8 +764,9 @@ static lfs_stag_t lfs_dir_getslice(const lfs_mdir_t* dir, lfs_tag_t gmask, lfs_t
             }
 
             lfs_size_t diff = lfs_min(lfs_tag_size(tag), gsize);
-            err = lfs_bd_read(NULL, &lfs.rcache, diff, dir->pair[0], off + sizeof(tag) + goff,
-                              gbuffer, diff);
+            err = lfs_bd_read(lfs,
+                    NULL, &lfs->rcache, diff,
+                    dir->pair[0], off+sizeof(tag)+goff, gbuffer, diff);
             if (err) {
                 return err;
             }
@@ -589,16 +780,19 @@ static lfs_stag_t lfs_dir_getslice(const lfs_mdir_t* dir, lfs_tag_t gmask, lfs_t
     return LFS_ERR_NOENT;
 }
 
-static lfs_stag_t lfs_dir_get(const lfs_mdir_t* dir, lfs_tag_t gmask, lfs_tag_t gtag,
-                              void* buffer) {
-    return lfs_dir_getslice(dir, gmask, gtag, 0, buffer, lfs_tag_size(gtag));
+static lfs_stag_t lfs_dir_get(lfs_t *lfs, const lfs_mdir_t *dir,
+        lfs_tag_t gmask, lfs_tag_t gtag, void *buffer) {
+    return lfs_dir_getslice(lfs, dir,
+            gmask, gtag,
+            0, buffer, lfs_tag_size(gtag));
 }
 
-static int lfs_dir_getread(const lfs_mdir_t* dir, const lfs_cache_t* pcache, lfs_cache_t* rcache,
-                           lfs_size_t hint, lfs_tag_t gmask, lfs_tag_t gtag, lfs_off_t off,
-                           void* buffer, lfs_size_t size) {
+static int lfs_dir_getread(lfs_t *lfs, const lfs_mdir_t *dir,
+        const lfs_cache_t *pcache, lfs_cache_t *rcache, lfs_size_t hint,
+        lfs_tag_t gmask, lfs_tag_t gtag,
+        lfs_off_t off, void *buffer, lfs_size_t size) {
     uint8_t *data = buffer;
-    if (off + size > lfs.cfg->block_size) {
+    if (off+size > lfs->cfg->block_size) {
         return LFS_ERR_CORRUPT;
     }
 
@@ -641,15 +835,17 @@ static int lfs_dir_getread(const lfs_mdir_t* dir, const lfs_cache_t* pcache, lfs
 
         // load to cache, first condition can no longer fail
         rcache->block = LFS_BLOCK_INLINE;
-        rcache->off = lfs_aligndown(off, lfs.cfg->read_size);
-        rcache->size = lfs_min(lfs_alignup(off + hint, lfs.cfg->read_size), lfs.cfg->cache_size);
-        int err = lfs_dir_getslice(dir, gmask, gtag, rcache->off, rcache->buffer, rcache->size);
+        rcache->off = lfs_aligndown(off, lfs->cfg->read_size);
+        rcache->size = lfs_min(lfs_alignup(off+hint, lfs->cfg->read_size),
+                lfs->cfg->cache_size);
+        int err = lfs_dir_getslice(lfs, dir, gmask, gtag,
+                rcache->off, rcache->buffer, rcache->size);
         if (err < 0) {
             return err;
         }
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 
 #ifndef LFS_READONLY
@@ -669,6 +865,7 @@ static int lfs_dir_traverse_filter(void *p,
             (LFS_MKTAG(0x7ff, 0x3ff, 0) & tag) == (
                 LFS_MKTAG(LFS_TYPE_DELETE, 0, 0) |
                     (LFS_MKTAG(0, 0x3ff, 0) & *filtertag))) {
+        *filtertag = LFS_MKTAG(LFS_FROM_NOOP, 0, 0);
         return true;
     }
 
@@ -683,104 +880,242 @@ static int lfs_dir_traverse_filter(void *p,
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_dir_traverse(const lfs_mdir_t* dir, lfs_off_t off, lfs_tag_t ptag,
-                            const struct lfs_mattr* attrs, int attrcount, lfs_tag_t tmask,
-                            lfs_tag_t ttag, uint16_t begin, uint16_t end, int16_t diff,
-                            int (*cb)(void* data, lfs_tag_t tag, const void* buffer), void* data) {
-    // iterate over directory and attrs
-    while (true) {
-        lfs_tag_t tag;
-        const void *buffer;
-        struct lfs_diskoff disk;
-        if (off+lfs_tag_dsize(ptag) < dir->off) {
-            off += lfs_tag_dsize(ptag);
-            int err =
-                lfs_bd_read(NULL, &lfs.rcache, sizeof(tag), dir->pair[0], off, &tag, sizeof(tag));
-            if (err) {
-                return err;
-            }
+// maximum recursive depth of lfs_dir_traverse, the deepest call:
+//
+// traverse with commit
+// '-> traverse with move
+//     '-> traverse with filter
+//
+#define LFS_DIR_TRAVERSE_DEPTH 3
+
+struct lfs_dir_traverse {
+    const lfs_mdir_t *dir;
+    lfs_off_t off;
+    lfs_tag_t ptag;
+    const struct lfs_mattr *attrs;
+    int attrcount;
 
-            tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;
-            disk.block = dir->pair[0];
-            disk.off = off+sizeof(lfs_tag_t);
-            buffer = &disk;
-            ptag = tag;
-        } else if (attrcount > 0) {
-            tag = attrs[0].tag;
-            buffer = attrs[0].buffer;
-            attrs += 1;
-            attrcount -= 1;
-        } else {
-            return LFS_ERR_OK;
-        }
+    lfs_tag_t tmask;
+    lfs_tag_t ttag;
+    uint16_t begin;
+    uint16_t end;
+    int16_t diff;
 
-        lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);
-        if ((mask & tmask & tag) != (mask & tmask & ttag)) {
-            continue;
-        }
+    int (*cb)(void *data, lfs_tag_t tag, const void *buffer);
+    void *data;
+
+    lfs_tag_t tag;
+    const void *buffer;
+    struct lfs_diskoff disk;
+};
+
+static int lfs_dir_traverse(lfs_t *lfs,
+        const lfs_mdir_t *dir, lfs_off_t off, lfs_tag_t ptag,
+        const struct lfs_mattr *attrs, int attrcount,
+        lfs_tag_t tmask, lfs_tag_t ttag,
+        uint16_t begin, uint16_t end, int16_t diff,
+        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {
+    // This function in inherently recursive, but bounded. To allow tool-based
+    // analysis without unnecessary code-cost we use an explicit stack
+    struct lfs_dir_traverse stack[LFS_DIR_TRAVERSE_DEPTH-1];
+    unsigned sp = 0;
+    int res;
+
+    // iterate over directory and attrs
+    lfs_tag_t tag;
+    const void *buffer;
+    struct lfs_diskoff disk = {0};
+    while (true) {
+        {
+            if (off+lfs_tag_dsize(ptag) < dir->off) {
+                off += lfs_tag_dsize(ptag);
+                int err = lfs_bd_read(lfs,
+                        NULL, &lfs->rcache, sizeof(tag),
+                        dir->pair[0], off, &tag, sizeof(tag));
+                if (err) {
+                    return err;
+                }
 
-        // do we need to filter? inlining the filtering logic here allows
-        // for some minor optimizations
-        if (lfs_tag_id(tmask) != 0) {
-            // scan for duplicates and update tag based on creates/deletes
-            int filter = lfs_dir_traverse(dir, off, ptag, attrs, attrcount, 0, 0, 0, 0, 0,
-                                          lfs_dir_traverse_filter, &tag);
-            if (filter < 0) {
-                return filter;
+                tag = (lfs_frombe32(tag) ^ ptag) | 0x80000000;
+                disk.block = dir->pair[0];
+                disk.off = off+sizeof(lfs_tag_t);
+                buffer = &disk;
+                ptag = tag;
+            } else if (attrcount > 0) {
+                tag = attrs[0].tag;
+                buffer = attrs[0].buffer;
+                attrs += 1;
+                attrcount -= 1;
+            } else {
+                // finished traversal, pop from stack?
+                res = 0;
+                break;
             }
 
-            if (filter) {
+            // do we need to filter?
+            lfs_tag_t mask = LFS_MKTAG(0x7ff, 0, 0);
+            if ((mask & tmask & tag) != (mask & tmask & ttag)) {
                 continue;
             }
 
-            // in filter range?
-            if (!(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {
+            if (lfs_tag_id(tmask) != 0) {
+                LFS_ASSERT(sp < LFS_DIR_TRAVERSE_DEPTH);
+                // recurse, scan for duplicates, and update tag based on
+                // creates/deletes
+                stack[sp] = (struct lfs_dir_traverse){
+                    .dir        = dir,
+                    .off        = off,
+                    .ptag       = ptag,
+                    .attrs      = attrs,
+                    .attrcount  = attrcount,
+                    .tmask      = tmask,
+                    .ttag       = ttag,
+                    .begin      = begin,
+                    .end        = end,
+                    .diff       = diff,
+                    .cb         = cb,
+                    .data       = data,
+                    .tag        = tag,
+                    .buffer     = buffer,
+                    .disk       = disk,
+                };
+                sp += 1;
+
+                tmask = 0;
+                ttag = 0;
+                begin = 0;
+                end = 0;
+                diff = 0;
+                cb = lfs_dir_traverse_filter;
+                data = &stack[sp-1].tag;
                 continue;
             }
         }
 
+popped:
+        // in filter range?
+        if (lfs_tag_id(tmask) != 0 &&
+                !(lfs_tag_id(tag) >= begin && lfs_tag_id(tag) < end)) {
+            continue;
+        }
+
         // handle special cases for mcu-side operations
         if (lfs_tag_type3(tag) == LFS_FROM_NOOP) {
             // do nothing
         } else if (lfs_tag_type3(tag) == LFS_FROM_MOVE) {
+            // Without this condition, lfs_dir_traverse can exhibit an
+            // extremely expensive O(n^3) of nested loops when renaming.
+            // This happens because lfs_dir_traverse tries to filter tags by
+            // the tags in the source directory, triggering a second
+            // lfs_dir_traverse with its own filter operation.
+            //
+            // traverse with commit
+            // '-> traverse with filter
+            //     '-> traverse with move
+            //         '-> traverse with filter
+            //
+            // However we don't actually care about filtering the second set of
+            // tags, since duplicate tags have no effect when filtering.
+            //
+            // This check skips this unnecessary recursive filtering explicitly,
+            // reducing this runtime from O(n^3) to O(n^2).
+            if (cb == lfs_dir_traverse_filter) {
+                continue;
+            }
+
+            // recurse into move
+            stack[sp] = (struct lfs_dir_traverse){
+                .dir        = dir,
+                .off        = off,
+                .ptag       = ptag,
+                .attrs      = attrs,
+                .attrcount  = attrcount,
+                .tmask      = tmask,
+                .ttag       = ttag,
+                .begin      = begin,
+                .end        = end,
+                .diff       = diff,
+                .cb         = cb,
+                .data       = data,
+                .tag        = LFS_MKTAG(LFS_FROM_NOOP, 0, 0),
+            };
+            sp += 1;
+
             uint16_t fromid = lfs_tag_size(tag);
             uint16_t toid = lfs_tag_id(tag);
-            int err = lfs_dir_traverse(buffer, 0, 0xffffffff, NULL, 0, LFS_MKTAG(0x600, 0x3ff, 0),
-                                       LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0), fromid, fromid + 1,
-                                       toid - fromid + diff, cb, data);
-            if (err) {
-                return err;
-            }
+            dir = buffer;
+            off = 0;
+            ptag = 0xffffffff;
+            attrs = NULL;
+            attrcount = 0;
+            tmask = LFS_MKTAG(0x600, 0x3ff, 0);
+            ttag = LFS_MKTAG(LFS_TYPE_STRUCT, 0, 0);
+            begin = fromid;
+            end = fromid+1;
+            diff = toid-fromid+diff;
         } else if (lfs_tag_type3(tag) == LFS_FROM_USERATTRS) {
             for (unsigned i = 0; i < lfs_tag_size(tag); i++) {
                 const struct lfs_attr *a = buffer;
-                int err = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,
+                res = cb(data, LFS_MKTAG(LFS_TYPE_USERATTR + a[i].type,
                         lfs_tag_id(tag) + diff, a[i].size), a[i].buffer);
-                if (err) {
-                    return err;
+                if (res < 0) {
+                    return res;
+                }
+
+                if (res) {
+                    break;
                 }
             }
         } else {
-            int err = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);
-            if (err) {
-                return err;
+            res = cb(data, tag + LFS_MKTAG(0, diff, 0), buffer);
+            if (res < 0) {
+                return res;
+            }
+
+            if (res) {
+                break;
             }
         }
     }
+
+    if (sp > 0) {
+        // pop from the stack and return, fortunately all pops share
+        // a destination
+        dir         = stack[sp-1].dir;
+        off         = stack[sp-1].off;
+        ptag        = stack[sp-1].ptag;
+        attrs       = stack[sp-1].attrs;
+        attrcount   = stack[sp-1].attrcount;
+        tmask       = stack[sp-1].tmask;
+        ttag        = stack[sp-1].ttag;
+        begin       = stack[sp-1].begin;
+        end         = stack[sp-1].end;
+        diff        = stack[sp-1].diff;
+        cb          = stack[sp-1].cb;
+        data        = stack[sp-1].data;
+        tag         = stack[sp-1].tag;
+        buffer      = stack[sp-1].buffer;
+        disk        = stack[sp-1].disk;
+        sp -= 1;
+        goto popped;
+    } else {
+        return res;
+    }
 }
 #endif
 
-static lfs_stag_t lfs_dir_fetchmatch(lfs_mdir_t* dir, const lfs_block_t pair[2], lfs_tag_t fmask,
-                                     lfs_tag_t ftag, uint16_t* id,
-                                     int (*cb)(void* data, lfs_tag_t tag, const void* buffer),
-                                     void* data) {
+static lfs_stag_t lfs_dir_fetchmatch(lfs_t *lfs,
+        lfs_mdir_t *dir, const lfs_block_t pair[2],
+        lfs_tag_t fmask, lfs_tag_t ftag, uint16_t *id,
+        int (*cb)(void *data, lfs_tag_t tag, const void *buffer), void *data) {
     // we can find tag very efficiently during a fetch, since we're already
     // scanning the entire directory
     lfs_stag_t besttag = -1;
 
     // if either block address is invalid we return LFS_ERR_CORRUPT here,
     // otherwise later writes to the pair could fail
-    if (pair[0] >= lfs.cfg->block_count || pair[1] >= lfs.cfg->block_count) {
+    if (lfs->block_count 
+            && (pair[0] >= lfs->block_count || pair[1] >= lfs->block_count)) {
         return LFS_ERR_CORRUPT;
     }
 
@@ -788,8 +1123,9 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_mdir_t* dir, const lfs_block_t pair[2],
     uint32_t revs[2] = {0, 0};
     int r = 0;
     for (int i = 0; i < 2; i++) {
-        int err =
-            lfs_bd_read(NULL, &lfs.rcache, sizeof(revs[i]), pair[i], 0, &revs[i], sizeof(revs[i]));
+        int err = lfs_bd_read(lfs,
+                NULL, &lfs->rcache, sizeof(revs[i]),
+                pair[i], 0, &revs[i], sizeof(revs[i]));
         revs[i] = lfs_fromle32(revs[i]);
         if (err && err != LFS_ERR_CORRUPT) {
             return err;
@@ -816,6 +1152,11 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_mdir_t* dir, const lfs_block_t pair[2],
         bool tempsplit = false;
         lfs_stag_t tempbesttag = besttag;
 
+        // assume not erased until proven otherwise
+        bool maybeerased = false;
+        bool hasfcrc = false;
+        struct lfs_fcrc fcrc;
+
         dir->rev = lfs_tole32(dir->rev);
         uint32_t crc = lfs_crc(0xffffffff, &dir->rev, sizeof(dir->rev));
         dir->rev = lfs_fromle32(dir->rev);
@@ -824,12 +1165,12 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_mdir_t* dir, const lfs_block_t pair[2],
             // extract next tag
             lfs_tag_t tag;
             off += lfs_tag_dsize(ptag);
-            int err = lfs_bd_read(NULL, &lfs.rcache, lfs.cfg->block_size, dir->pair[0], off, &tag,
-                                  sizeof(tag));
+            int err = lfs_bd_read(lfs,
+                    NULL, &lfs->rcache, lfs->cfg->block_size,
+                    dir->pair[0], off, &tag, sizeof(tag));
             if (err) {
                 if (err == LFS_ERR_CORRUPT) {
                     // can't continue?
-                    dir->erased = false;
                     break;
                 }
                 return err;
@@ -838,26 +1179,26 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_mdir_t* dir, const lfs_block_t pair[2],
             crc = lfs_crc(crc, &tag, sizeof(tag));
             tag = lfs_frombe32(tag) ^ ptag;
 
-            // next commit not yet programmed or we're not in valid range
+            // next commit not yet programmed?
             if (!lfs_tag_isvalid(tag)) {
-                dir->erased =
-                    (lfs_tag_type1(ptag) == LFS_TYPE_CRC && dir->off % lfs.cfg->prog_size == 0);
+                // we only might be erased if the last tag was a crc
+                maybeerased = (lfs_tag_type2(ptag) == LFS_TYPE_CCRC);
                 break;
-            } else if (off + lfs_tag_dsize(tag) > lfs.cfg->block_size) {
-                dir->erased = false;
+            // out of range?
+            } else if (off + lfs_tag_dsize(tag) > lfs->cfg->block_size) {
                 break;
             }
 
             ptag = tag;
 
-            if (lfs_tag_type1(tag) == LFS_TYPE_CRC) {
+            if (lfs_tag_type2(tag) == LFS_TYPE_CCRC) {
                 // check the crc attr
                 uint32_t dcrc;
-                err = lfs_bd_read(NULL, &lfs.rcache, lfs.cfg->block_size, dir->pair[0],
-                                  off + sizeof(tag), &dcrc, sizeof(dcrc));
+                err = lfs_bd_read(lfs,
+                        NULL, &lfs->rcache, lfs->cfg->block_size,
+                        dir->pair[0], off+sizeof(tag), &dcrc, sizeof(dcrc));
                 if (err) {
                     if (err == LFS_ERR_CORRUPT) {
-                        dir->erased = false;
                         break;
                     }
                     return err;
@@ -865,7 +1206,6 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_mdir_t* dir, const lfs_block_t pair[2],
                 dcrc = lfs_fromle32(dcrc);
 
                 if (crc != dcrc) {
-                    dir->erased = false;
                     break;
                 }
 
@@ -876,7 +1216,7 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_mdir_t* dir, const lfs_block_t pair[2],
                 // pseudorandom numbers, note we use another crc here
                 // as a collection function because it is sufficiently
                 // random and convenient
-                lfs.seed = lfs_crc(lfs.seed, &crc, sizeof(crc));
+                lfs->seed = lfs_crc(lfs->seed, &crc, sizeof(crc));
 
                 // update with what's found so far
                 besttag = tempbesttag;
@@ -887,25 +1227,21 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_mdir_t* dir, const lfs_block_t pair[2],
                 dir->tail[1] = temptail[1];
                 dir->split = tempsplit;
 
-                // reset crc
+                // reset crc, hasfcrc
                 crc = 0xffffffff;
                 continue;
             }
 
             // crc the entry first, hopefully leaving it in the cache
-            for (lfs_off_t j = sizeof(tag); j < lfs_tag_dsize(tag); j++) {
-                uint8_t dat;
-                err = lfs_bd_read(NULL, &lfs.rcache, lfs.cfg->block_size, dir->pair[0], off + j,
-                                  &dat, 1);
-                if (err) {
-                    if (err == LFS_ERR_CORRUPT) {
-                        dir->erased = false;
-                        break;
-                    }
-                    return err;
+            err = lfs_bd_crc(lfs,
+                    NULL, &lfs->rcache, lfs->cfg->block_size,
+                    dir->pair[0], off+sizeof(tag),
+                    lfs_tag_dsize(tag)-sizeof(tag), &crc);
+            if (err) {
+                if (err == LFS_ERR_CORRUPT) {
+                    break;
                 }
-
-                crc = lfs_crc(crc, &dat, 1);
+                return err;
             }
 
             // directory modification tags?
@@ -927,15 +1263,29 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_mdir_t* dir, const lfs_block_t pair[2],
             } else if (lfs_tag_type1(tag) == LFS_TYPE_TAIL) {
                 tempsplit = (lfs_tag_chunk(tag) & 1);
 
-                err = lfs_bd_read(NULL, &lfs.rcache, lfs.cfg->block_size, dir->pair[0],
-                                  off + sizeof(tag), &temptail, 8);
+                err = lfs_bd_read(lfs,
+                        NULL, &lfs->rcache, lfs->cfg->block_size,
+                        dir->pair[0], off+sizeof(tag), &temptail, 8);
                 if (err) {
                     if (err == LFS_ERR_CORRUPT) {
-                        dir->erased = false;
                         break;
                     }
+                    return err;
                 }
                 lfs_pair_fromle32(temptail);
+            } else if (lfs_tag_type3(tag) == LFS_TYPE_FCRC) {
+                err = lfs_bd_read(lfs,
+                        NULL, &lfs->rcache, lfs->cfg->block_size,
+                        dir->pair[0], off+sizeof(tag),
+                        &fcrc, sizeof(fcrc));
+                if (err) {
+                    if (err == LFS_ERR_CORRUPT) {
+                        break;
+                    }
+                }
+
+                lfs_fcrc_fromle32(&fcrc);
+                hasfcrc = true;
             }
 
             // found a match for our fetcher?
@@ -944,7 +1294,6 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_mdir_t* dir, const lfs_block_t pair[2],
                         dir->pair[0], off+sizeof(tag)});
                 if (res < 0) {
                     if (res == LFS_ERR_CORRUPT) {
-                        dir->erased = false;
                         break;
                     }
                     return res;
@@ -966,34 +1315,67 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_mdir_t* dir, const lfs_block_t pair[2],
             }
         }
 
-        // consider what we have good enough
-        if (dir->off > 0) {
-            // synthetic move
-            if (lfs_gstate_hasmovehere(&lfs.gdisk, dir->pair)) {
-                if (lfs_tag_id(lfs.gdisk.tag) == lfs_tag_id(besttag)) {
-                    besttag |= 0x80000000;
-                } else if (besttag != -1 && lfs_tag_id(lfs.gdisk.tag) < lfs_tag_id(besttag)) {
-                    besttag -= LFS_MKTAG(0, 1, 0);
+        // found no valid commits?
+        if (dir->off == 0) {
+            // try the other block?
+            lfs_pair_swap(dir->pair);
+            dir->rev = revs[(r+1)%2];
+            continue;
+        }
+
+        // did we end on a valid commit? we may have an erased block
+        dir->erased = false;
+        if (maybeerased && dir->off % lfs->cfg->prog_size == 0) {
+        #ifdef LFS_MULTIVERSION
+            // note versions < lfs2.1 did not have fcrc tags, if
+            // we're < lfs2.1 treat missing fcrc as erased data
+            //
+            // we don't strictly need to do this, but otherwise writing
+            // to lfs2.0 disks becomes very inefficient
+            if (lfs_fs_disk_version(lfs) < 0x00020001) {
+                dir->erased = true;
+
+            } else
+        #endif
+            if (hasfcrc) {
+                // check for an fcrc matching the next prog's erased state, if
+                // this failed most likely a previous prog was interrupted, we
+                // need a new erase
+                uint32_t fcrc_ = 0xffffffff;
+                int err = lfs_bd_crc(lfs,
+                        NULL, &lfs->rcache, lfs->cfg->block_size,
+                        dir->pair[0], dir->off, fcrc.size, &fcrc_);
+                if (err && err != LFS_ERR_CORRUPT) {
+                    return err;
                 }
-            }
 
-            // found tag? or found best id?
-            if (id) {
-                *id = lfs_min(lfs_tag_id(besttag), dir->count);
+                // found beginning of erased part?
+                dir->erased = (fcrc_ == fcrc.crc);
             }
+        }
 
-            if (lfs_tag_isvalid(besttag)) {
-                return besttag;
-            } else if (lfs_tag_id(besttag) < dir->count) {
-                return LFS_ERR_NOENT;
-            } else {
-                return LFS_ERR_OK;
+        // synthetic move
+        if (lfs_gstate_hasmovehere(&lfs->gdisk, dir->pair)) {
+            if (lfs_tag_id(lfs->gdisk.tag) == lfs_tag_id(besttag)) {
+                besttag |= 0x80000000;
+            } else if (besttag != -1 &&
+                    lfs_tag_id(lfs->gdisk.tag) < lfs_tag_id(besttag)) {
+                besttag -= LFS_MKTAG(0, 1, 0);
             }
         }
 
-        // failed, try the other block?
-        lfs_pair_swap(dir->pair);
-        dir->rev = revs[(r+1)%2];
+        // found tag? or found best id?
+        if (id) {
+            *id = lfs_min(lfs_tag_id(besttag), dir->count);
+        }
+
+        if (lfs_tag_isvalid(besttag)) {
+            return besttag;
+        } else if (lfs_tag_id(besttag) < dir->count) {
+            return LFS_ERR_NOENT;
+        } else {
+            return 0;
+        }
     }
 
     LFS_ERROR("Corrupted dir pair at {0x%"PRIx32", 0x%"PRIx32"}",
@@ -1001,16 +1383,19 @@ static lfs_stag_t lfs_dir_fetchmatch(lfs_mdir_t* dir, const lfs_block_t pair[2],
     return LFS_ERR_CORRUPT;
 }
 
-static int lfs_dir_fetch(lfs_mdir_t* dir, const lfs_block_t pair[2]) {
+static int lfs_dir_fetch(lfs_t *lfs,
+        lfs_mdir_t *dir, const lfs_block_t pair[2]) {
     // note, mask=-1, tag=-1 can never match a tag since this
     // pattern has the invalid bit set
-    return (int)lfs_dir_fetchmatch(dir, pair, (lfs_tag_t)-1, (lfs_tag_t)-1, NULL, NULL, NULL);
+    return (int)lfs_dir_fetchmatch(lfs, dir, pair,
+            (lfs_tag_t)-1, (lfs_tag_t)-1, NULL, NULL, NULL);
 }
 
-static int lfs_dir_getgstate(const lfs_mdir_t* dir, lfs_gstate_t* gstate) {
+static int lfs_dir_getgstate(lfs_t *lfs, const lfs_mdir_t *dir,
+        lfs_gstate_t *gstate) {
     lfs_gstate_t temp;
-    lfs_stag_t res = lfs_dir_get(dir, LFS_MKTAG(0x7ff, 0, 0),
-                                 LFS_MKTAG(LFS_TYPE_MOVESTATE, 0, sizeof(temp)), &temp);
+    lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x7ff, 0, 0),
+            LFS_MKTAG(LFS_TYPE_MOVESTATE, 0, sizeof(temp)), &temp);
     if (res < 0 && res != LFS_ERR_NOENT) {
         return res;
     }
@@ -1021,19 +1406,20 @@ static int lfs_dir_getgstate(const lfs_mdir_t* dir, lfs_gstate_t* gstate) {
         lfs_gstate_xor(gstate, &temp);
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 
-static int lfs_dir_getinfo(lfs_mdir_t* dir, uint16_t id, struct lfs_info* info) {
+static int lfs_dir_getinfo(lfs_t *lfs, lfs_mdir_t *dir,
+        uint16_t id, struct lfs_info *info) {
     if (id == 0x3ff) {
         // special case for root
         strcpy(info->name, "/");
         info->type = LFS_TYPE_DIR;
-        return LFS_ERR_OK;
+        return 0;
     }
 
-    lfs_stag_t tag = lfs_dir_get(dir, LFS_MKTAG(0x780, 0x3ff, 0),
-                                 LFS_MKTAG(LFS_TYPE_NAME, id, lfs.name_max + 1), info->name);
+    lfs_stag_t tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x780, 0x3ff, 0),
+            LFS_MKTAG(LFS_TYPE_NAME, id, lfs->name_max+1), info->name);
     if (tag < 0) {
         return (int)tag;
     }
@@ -1041,8 +1427,8 @@ static int lfs_dir_getinfo(lfs_mdir_t* dir, uint16_t id, struct lfs_info* info)
     info->type = lfs_tag_type3(tag);
 
     struct lfs_ctz ctz;
-    tag = lfs_dir_get(dir, LFS_MKTAG(0x700, 0x3ff, 0), LFS_MKTAG(LFS_TYPE_STRUCT, id, sizeof(ctz)),
-                      &ctz);
+    tag = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),
+            LFS_MKTAG(LFS_TYPE_STRUCT, id, sizeof(ctz)), &ctz);
     if (tag < 0) {
         return (int)tag;
     }
@@ -1054,10 +1440,11 @@ static int lfs_dir_getinfo(lfs_mdir_t* dir, uint16_t id, struct lfs_info* info)
         info->size = lfs_tag_size(tag);
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 
 struct lfs_dir_find_match {
+    lfs_t *lfs;
     const void *name;
     lfs_size_t size;
 };
@@ -1065,11 +1452,14 @@ struct lfs_dir_find_match {
 static int lfs_dir_find_match(void *data,
         lfs_tag_t tag, const void *buffer) {
     struct lfs_dir_find_match *name = data;
+    lfs_t *lfs = name->lfs;
     const struct lfs_diskoff *disk = buffer;
 
     // compare with disk
     lfs_size_t diff = lfs_min(name->size, lfs_tag_size(tag));
-    int res = lfs_bd_cmp(NULL, &lfs.rcache, diff, disk->block, disk->off, name->name, diff);
+    int res = lfs_bd_cmp(lfs,
+            NULL, &lfs->rcache, diff,
+            disk->block, disk->off, name->name, diff);
     if (res != LFS_CMP_EQ) {
         return res;
     }
@@ -1083,31 +1473,46 @@ static int lfs_dir_find_match(void *data,
     return LFS_CMP_EQ;
 }
 
-static lfs_stag_t lfs_dir_find(lfs_mdir_t* dir, const char** path, uint16_t* id) {
+// lfs_dir_find tries to set path and id even if file is not found
+//
+// returns:
+// - 0                  if file is found
+// - LFS_ERR_NOENT      if file or parent is not found
+// - LFS_ERR_NOTDIR     if parent is not a dir
+static lfs_stag_t lfs_dir_find(lfs_t *lfs, lfs_mdir_t *dir,
+        const char **path, uint16_t *id) {
     // we reduce path to a single name if we can find it
     const char *name = *path;
-    if (id) {
-        *id = 0x3ff;
-    }
 
     // default to root dir
     lfs_stag_t tag = LFS_MKTAG(LFS_TYPE_DIR, 0x3ff, 0);
-    dir->tail[0] = lfs.root[0];
-    dir->tail[1] = lfs.root[1];
+    dir->tail[0] = lfs->root[0];
+    dir->tail[1] = lfs->root[1];
+
+    // empty paths are not allowed
+    if (*name == '\0') {
+        return LFS_ERR_INVAL;
+    }
 
     while (true) {
 nextname:
-        // skip slashes
-        name += strspn(name, "/");
+        // skip slashes if we're a directory
+        if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {
+            name += strspn(name, "/");
+        }
         lfs_size_t namelen = strcspn(name, "/");
 
-        // skip '.' and root '..'
-        if ((namelen == 1 && memcmp(name, ".", 1) == 0) ||
-            (namelen == 2 && memcmp(name, "..", 2) == 0)) {
+        // skip '.'
+        if (namelen == 1 && memcmp(name, ".", 1) == 0) {
             name += namelen;
             goto nextname;
         }
 
+        // error on unmatched '..', trying to go above root?
+        if (namelen == 2 && memcmp(name, "..", 2) == 0) {
+            return LFS_ERR_INVAL;
+        }
+
         // skip if matched by '..' in name
         const char *suffix = name + namelen;
         lfs_size_t sufflen;
@@ -1119,7 +1524,9 @@ nextname:
                 break;
             }
 
-            if (sufflen == 2 && memcmp(suffix, "..", 2) == 0) {
+            if (sufflen == 1 && memcmp(suffix, ".", 1) == 0) {
+                // noop
+            } else if (sufflen == 2 && memcmp(suffix, "..", 2) == 0) {
                 depth -= 1;
                 if (depth == 0) {
                     name = suffix + sufflen;
@@ -1133,22 +1540,22 @@ nextname:
         }
 
         // found path
-        if (name[0] == '\0') {
+        if (*name == '\0') {
             return tag;
         }
 
         // update what we've found so far
         *path = name;
 
-        // only continue if we hit a directory
+        // only continue if we're a directory
         if (lfs_tag_type3(tag) != LFS_TYPE_DIR) {
             return LFS_ERR_NOTDIR;
         }
 
         // grab the entry data
         if (lfs_tag_id(tag) != 0x3ff) {
-            lfs_stag_t res = lfs_dir_get(dir, LFS_MKTAG(0x700, 0x3ff, 0),
-                                         LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), dir->tail);
+            lfs_stag_t res = lfs_dir_get(lfs, dir, LFS_MKTAG(0x700, 0x3ff, 0),
+                    LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), dir->tail);
             if (res < 0) {
                 return res;
             }
@@ -1157,11 +1564,12 @@ nextname:
 
         // find entry matching name
         while (true) {
-            tag = lfs_dir_fetchmatch(dir, dir->tail, LFS_MKTAG(0x780, 0, 0),
-                                     LFS_MKTAG(LFS_TYPE_NAME, 0, namelen),
-                                     // are we last name?
-                                     (strchr(name, '/') == NULL) ? id : NULL, lfs_dir_find_match,
-                                     &(struct lfs_dir_find_match){name, namelen});
+            tag = lfs_dir_fetchmatch(lfs, dir, dir->tail,
+                    LFS_MKTAG(0x780, 0, 0),
+                    LFS_MKTAG(LFS_TYPE_NAME, 0, namelen),
+                    id,
+                    lfs_dir_find_match, &(struct lfs_dir_find_match){
+                        lfs, name, namelen});
             if (tag < 0) {
                 return tag;
             }
@@ -1192,21 +1600,25 @@ struct lfs_commit {
 };
 
 #ifndef LFS_READONLY
-static int lfs_dir_commitprog(struct lfs_commit* commit, const void* buffer, lfs_size_t size) {
-    int err = lfs_bd_prog(&lfs.pcache, &lfs.rcache, false, commit->block, commit->off,
-                          (const uint8_t*)buffer, size);
+static int lfs_dir_commitprog(lfs_t *lfs, struct lfs_commit *commit,
+        const void *buffer, lfs_size_t size) {
+    int err = lfs_bd_prog(lfs,
+            &lfs->pcache, &lfs->rcache, false,
+            commit->block, commit->off ,
+            (const uint8_t*)buffer, size);
     if (err) {
         return err;
     }
 
     commit->crc = lfs_crc(commit->crc, buffer, size);
     commit->off += size;
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_dir_commitattr(struct lfs_commit* commit, lfs_tag_t tag, const void* buffer) {
+static int lfs_dir_commitattr(lfs_t *lfs, struct lfs_commit *commit,
+        lfs_tag_t tag, const void *buffer) {
     // check if we fit
     lfs_size_t dsize = lfs_tag_dsize(tag);
     if (commit->off + dsize > commit->end) {
@@ -1215,14 +1627,14 @@ static int lfs_dir_commitattr(struct lfs_commit* commit, lfs_tag_t tag, const vo
 
     // write out tag
     lfs_tag_t ntag = lfs_tobe32((tag & 0x7fffffff) ^ commit->ptag);
-    int err = lfs_dir_commitprog(commit, &ntag, sizeof(ntag));
+    int err = lfs_dir_commitprog(lfs, commit, &ntag, sizeof(ntag));
     if (err) {
         return err;
     }
 
     if (!(tag & 0x80000000)) {
         // from memory
-        err = lfs_dir_commitprog(commit, buffer, dsize - sizeof(tag));
+        err = lfs_dir_commitprog(lfs, commit, buffer, dsize-sizeof(tag));
         if (err) {
             return err;
         }
@@ -1232,13 +1644,14 @@ static int lfs_dir_commitattr(struct lfs_commit* commit, lfs_tag_t tag, const vo
         for (lfs_off_t i = 0; i < dsize-sizeof(tag); i++) {
             // rely on caching to make this efficient
             uint8_t dat;
-            err = lfs_bd_read(NULL, &lfs.rcache, dsize - sizeof(tag) - i, disk->block,
-                              disk->off + i, &dat, 1);
+            err = lfs_bd_read(lfs,
+                    NULL, &lfs->rcache, dsize-sizeof(tag)-i,
+                    disk->block, disk->off+i, &dat, 1);
             if (err) {
                 return err;
             }
 
-            err = lfs_dir_commitprog(commit, &dat, 1);
+            err = lfs_dir_commitprog(lfs, commit, &dat, 1);
             if (err) {
                 return err;
             }
@@ -1246,14 +1659,21 @@ static int lfs_dir_commitattr(struct lfs_commit* commit, lfs_tag_t tag, const vo
     }
 
     commit->ptag = tag & 0x7fffffff;
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_dir_commitcrc(struct lfs_commit* commit) {
+
+static int lfs_dir_commitcrc(lfs_t *lfs, struct lfs_commit *commit) {
     // align to program units
-    const lfs_off_t end = lfs_alignup(commit->off + 2 * sizeof(uint32_t), lfs.cfg->prog_size);
+    //
+    // this gets a bit complex as we have two types of crcs:
+    // - 5-word crc with fcrc to check following prog (middle of block)
+    // - 2-word crc with no following prog (end of block)
+    const lfs_off_t end = lfs_alignup(
+            lfs_min(commit->off + 5*sizeof(uint32_t), lfs->cfg->block_size),
+            lfs->cfg->prog_size);
 
     lfs_off_t off1 = 0;
     uint32_t crc1 = 0;
@@ -1262,109 +1682,152 @@ static int lfs_dir_commitcrc(struct lfs_commit* commit) {
     // padding is not crced, which lets fetches skip padding but
     // makes committing a bit more complicated
     while (commit->off < end) {
-        lfs_off_t off = commit->off + sizeof(lfs_tag_t);
-        lfs_off_t noff = lfs_min(end - off, 0x3fe) + off;
+        lfs_off_t noff = (
+                lfs_min(end - (commit->off+sizeof(lfs_tag_t)), 0x3fe)
+                + (commit->off+sizeof(lfs_tag_t)));
+        // too large for crc tag? need padding commits
         if (noff < end) {
-            noff = lfs_min(noff, end - 2*sizeof(uint32_t));
-        }
+            noff = lfs_min(noff, end - 5*sizeof(uint32_t));
+        }
+
+        // space for fcrc?
+        uint8_t eperturb = (uint8_t)-1;
+        if (noff >= end && noff <= lfs->cfg->block_size - lfs->cfg->prog_size) {
+            // first read the leading byte, this always contains a bit
+            // we can perturb to avoid writes that don't change the fcrc
+            int err = lfs_bd_read(lfs,
+                    NULL, &lfs->rcache, lfs->cfg->prog_size,
+                    commit->block, noff, &eperturb, 1);
+            if (err && err != LFS_ERR_CORRUPT) {
+                return err;
+            }
 
-        // read erased state from next program unit
-        lfs_tag_t tag = 0xffffffff;
-        int err =
-            lfs_bd_read(NULL, &lfs.rcache, sizeof(tag), commit->block, noff, &tag, sizeof(tag));
-        if (err && err != LFS_ERR_CORRUPT) {
-            return err;
-        }
+        #ifdef LFS_MULTIVERSION
+            // unfortunately fcrcs break mdir fetching < lfs2.1, so only write
+            // these if we're a >= lfs2.1 filesystem
+            if (lfs_fs_disk_version(lfs) <= 0x00020000) {
+                // don't write fcrc
+            } else
+        #endif
+            {
+                // find the expected fcrc, don't bother avoiding a reread
+                // of the eperturb, it should still be in our cache
+                struct lfs_fcrc fcrc = {
+                    .size = lfs->cfg->prog_size,
+                    .crc = 0xffffffff
+                };
+                err = lfs_bd_crc(lfs,
+                        NULL, &lfs->rcache, lfs->cfg->prog_size,
+                        commit->block, noff, fcrc.size, &fcrc.crc);
+                if (err && err != LFS_ERR_CORRUPT) {
+                    return err;
+                }
 
-        // build crc tag
-        bool reset = ~lfs_frombe32(tag) >> 31;
-        tag = LFS_MKTAG(LFS_TYPE_CRC + reset, 0x3ff, noff - off);
+                lfs_fcrc_tole32(&fcrc);
+                err = lfs_dir_commitattr(lfs, commit,
+                        LFS_MKTAG(LFS_TYPE_FCRC, 0x3ff, sizeof(struct lfs_fcrc)),
+                        &fcrc);
+                if (err) {
+                    return err;
+                }
+            }
+        }
 
-        // write out crc
-        uint32_t footer[2];
-        footer[0] = lfs_tobe32(tag ^ commit->ptag);
-        commit->crc = lfs_crc(commit->crc, &footer[0], sizeof(footer[0]));
-        footer[1] = lfs_tole32(commit->crc);
-        err = lfs_bd_prog(&lfs.pcache, &lfs.rcache, false, commit->block, commit->off, &footer,
-                          sizeof(footer));
+        // build commit crc
+        struct {
+            lfs_tag_t tag;
+            uint32_t crc;
+        } ccrc;
+        lfs_tag_t ntag = LFS_MKTAG(
+                LFS_TYPE_CCRC + (((uint8_t)~eperturb) >> 7), 0x3ff,
+                noff - (commit->off+sizeof(lfs_tag_t)));
+        ccrc.tag = lfs_tobe32(ntag ^ commit->ptag);
+        commit->crc = lfs_crc(commit->crc, &ccrc.tag, sizeof(lfs_tag_t));
+        ccrc.crc = lfs_tole32(commit->crc);
+
+        int err = lfs_bd_prog(lfs,
+                &lfs->pcache, &lfs->rcache, false,
+                commit->block, commit->off, &ccrc, sizeof(ccrc));
         if (err) {
             return err;
         }
 
         // keep track of non-padding checksum to verify
         if (off1 == 0) {
-            off1 = commit->off + sizeof(uint32_t);
+            off1 = commit->off + sizeof(lfs_tag_t);
             crc1 = commit->crc;
         }
 
-        commit->off += sizeof(tag)+lfs_tag_size(tag);
-        commit->ptag = tag ^ ((lfs_tag_t)reset << 31);
-        commit->crc = 0xffffffff; // reset crc for next "commit"
-    }
-
-    // flush buffers
-    int err = lfs_bd_sync(&lfs.pcache, &lfs.rcache, false);
-    if (err) {
-        return err;
-    }
-
-    // successful commit, check checksums to make sure
-    lfs_off_t off = commit->begin;
-    lfs_off_t noff = off1;
-    while (off < end) {
-        uint32_t crc = 0xffffffff;
-        for (lfs_off_t i = off; i < noff+sizeof(uint32_t); i++) {
-            // check against written crc, may catch blocks that
-            // become readonly and match our commit size exactly
-            if (i == off1 && crc != crc1) {
-                return LFS_ERR_CORRUPT;
-            }
+        commit->off = noff;
+        // perturb valid bit?
+        commit->ptag = ntag ^ ((0x80UL & ~eperturb) << 24);
+        // reset crc for next commit
+        commit->crc = 0xffffffff;
 
-            // leave it up to caching to make this efficient
-            uint8_t dat;
-            err = lfs_bd_read(NULL, &lfs.rcache, noff + sizeof(uint32_t) - i, commit->block, i,
-                              &dat, 1);
+        // manually flush here since we don't prog the padding, this confuses
+        // the caching layer
+        if (noff >= end || noff >= lfs->pcache.off + lfs->cfg->cache_size) {
+            // flush buffers
+            int err = lfs_bd_sync(lfs, &lfs->pcache, &lfs->rcache, false);
             if (err) {
                 return err;
             }
-
-            crc = lfs_crc(crc, &dat, 1);
-        }
-
-        // detected write error?
-        if (crc != 0) {
-            return LFS_ERR_CORRUPT;
-        }
-
-        // skip padding
-        off = lfs_min(end - noff, 0x3fe) + noff;
-        if (off < end) {
-            off = lfs_min(off, end - 2*sizeof(uint32_t));
         }
-        noff = off + sizeof(uint32_t);
     }
 
-    return LFS_ERR_OK;
+    // successful commit, check checksums to make sure
+    //
+    // note that we don't need to check padding commits, worst
+    // case if they are corrupted we would have had to compact anyways
+    lfs_off_t off = commit->begin;
+    uint32_t crc = 0xffffffff;
+    int err = lfs_bd_crc(lfs,
+            NULL, &lfs->rcache, off1+sizeof(uint32_t),
+            commit->block, off, off1-off, &crc);
+    if (err) {
+        return err;
+    }
+
+    // check non-padding commits against known crc
+    if (crc != crc1) {
+        return LFS_ERR_CORRUPT;
+    }
+
+    // make sure to check crc in case we happen to pick
+    // up an unrelated crc (frozen block?)
+    err = lfs_bd_crc(lfs,
+            NULL, &lfs->rcache, sizeof(uint32_t),
+            commit->block, off1, sizeof(uint32_t), &crc);
+    if (err) {
+        return err;
+    }
+
+    if (crc != 0) {
+        return LFS_ERR_CORRUPT;
+    }
+
+    return 0;
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_dir_alloc(lfs_mdir_t* dir) {
+static int lfs_dir_alloc(lfs_t *lfs, lfs_mdir_t *dir) {
     // allocate pair of dir blocks (backwards, so we write block 1 first)
     for (int i = 0; i < 2; i++) {
-        int err = lfs_alloc(&dir->pair[(i + 1) % 2]);
+        int err = lfs_alloc(lfs, &dir->pair[(i+1)%2]);
         if (err) {
             return err;
         }
     }
 
-    // zero for reproducability in case initial block is unreadable
+    // zero for reproducibility in case initial block is unreadable
     dir->rev = 0;
 
     // rather than clobbering one of the blocks we just pretend
     // the revision may be valid
-    int err = lfs_bd_read(NULL, &lfs.rcache, sizeof(dir->rev), dir->pair[0], 0, &dir->rev,
-                          sizeof(dir->rev));
+    int err = lfs_bd_read(lfs,
+            NULL, &lfs->rcache, sizeof(dir->rev),
+            dir->pair[0], 0, &dir->rev, sizeof(dir->rev));
     dir->rev = lfs_fromle32(dir->rev);
     if (err && err != LFS_ERR_CORRUPT) {
         return err;
@@ -1373,8 +1836,8 @@ static int lfs_dir_alloc(lfs_mdir_t* dir) {
     // to make sure we don't immediately evict, align the new revision count
     // to our block_cycles modulus, see lfs_dir_compact for why our modulus
     // is tweaked this way
-    if (lfs.cfg->block_cycles > 0) {
-        dir->rev = lfs_alignup(dir->rev, ((lfs.cfg->block_cycles + 1) | 1));
+    if (lfs->cfg->block_cycles > 0) {
+        dir->rev = lfs_alignup(dir->rev, ((lfs->cfg->block_cycles+1)|1));
     }
 
     // set defaults
@@ -1387,38 +1850,38 @@ static int lfs_dir_alloc(lfs_mdir_t* dir) {
     dir->split = false;
 
     // don't write out yet, let caller take care of that
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_dir_drop(lfs_mdir_t* dir, lfs_mdir_t* tail) {
+static int lfs_dir_drop(lfs_t *lfs, lfs_mdir_t *dir, lfs_mdir_t *tail) {
     // steal state
-    int err = lfs_dir_getgstate(tail, &lfs.gdelta);
+    int err = lfs_dir_getgstate(lfs, tail, &lfs->gdelta);
     if (err) {
         return err;
     }
 
     // steal tail
     lfs_pair_tole32(tail->tail);
-    err = lfs_dir_commit(
-        dir, LFS_MKATTRS({LFS_MKTAG(LFS_TYPE_TAIL + tail->split, 0x3ff, 8), tail->tail}));
+    err = lfs_dir_commit(lfs, dir, LFS_MKATTRS(
+            {LFS_MKTAG(LFS_TYPE_TAIL + tail->split, 0x3ff, 8), tail->tail}));
     lfs_pair_fromle32(tail->tail);
     if (err) {
         return err;
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_dir_split(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int attrcount,
-                         lfs_mdir_t* source, uint16_t split, uint16_t end) {
-    // create tail directory
-    lfs_alloc_ack();
+static int lfs_dir_split(lfs_t *lfs,
+        lfs_mdir_t *dir, const struct lfs_mattr *attrs, int attrcount,
+        lfs_mdir_t *source, uint16_t split, uint16_t end) {
+    // create tail metadata pair
     lfs_mdir_t tail;
-    int err = lfs_dir_alloc(&tail);
+    int err = lfs_dir_alloc(lfs, &tail);
     if (err) {
         return err;
     }
@@ -1427,9 +1890,10 @@ static int lfs_dir_split(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int att
     tail.tail[0] = dir->tail[0];
     tail.tail[1] = dir->tail[1];
 
-    err = lfs_dir_compact(&tail, attrs, attrcount, source, split, end);
-    if (err) {
-        return err;
+    // note we don't care about LFS_OK_RELOCATED
+    int res = lfs_dir_compact(lfs, &tail, attrs, attrcount, source, split, end);
+    if (res < 0) {
+        return res;
     }
 
     dir->tail[0] = tail.pair[0];
@@ -1437,12 +1901,12 @@ static int lfs_dir_split(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int att
     dir->split = true;
 
     // update root if needed
-    if (lfs_pair_cmp(dir->pair, lfs.root) == 0 && split == 0) {
-        lfs.root[0] = tail.pair[0];
-        lfs.root[1] = tail.pair[1];
+    if (lfs_pair_cmp(dir->pair, lfs->root) == 0 && split == 0) {
+        lfs->root[0] = tail.pair[0];
+        lfs->root[1] = tail.pair[1];
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
@@ -1452,12 +1916,13 @@ static int lfs_dir_commit_size(void *p, lfs_tag_t tag, const void *buffer) {
     (void)buffer;
 
     *size += lfs_tag_dsize(tag);
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
 #ifndef LFS_READONLY
 struct lfs_dir_commit_commit {
+    lfs_t *lfs;
     struct lfs_commit *commit;
 };
 #endif
@@ -1465,96 +1930,49 @@ struct lfs_dir_commit_commit {
 #ifndef LFS_READONLY
 static int lfs_dir_commit_commit(void *p, lfs_tag_t tag, const void *buffer) {
     struct lfs_dir_commit_commit *commit = p;
-    return lfs_dir_commitattr(commit->commit, tag, buffer);
+    return lfs_dir_commitattr(commit->lfs, commit->commit, tag, buffer);
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_dir_compact(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int attrcount,
-                           lfs_mdir_t* source, uint16_t begin, uint16_t end) {
-    // save some state in case block is bad
-    const lfs_block_t oldpair[2] = {dir->pair[0], dir->pair[1]};
-    bool relocated = false;
-    bool tired = false;
-
-    // should we split?
-    while (end - begin > 1) {
-        // find size
-        lfs_size_t size = 0;
-        int err = lfs_dir_traverse(source, 0, 0xffffffff, attrs, attrcount,
-                                   LFS_MKTAG(0x400, 0x3ff, 0), LFS_MKTAG(LFS_TYPE_NAME, 0, 0),
-                                   begin, end, -begin, lfs_dir_commit_size, &size);
-        if (err) {
-            return err;
-        }
-
-        // space is complicated, we need room for tail, crc, gstate,
-        // cleanup delete, and we cap at half a block to give room
-        // for metadata updates.
-        if (end - begin < 0xff &&
-            size <= lfs_min(lfs.cfg->block_size - 36,
-                            lfs_alignup((lfs.cfg->metadata_max ? lfs.cfg->metadata_max
-                                                               : lfs.cfg->block_size) /
-                                            2,
-                                        lfs.cfg->prog_size))) {
-            break;
-        }
-
-        // can't fit, need to split, we should really be finding the
-        // largest size that fits with a small binary search, but right now
-        // it's not worth the code size
-        uint16_t split = (end - begin) / 2;
-        err = lfs_dir_split(dir, attrs, attrcount, source, begin + split, end);
-        if (err) {
-            // if we fail to split, we may be able to overcompact, unless
-            // we're too big for even the full block, in which case our
-            // only option is to error
-            if (err == LFS_ERR_NOSPC && size <= lfs.cfg->block_size - 36) {
-                break;
-            }
-            return err;
-        }
-
-        end = begin + split;
-    }
-
-    // increment revision count
-    dir->rev += 1;
+static bool lfs_dir_needsrelocation(lfs_t *lfs, lfs_mdir_t *dir) {
     // If our revision count == n * block_cycles, we should force a relocation,
     // this is how littlefs wear-levels at the metadata-pair level. Note that we
     // actually use (block_cycles+1)|1, this is to avoid two corner cases:
     // 1. block_cycles = 1, which would prevent relocations from terminating
     // 2. block_cycles = 2n, which, due to aliasing, would only ever relocate
     //    one metadata block in the pair, effectively making this useless
-    if (lfs.cfg->block_cycles > 0 && (dir->rev % ((lfs.cfg->block_cycles + 1) | 1) == 0)) {
-        if (lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) == 0) {
-            // oh no! we're writing too much to the superblock,
-            // should we expand?
-            lfs_ssize_t res = lfs_fs_rawsize();
-            if (res < 0) {
-                return res;
-            }
+    return (lfs->cfg->block_cycles > 0
+            && ((dir->rev + 1) % ((lfs->cfg->block_cycles+1)|1) == 0));
+}
+#endif
 
-            // do we have extra space? littlefs can't reclaim this space
-            // by itself, so expand cautiously
-            if ((lfs_size_t)res < lfs.cfg->block_count / 2) {
-                LFS_DEBUG("Expanding superblock at rev %"PRIu32, dir->rev);
-                int err = lfs_dir_split(dir, attrs, attrcount, source, begin, end);
-                if (err && err != LFS_ERR_NOSPC) {
-                    return err;
-                }
+#ifndef LFS_READONLY
+static int lfs_dir_compact(lfs_t *lfs,
+        lfs_mdir_t *dir, const struct lfs_mattr *attrs, int attrcount,
+        lfs_mdir_t *source, uint16_t begin, uint16_t end) {
+    // save some state in case block is bad
+    bool relocated = false;
+    bool tired = lfs_dir_needsrelocation(lfs, dir);
 
-                // welp, we tried, if we ran out of space there's not much
-                // we can do, we'll error later if we've become frozen
-                if (!err) {
-                    end = begin;
-                }
-            }
-        } else {
-            // we're writing too much, time to relocate
-            tired = true;
-            goto relocate;
-        }
+    // increment revision count
+    dir->rev += 1;
+
+    // do not proactively relocate blocks during migrations, this
+    // can cause a number of failure states such: clobbering the
+    // v1 superblock if we relocate root, and invalidating directory
+    // pointers if we relocate the head of a directory. On top of
+    // this, relocations increase the overall complexity of
+    // lfs_migration, which is already a delicate operation.
+#ifdef LFS_MIGRATE
+    if (lfs->lfs1) {
+        tired = false;
+    }
+#endif
+
+    if (tired && lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) != 0) {
+        // we're writing too much, time to relocate
+        goto relocate;
     }
 
     // begin loop to commit compaction to blocks until a compact sticks
@@ -1568,11 +1986,12 @@ static int lfs_dir_compact(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int a
                 .crc = 0xffffffff,
 
                 .begin = 0,
-                .end = (lfs.cfg->metadata_max ? lfs.cfg->metadata_max : lfs.cfg->block_size) - 8,
+                .end = (lfs->cfg->metadata_max ?
+                    lfs->cfg->metadata_max : lfs->cfg->block_size) - 8,
             };
 
             // erase block to write to
-            int err = lfs_bd_erase(dir->pair[1]);
+            int err = lfs_bd_erase(lfs, dir->pair[1]);
             if (err) {
                 if (err == LFS_ERR_CORRUPT) {
                     goto relocate;
@@ -1582,7 +2001,8 @@ static int lfs_dir_compact(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int a
 
             // write out header
             dir->rev = lfs_tole32(dir->rev);
-            err = lfs_dir_commitprog(&commit, &dir->rev, sizeof(dir->rev));
+            err = lfs_dir_commitprog(lfs, &commit,
+                    &dir->rev, sizeof(dir->rev));
             dir->rev = lfs_fromle32(dir->rev);
             if (err) {
                 if (err == LFS_ERR_CORRUPT) {
@@ -1592,10 +2012,13 @@ static int lfs_dir_compact(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int a
             }
 
             // traverse the directory, this time writing out all unique tags
-            err = lfs_dir_traverse(source, 0, 0xffffffff, attrs, attrcount,
-                                   LFS_MKTAG(0x400, 0x3ff, 0), LFS_MKTAG(LFS_TYPE_NAME, 0, 0),
-                                   begin, end, -begin, lfs_dir_commit_commit,
-                                   &(struct lfs_dir_commit_commit){&commit});
+            err = lfs_dir_traverse(lfs,
+                    source, 0, 0xffffffff, attrs, attrcount,
+                    LFS_MKTAG(0x400, 0x3ff, 0),
+                    LFS_MKTAG(LFS_TYPE_NAME, 0, 0),
+                    begin, end, -begin,
+                    lfs_dir_commit_commit, &(struct lfs_dir_commit_commit){
+                        lfs, &commit});
             if (err) {
                 if (err == LFS_ERR_CORRUPT) {
                     goto relocate;
@@ -1606,8 +2029,9 @@ static int lfs_dir_compact(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int a
             // commit tail, which may be new after last size check
             if (!lfs_pair_isnull(dir->tail)) {
                 lfs_pair_tole32(dir->tail);
-                err = lfs_dir_commitattr(&commit, LFS_MKTAG(LFS_TYPE_TAIL + dir->split, 0x3ff, 8),
-                                         dir->tail);
+                err = lfs_dir_commitattr(lfs, &commit,
+                        LFS_MKTAG(LFS_TYPE_TAIL + dir->split, 0x3ff, 8),
+                        dir->tail);
                 lfs_pair_fromle32(dir->tail);
                 if (err) {
                     if (err == LFS_ERR_CORRUPT) {
@@ -1620,21 +2044,22 @@ static int lfs_dir_compact(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int a
             // bring over gstate?
             lfs_gstate_t delta = {0};
             if (!relocated) {
-                lfs_gstate_xor(&delta, &lfs.gdisk);
-                lfs_gstate_xor(&delta, &lfs.gstate);
+                lfs_gstate_xor(&delta, &lfs->gdisk);
+                lfs_gstate_xor(&delta, &lfs->gstate);
             }
-            lfs_gstate_xor(&delta, &lfs.gdelta);
+            lfs_gstate_xor(&delta, &lfs->gdelta);
             delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);
 
-            err = lfs_dir_getgstate(dir, &delta);
+            err = lfs_dir_getgstate(lfs, dir, &delta);
             if (err) {
                 return err;
             }
 
             if (!lfs_gstate_iszero(&delta)) {
                 lfs_gstate_tole32(&delta);
-                err = lfs_dir_commitattr(
-                    &commit, LFS_MKTAG(LFS_TYPE_MOVESTATE, 0x3ff, sizeof(delta)), &delta);
+                err = lfs_dir_commitattr(lfs, &commit,
+                        LFS_MKTAG(LFS_TYPE_MOVESTATE, 0x3ff,
+                            sizeof(delta)), &delta);
                 if (err) {
                     if (err == LFS_ERR_CORRUPT) {
                         goto relocate;
@@ -1644,7 +2069,7 @@ static int lfs_dir_compact(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int a
             }
 
             // complete commit with crc
-            err = lfs_dir_commitcrc(&commit);
+            err = lfs_dir_commitcrc(lfs, &commit);
             if (err) {
                 if (err == LFS_ERR_CORRUPT) {
                     goto relocate;
@@ -1653,15 +2078,15 @@ static int lfs_dir_compact(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int a
             }
 
             // successful compaction, swap dir pair to indicate most recent
-            LFS_ASSERT(commit.off % lfs.cfg->prog_size == 0);
+            LFS_ASSERT(commit.off % lfs->cfg->prog_size == 0);
             lfs_pair_swap(dir->pair);
             dir->count = end - begin;
             dir->off = commit.off;
             dir->etag = commit.ptag;
             // update gstate
-            lfs.gdelta = (lfs_gstate_t){0};
+            lfs->gdelta = (lfs_gstate_t){0};
             if (!relocated) {
-                lfs.gdisk = lfs.gstate;
+                lfs->gdisk = lfs->gstate;
             }
         }
         break;
@@ -1669,7 +2094,7 @@ static int lfs_dir_compact(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int a
 relocate:
         // commit was corrupted, drop caches and prepare to relocate block
         relocated = true;
-        lfs_cache_drop(&lfs.pcache);
+        lfs_cache_drop(lfs, &lfs->pcache);
         if (!tired) {
             LFS_DEBUG("Bad block at 0x%"PRIx32, dir->pair[1]);
         }
@@ -1682,7 +2107,7 @@ relocate:
         }
 
         // relocate half of pair
-        int err = lfs_alloc(&dir->pair[1]);
+        int err = lfs_alloc(lfs, &dir->pair[1]);
         if (err && (err != LFS_ERR_NOSPC || !tired)) {
             return err;
         }
@@ -1691,42 +2116,127 @@ relocate:
         continue;
     }
 
-    if (relocated) {
-        // update references if we relocated
-        LFS_DEBUG("Relocating {0x%"PRIx32", 0x%"PRIx32"} "
-                    "-> {0x%"PRIx32", 0x%"PRIx32"}",
-                oldpair[0], oldpair[1], dir->pair[0], dir->pair[1]);
-        int err = lfs_fs_relocate(oldpair, dir->pair);
-        if (err) {
-            return err;
-        }
-    }
-
-    return LFS_ERR_OK;
+    return relocated ? LFS_OK_RELOCATED : 0;
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_dir_commit(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int attrcount) {
-    // check for any inline files that aren't RAM backed and
-    // forcefully evict them, needed for filesystem consistency
-    for (lfs_file_t* f = (lfs_file_t*)lfs.mlist; f; f = f->next) {
-        if (dir != &f->m && lfs_pair_cmp(f->m.pair, dir->pair) == 0 && f->type == LFS_TYPE_REG &&
-            (f->flags & LFS_F_INLINE) && f->ctz.size > lfs.cfg->cache_size) {
-            int err = lfs_file_outline(f);
+static int lfs_dir_splittingcompact(lfs_t *lfs, lfs_mdir_t *dir,
+        const struct lfs_mattr *attrs, int attrcount,
+        lfs_mdir_t *source, uint16_t begin, uint16_t end) {
+    while (true) {
+        // find size of first split, we do this by halving the split until
+        // the metadata is guaranteed to fit
+        //
+        // Note that this isn't a true binary search, we never increase the
+        // split size. This may result in poorly distributed metadata but isn't
+        // worth the extra code size or performance hit to fix.
+        lfs_size_t split = begin;
+        while (end - split > 1) {
+            lfs_size_t size = 0;
+            int err = lfs_dir_traverse(lfs,
+                    source, 0, 0xffffffff, attrs, attrcount,
+                    LFS_MKTAG(0x400, 0x3ff, 0),
+                    LFS_MKTAG(LFS_TYPE_NAME, 0, 0),
+                    split, end, -split,
+                    lfs_dir_commit_size, &size);
             if (err) {
                 return err;
             }
 
-            err = lfs_file_flush(f);
-            if (err) {
+            // space is complicated, we need room for:
+            //
+            // - tail:         4+2*4 = 12 bytes
+            // - gstate:       4+3*4 = 16 bytes
+            // - move delete:  4     = 4 bytes
+            // - crc:          4+4   = 8 bytes
+            //                 total = 40 bytes
+            //
+            // And we cap at half a block to avoid degenerate cases with
+            // nearly-full metadata blocks.
+            //
+            lfs_size_t metadata_max = (lfs->cfg->metadata_max)
+                    ? lfs->cfg->metadata_max
+                    : lfs->cfg->block_size;
+            if (end - split < 0xff
+                    && size <= lfs_min(
+                        metadata_max - 40,
+                        lfs_alignup(
+                            metadata_max/2,
+                            lfs->cfg->prog_size))) {
+                break;
+            }
+
+            split = split + ((end - split) / 2);
+        }
+
+        if (split == begin) {
+            // no split needed
+            break;
+        }
+
+        // split into two metadata pairs and continue
+        int err = lfs_dir_split(lfs, dir, attrs, attrcount,
+                source, split, end);
+        if (err && err != LFS_ERR_NOSPC) {
+            return err;
+        }
+
+        if (err) {
+            // we can't allocate a new block, try to compact with degraded
+            // performance
+            LFS_WARN("Unable to split {0x%"PRIx32", 0x%"PRIx32"}",
+                    dir->pair[0], dir->pair[1]);
+            break;
+        } else {
+            end = split;
+        }
+    }
+
+    if (lfs_dir_needsrelocation(lfs, dir)
+            && lfs_pair_cmp(dir->pair, (const lfs_block_t[2]){0, 1}) == 0) {
+        // oh no! we're writing too much to the superblock,
+        // should we expand?
+        lfs_ssize_t size = lfs_fs_size_(lfs);
+        if (size < 0) {
+            return size;
+        }
+
+        // littlefs cannot reclaim expanded superblocks, so expand cautiously
+        //
+        // if our filesystem is more than ~88% full, don't expand, this is
+        // somewhat arbitrary
+        if (lfs->block_count - size > lfs->block_count/8) {
+            LFS_DEBUG("Expanding superblock at rev %"PRIu32, dir->rev);
+            int err = lfs_dir_split(lfs, dir, attrs, attrcount,
+                    source, begin, end);
+            if (err && err != LFS_ERR_NOSPC) {
                 return err;
             }
+
+            if (err) {
+                // welp, we tried, if we ran out of space there's not much
+                // we can do, we'll error later if we've become frozen
+                LFS_WARN("Unable to expand superblock");
+            } else {
+                // duplicate the superblock entry into the new superblock
+                end = 1;
+            }
         }
     }
 
+    return lfs_dir_compact(lfs, dir, attrs, attrcount, source, begin, end);
+}
+#endif
+
+#ifndef LFS_READONLY
+static int lfs_dir_relocatingcommit(lfs_t *lfs, lfs_mdir_t *dir,
+        const lfs_block_t pair[2],
+        const struct lfs_mattr *attrs, int attrcount,
+        lfs_mdir_t *pdir) {
+    int state = 0;
+
     // calculate changes to the directory
-    lfs_mdir_t olddir = *dir;
     bool hasdelete = false;
     for (int i = 0; i < attrcount; i++) {
         if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE) {
@@ -1745,23 +2255,19 @@ static int lfs_dir_commit(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int at
 
     // should we actually drop the directory block?
     if (hasdelete && dir->count == 0) {
-        lfs_mdir_t pdir;
-        int err = lfs_fs_pred(dir->pair, &pdir);
+        LFS_ASSERT(pdir);
+        int err = lfs_fs_pred(lfs, dir->pair, pdir);
         if (err && err != LFS_ERR_NOENT) {
-            *dir = olddir;
             return err;
         }
 
-        if (err != LFS_ERR_NOENT && pdir.split) {
-            err = lfs_dir_drop(&pdir, dir);
-            if (err) {
-                *dir = olddir;
-                return err;
-            }
+        if (err != LFS_ERR_NOENT && pdir->split) {
+            state = LFS_OK_DROPPED;
+            goto fixmlist;
         }
     }
 
-    if (dir->erased || dir->count >= 0xff) {
+    if (dir->erased) {
         // try to commit
         struct lfs_commit commit = {
             .block = dir->pair[0],
@@ -1770,76 +2276,82 @@ static int lfs_dir_commit(lfs_mdir_t* dir, const struct lfs_mattr* attrs, int at
             .crc = 0xffffffff,
 
             .begin = dir->off,
-            .end = (lfs.cfg->metadata_max ? lfs.cfg->metadata_max : lfs.cfg->block_size) - 8,
+            .end = (lfs->cfg->metadata_max ?
+                lfs->cfg->metadata_max : lfs->cfg->block_size) - 8,
         };
 
         // traverse attrs that need to be written out
         lfs_pair_tole32(dir->tail);
-        int err = lfs_dir_traverse(dir, dir->off, dir->etag, attrs, attrcount, 0, 0, 0, 0, 0,
-                                   lfs_dir_commit_commit, &(struct lfs_dir_commit_commit){&commit});
+        int err = lfs_dir_traverse(lfs,
+                dir, dir->off, dir->etag, attrs, attrcount,
+                0, 0, 0, 0, 0,
+                lfs_dir_commit_commit, &(struct lfs_dir_commit_commit){
+                    lfs, &commit});
         lfs_pair_fromle32(dir->tail);
         if (err) {
             if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {
                 goto compact;
             }
-            *dir = olddir;
             return err;
         }
 
         // commit any global diffs if we have any
         lfs_gstate_t delta = {0};
-        lfs_gstate_xor(&delta, &lfs.gstate);
-        lfs_gstate_xor(&delta, &lfs.gdisk);
-        lfs_gstate_xor(&delta, &lfs.gdelta);
+        lfs_gstate_xor(&delta, &lfs->gstate);
+        lfs_gstate_xor(&delta, &lfs->gdisk);
+        lfs_gstate_xor(&delta, &lfs->gdelta);
         delta.tag &= ~LFS_MKTAG(0, 0, 0x3ff);
         if (!lfs_gstate_iszero(&delta)) {
-            err = lfs_dir_getgstate(dir, &delta);
+            err = lfs_dir_getgstate(lfs, dir, &delta);
             if (err) {
-                *dir = olddir;
                 return err;
             }
 
             lfs_gstate_tole32(&delta);
-            err = lfs_dir_commitattr(&commit, LFS_MKTAG(LFS_TYPE_MOVESTATE, 0x3ff, sizeof(delta)),
-                                     &delta);
+            err = lfs_dir_commitattr(lfs, &commit,
+                    LFS_MKTAG(LFS_TYPE_MOVESTATE, 0x3ff,
+                        sizeof(delta)), &delta);
             if (err) {
                 if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {
                     goto compact;
                 }
-                *dir = olddir;
                 return err;
             }
         }
 
         // finalize commit with the crc
-        err = lfs_dir_commitcrc(&commit);
+        err = lfs_dir_commitcrc(lfs, &commit);
         if (err) {
             if (err == LFS_ERR_NOSPC || err == LFS_ERR_CORRUPT) {
                 goto compact;
             }
-            *dir = olddir;
             return err;
         }
 
         // successful commit, update dir
-        LFS_ASSERT(commit.off % lfs.cfg->prog_size == 0);
+        LFS_ASSERT(commit.off % lfs->cfg->prog_size == 0);
         dir->off = commit.off;
         dir->etag = commit.ptag;
         // and update gstate
-        lfs.gdisk = lfs.gstate;
-        lfs.gdelta = (lfs_gstate_t){0};
-    } else {
+        lfs->gdisk = lfs->gstate;
+        lfs->gdelta = (lfs_gstate_t){0};
+
+        goto fixmlist;
+    }
+
 compact:
-        // fall back to compaction
-        lfs_cache_drop(&lfs.pcache);
+    // fall back to compaction
+    lfs_cache_drop(lfs, &lfs->pcache);
 
-        int err = lfs_dir_compact(dir, attrs, attrcount, dir, 0, dir->count);
-        if (err) {
-            *dir = olddir;
-            return err;
-        }
+    state = lfs_dir_splittingcompact(lfs, dir, attrs, attrcount,
+            dir, 0, dir->count);
+    if (state < 0) {
+        return state;
     }
 
+    goto fixmlist;
+
+fixmlist:;
     // this complicated bit of logic is for fixing up any active
     // metadata-pairs that we may have affected
     //
@@ -1847,37 +2359,39 @@ compact:
     // lfs_dir_commit could also be in this list, and even then
     // we need to copy the pair so they don't get clobbered if we refetch
     // our mdir.
-    for (struct lfs_mlist* d = lfs.mlist; d; d = d->next) {
-        if (&d->m != dir && lfs_pair_cmp(d->m.pair, olddir.pair) == 0) {
+    lfs_block_t oldpair[2] = {pair[0], pair[1]};
+    for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
+        if (lfs_pair_cmp(d->m.pair, oldpair) == 0) {
             d->m = *dir;
-            for (int i = 0; i < attrcount; i++) {
-                if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
-                        d->id == lfs_tag_id(attrs[i].tag)) {
-                    d->m.pair[0] = LFS_BLOCK_NULL;
-                    d->m.pair[1] = LFS_BLOCK_NULL;
-                } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
-                        d->id > lfs_tag_id(attrs[i].tag)) {
-                    d->id -= 1;
-                    if (d->type == LFS_TYPE_DIR) {
-                        ((lfs_dir_t*)d)->pos -= 1;
-                    }
-                } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE &&
-                        d->id >= lfs_tag_id(attrs[i].tag)) {
-                    d->id += 1;
-                    if (d->type == LFS_TYPE_DIR) {
-                        ((lfs_dir_t*)d)->pos += 1;
+            if (d->m.pair != pair) {
+                for (int i = 0; i < attrcount; i++) {
+                    if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
+                            d->id == lfs_tag_id(attrs[i].tag) &&
+                            d->type != LFS_TYPE_DIR) {
+                        d->m.pair[0] = LFS_BLOCK_NULL;
+                        d->m.pair[1] = LFS_BLOCK_NULL;
+                    } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_DELETE &&
+                            d->id > lfs_tag_id(attrs[i].tag)) {
+                        d->id -= 1;
+                        if (d->type == LFS_TYPE_DIR) {
+                            ((lfs_dir_t*)d)->pos -= 1;
+                        }
+                    } else if (lfs_tag_type3(attrs[i].tag) == LFS_TYPE_CREATE &&
+                            d->id >= lfs_tag_id(attrs[i].tag)) {
+                        d->id += 1;
+                        if (d->type == LFS_TYPE_DIR) {
+                            ((lfs_dir_t*)d)->pos += 1;
+                        }
                     }
                 }
             }
-        }
-    }
 
-    for (struct lfs_mlist* d = lfs.mlist; d; d = d->next) {
-        if (lfs_pair_cmp(d->m.pair, olddir.pair) == 0) {
             while (d->id >= d->m.count && d->m.split) {
                 // we split and id is on tail now
-                d->id -= d->m.count;
-                int err = lfs_dir_fetch(&d->m, d->m.tail);
+                if (lfs_pair_cmp(d->m.tail, lfs->root) != 0) {
+                    d->id -= d->m.count;
+                }
+                int err = lfs_dir_fetch(lfs, &d->m, d->m.tail);
                 if (err) {
                     return err;
                 }
@@ -1885,38 +2399,253 @@ compact:
         }
     }
 
-    return LFS_ERR_OK;
+    return state;
+}
+#endif
+
+#ifndef LFS_READONLY
+static int lfs_dir_orphaningcommit(lfs_t *lfs, lfs_mdir_t *dir,
+        const struct lfs_mattr *attrs, int attrcount) {
+    // check for any inline files that aren't RAM backed and
+    // forcefully evict them, needed for filesystem consistency
+    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
+        if (dir != &f->m && lfs_pair_cmp(f->m.pair, dir->pair) == 0 &&
+                f->type == LFS_TYPE_REG && (f->flags & LFS_F_INLINE) &&
+                f->ctz.size > lfs->cfg->cache_size) {
+            int err = lfs_file_outline(lfs, f);
+            if (err) {
+                return err;
+            }
+
+            err = lfs_file_flush(lfs, f);
+            if (err) {
+                return err;
+            }
+        }
+    }
+
+    lfs_block_t lpair[2] = {dir->pair[0], dir->pair[1]};
+    lfs_mdir_t ldir = *dir;
+    lfs_mdir_t pdir;
+    int state = lfs_dir_relocatingcommit(lfs, &ldir, dir->pair,
+            attrs, attrcount, &pdir);
+    if (state < 0) {
+        return state;
+    }
+
+    // update if we're not in mlist, note we may have already been
+    // updated if we are in mlist
+    if (lfs_pair_cmp(dir->pair, lpair) == 0) {
+        *dir = ldir;
+    }
+
+    // commit was successful, but may require other changes in the
+    // filesystem, these would normally be tail recursive, but we have
+    // flattened them here avoid unbounded stack usage
+
+    // need to drop?
+    if (state == LFS_OK_DROPPED) {
+        // steal state
+        int err = lfs_dir_getgstate(lfs, dir, &lfs->gdelta);
+        if (err) {
+            return err;
+        }
+
+        // steal tail, note that this can't create a recursive drop
+        lpair[0] = pdir.pair[0];
+        lpair[1] = pdir.pair[1];
+        lfs_pair_tole32(dir->tail);
+        state = lfs_dir_relocatingcommit(lfs, &pdir, lpair, LFS_MKATTRS(
+                    {LFS_MKTAG(LFS_TYPE_TAIL + dir->split, 0x3ff, 8),
+                        dir->tail}),
+                NULL);
+        lfs_pair_fromle32(dir->tail);
+        if (state < 0) {
+            return state;
+        }
+
+        ldir = pdir;
+    }
+
+    // need to relocate?
+    bool orphans = false;
+    while (state == LFS_OK_RELOCATED) {
+        LFS_DEBUG("Relocating {0x%"PRIx32", 0x%"PRIx32"} "
+                    "-> {0x%"PRIx32", 0x%"PRIx32"}",
+                lpair[0], lpair[1], ldir.pair[0], ldir.pair[1]);
+        state = 0;
+
+        // update internal root
+        if (lfs_pair_cmp(lpair, lfs->root) == 0) {
+            lfs->root[0] = ldir.pair[0];
+            lfs->root[1] = ldir.pair[1];
+        }
+
+        // update internally tracked dirs
+        for (struct lfs_mlist *d = lfs->mlist; d; d = d->next) {
+            if (lfs_pair_cmp(lpair, d->m.pair) == 0) {
+                d->m.pair[0] = ldir.pair[0];
+                d->m.pair[1] = ldir.pair[1];
+            }
+
+            if (d->type == LFS_TYPE_DIR &&
+                    lfs_pair_cmp(lpair, ((lfs_dir_t*)d)->head) == 0) {
+                ((lfs_dir_t*)d)->head[0] = ldir.pair[0];
+                ((lfs_dir_t*)d)->head[1] = ldir.pair[1];
+            }
+        }
+
+        // find parent
+        lfs_stag_t tag = lfs_fs_parent(lfs, lpair, &pdir);
+        if (tag < 0 && tag != LFS_ERR_NOENT) {
+            return tag;
+        }
+
+        bool hasparent = (tag != LFS_ERR_NOENT);
+        if (tag != LFS_ERR_NOENT) {
+            // note that if we have a parent, we must have a pred, so this will
+            // always create an orphan
+            int err = lfs_fs_preporphans(lfs, +1);
+            if (err) {
+                return err;
+            }
+
+            // fix pending move in this pair? this looks like an optimization but
+            // is in fact _required_ since relocating may outdate the move.
+            uint16_t moveid = 0x3ff;
+            if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {
+                moveid = lfs_tag_id(lfs->gstate.tag);
+                LFS_DEBUG("Fixing move while relocating "
+                        "{0x%"PRIx32", 0x%"PRIx32"} 0x%"PRIx16"\n",
+                        pdir.pair[0], pdir.pair[1], moveid);
+                lfs_fs_prepmove(lfs, 0x3ff, NULL);
+                if (moveid < lfs_tag_id(tag)) {
+                    tag -= LFS_MKTAG(0, 1, 0);
+                }
+            }
+
+            lfs_block_t ppair[2] = {pdir.pair[0], pdir.pair[1]};
+            lfs_pair_tole32(ldir.pair);
+            state = lfs_dir_relocatingcommit(lfs, &pdir, ppair, LFS_MKATTRS(
+                        {LFS_MKTAG_IF(moveid != 0x3ff,
+                            LFS_TYPE_DELETE, moveid, 0), NULL},
+                        {tag, ldir.pair}),
+                    NULL);
+            lfs_pair_fromle32(ldir.pair);
+            if (state < 0) {
+                return state;
+            }
+
+            if (state == LFS_OK_RELOCATED) {
+                lpair[0] = ppair[0];
+                lpair[1] = ppair[1];
+                ldir = pdir;
+                orphans = true;
+                continue;
+            }
+        }
+
+        // find pred
+        int err = lfs_fs_pred(lfs, lpair, &pdir);
+        if (err && err != LFS_ERR_NOENT) {
+            return err;
+        }
+        LFS_ASSERT(!(hasparent && err == LFS_ERR_NOENT));
+
+        // if we can't find dir, it must be new
+        if (err != LFS_ERR_NOENT) {
+            if (lfs_gstate_hasorphans(&lfs->gstate)) {
+                // next step, clean up orphans
+                err = lfs_fs_preporphans(lfs, -(int8_t)hasparent);
+                if (err) {
+                    return err;
+                }
+            }
+
+            // fix pending move in this pair? this looks like an optimization
+            // but is in fact _required_ since relocating may outdate the move.
+            uint16_t moveid = 0x3ff;
+            if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {
+                moveid = lfs_tag_id(lfs->gstate.tag);
+                LFS_DEBUG("Fixing move while relocating "
+                        "{0x%"PRIx32", 0x%"PRIx32"} 0x%"PRIx16"\n",
+                        pdir.pair[0], pdir.pair[1], moveid);
+                lfs_fs_prepmove(lfs, 0x3ff, NULL);
+            }
+
+            // replace bad pair, either we clean up desync, or no desync occured
+            lpair[0] = pdir.pair[0];
+            lpair[1] = pdir.pair[1];
+            lfs_pair_tole32(ldir.pair);
+            state = lfs_dir_relocatingcommit(lfs, &pdir, lpair, LFS_MKATTRS(
+                        {LFS_MKTAG_IF(moveid != 0x3ff,
+                            LFS_TYPE_DELETE, moveid, 0), NULL},
+                        {LFS_MKTAG(LFS_TYPE_TAIL + pdir.split, 0x3ff, 8),
+                            ldir.pair}),
+                    NULL);
+            lfs_pair_fromle32(ldir.pair);
+            if (state < 0) {
+                return state;
+            }
+
+            ldir = pdir;
+        }
+    }
+
+    return orphans ? LFS_OK_ORPHANED : 0;
+}
+#endif
+
+#ifndef LFS_READONLY
+static int lfs_dir_commit(lfs_t *lfs, lfs_mdir_t *dir,
+        const struct lfs_mattr *attrs, int attrcount) {
+    int orphans = lfs_dir_orphaningcommit(lfs, dir, attrs, attrcount);
+    if (orphans < 0) {
+        return orphans;
+    }
+
+    if (orphans) {
+        // make sure we've removed all orphans, this is a noop if there
+        // are none, but if we had nested blocks failures we may have
+        // created some
+        int err = lfs_fs_deorphan(lfs, false);
+        if (err) {
+            return err;
+        }
+    }
+
+    return 0;
 }
 #endif
 
 
 /// Top level directory operations ///
 #ifndef LFS_READONLY
-static int lfs_rawmkdir(const char* path) {
+static int lfs_mkdir_(lfs_t *lfs, const char *path) {
     // deorphan if we haven't yet, needed at most once after poweron
-    int err = lfs_fs_forceconsistency();
+    int err = lfs_fs_forceconsistency(lfs);
     if (err) {
         return err;
     }
 
     struct lfs_mlist cwd;
-    cwd.next = lfs.mlist;
+    cwd.next = lfs->mlist;
     uint16_t id;
-    err = lfs_dir_find(&cwd.m, &path, &id);
-    if (!(err == LFS_ERR_NOENT && id != 0x3ff)) {
+    err = lfs_dir_find(lfs, &cwd.m, &path, &id);
+    if (!(err == LFS_ERR_NOENT && lfs_path_islast(path))) {
         return (err < 0) ? err : LFS_ERR_EXIST;
     }
 
     // check that name fits
-    lfs_size_t nlen = strlen(path);
-    if (nlen > lfs.name_max) {
+    lfs_size_t nlen = lfs_path_namelen(path);
+    if (nlen > lfs->name_max) {
         return LFS_ERR_NAMETOOLONG;
     }
 
     // build up new directory
-    lfs_alloc_ack();
+    lfs_alloc_ckpoint(lfs);
     lfs_mdir_t dir;
-    err = lfs_dir_alloc(&dir);
+    err = lfs_dir_alloc(lfs, &dir);
     if (err) {
         return err;
     }
@@ -1924,7 +2653,7 @@ static int lfs_rawmkdir(const char* path) {
     // find end of list
     lfs_mdir_t pred = cwd.m;
     while (pred.split) {
-        err = lfs_dir_fetch(&pred, pred.tail);
+        err = lfs_dir_fetch(lfs, &pred, pred.tail);
         if (err) {
             return err;
         }
@@ -1932,16 +2661,17 @@ static int lfs_rawmkdir(const char* path) {
 
     // setup dir
     lfs_pair_tole32(pred.tail);
-    err = lfs_dir_commit(&dir, LFS_MKATTRS({LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), pred.tail}));
+    err = lfs_dir_commit(lfs, &dir, LFS_MKATTRS(
+            {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), pred.tail}));
     lfs_pair_fromle32(pred.tail);
     if (err) {
         return err;
     }
 
-    // current block end of list?
+    // current block not end of list?
     if (cwd.m.split) {
         // update tails, this creates a desync
-        err = lfs_fs_preporphans(+1);
+        err = lfs_fs_preporphans(lfs, +1);
         if (err) {
             return err;
         }
@@ -1952,19 +2682,19 @@ static int lfs_rawmkdir(const char* path) {
         // ourselves into littlefs to catch this
         cwd.type = 0;
         cwd.id = 0;
-        lfs.mlist = &cwd;
+        lfs->mlist = &cwd;
 
         lfs_pair_tole32(dir.pair);
-        err =
-            lfs_dir_commit(&pred, LFS_MKATTRS({LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));
+        err = lfs_dir_commit(lfs, &pred, LFS_MKATTRS(
+                {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));
         lfs_pair_fromle32(dir.pair);
         if (err) {
-            lfs.mlist = cwd.next;
+            lfs->mlist = cwd.next;
             return err;
         }
 
-        lfs.mlist = cwd.next;
-        err = lfs_fs_preporphans(-1);
+        lfs->mlist = cwd.next;
+        err = lfs_fs_preporphans(lfs, -1);
         if (err) {
             return err;
         }
@@ -1972,22 +2702,23 @@ static int lfs_rawmkdir(const char* path) {
 
     // now insert into our parent block
     lfs_pair_tole32(dir.pair);
-    err = lfs_dir_commit(
-        &cwd.m, LFS_MKATTRS({LFS_MKTAG(LFS_TYPE_CREATE, id, 0), NULL},
-                            {LFS_MKTAG(LFS_TYPE_DIR, id, nlen), path},
-                            {LFS_MKTAG(LFS_TYPE_DIRSTRUCT, id, 8), dir.pair},
-                            {LFS_MKTAG_IF(!cwd.m.split, LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));
+    err = lfs_dir_commit(lfs, &cwd.m, LFS_MKATTRS(
+            {LFS_MKTAG(LFS_TYPE_CREATE, id, 0), NULL},
+            {LFS_MKTAG(LFS_TYPE_DIR, id, nlen), path},
+            {LFS_MKTAG(LFS_TYPE_DIRSTRUCT, id, 8), dir.pair},
+            {LFS_MKTAG_IF(!cwd.m.split,
+                LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir.pair}));
     lfs_pair_fromle32(dir.pair);
     if (err) {
         return err;
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
-static int lfs_dir_rawopen(lfs_dir_t* dir, const char* path) {
-    lfs_stag_t tag = lfs_dir_find(&dir->m, &path, NULL);
+static int lfs_dir_open_(lfs_t *lfs, lfs_dir_t *dir, const char *path) {
+    lfs_stag_t tag = lfs_dir_find(lfs, &dir->m, &path, NULL);
     if (tag < 0) {
         return tag;
     }
@@ -1999,12 +2730,12 @@ static int lfs_dir_rawopen(lfs_dir_t* dir, const char* path) {
     lfs_block_t pair[2];
     if (lfs_tag_id(tag) == 0x3ff) {
         // handle root dir separately
-        pair[0] = lfs.root[0];
-        pair[1] = lfs.root[1];
+        pair[0] = lfs->root[0];
+        pair[1] = lfs->root[1];
     } else {
         // get dir pair from parent
-        lfs_stag_t res = lfs_dir_get(&dir->m, LFS_MKTAG(0x700, 0x3ff, 0),
-                                     LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), pair);
+        lfs_stag_t res = lfs_dir_get(lfs, &dir->m, LFS_MKTAG(0x700, 0x3ff, 0),
+                LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), pair);
         if (res < 0) {
             return res;
         }
@@ -2012,7 +2743,7 @@ static int lfs_dir_rawopen(lfs_dir_t* dir, const char* path) {
     }
 
     // fetch first pair
-    int err = lfs_dir_fetch(&dir->m, pair);
+    int err = lfs_dir_fetch(lfs, &dir->m, pair);
     if (err) {
         return err;
     }
@@ -2025,19 +2756,19 @@ static int lfs_dir_rawopen(lfs_dir_t* dir, const char* path) {
 
     // add to list of mdirs
     dir->type = LFS_TYPE_DIR;
-    lfs_mlist_append((struct lfs_mlist*)dir);
+    lfs_mlist_append(lfs, (struct lfs_mlist *)dir);
 
-    return LFS_ERR_OK;
+    return 0;
 }
 
-static int lfs_dir_rawclose(lfs_dir_t* dir) {
+static int lfs_dir_close_(lfs_t *lfs, lfs_dir_t *dir) {
     // remove from list of mdirs
-    lfs_mlist_remove((struct lfs_mlist*)dir);
+    lfs_mlist_remove(lfs, (struct lfs_mlist *)dir);
 
-    return LFS_ERR_OK;
+    return 0;
 }
 
-static int lfs_dir_rawread(lfs_dir_t* dir, struct lfs_info* info) {
+static int lfs_dir_read_(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {
     memset(info, 0, sizeof(*info));
 
     // special offset for '.' and '..'
@@ -2059,7 +2790,7 @@ static int lfs_dir_rawread(lfs_dir_t* dir, struct lfs_info* info) {
                 return false;
             }
 
-            int err = lfs_dir_fetch(&dir->m, dir->m.tail);
+            int err = lfs_dir_fetch(lfs, &dir->m, dir->m.tail);
             if (err) {
                 return err;
             }
@@ -2067,7 +2798,7 @@ static int lfs_dir_rawread(lfs_dir_t* dir, struct lfs_info* info) {
             dir->id = 0;
         }
 
-        int err = lfs_dir_getinfo(&dir->m, dir->id, info);
+        int err = lfs_dir_getinfo(lfs, &dir->m, dir->id, info);
         if (err && err != LFS_ERR_NOENT) {
             return err;
         }
@@ -2082,9 +2813,9 @@ static int lfs_dir_rawread(lfs_dir_t* dir, struct lfs_info* info) {
     return true;
 }
 
-static int lfs_dir_rawseek(lfs_dir_t* dir, lfs_off_t off) {
+static int lfs_dir_seek_(lfs_t *lfs, lfs_dir_t *dir, lfs_off_t off) {
     // simply walk from head dir
-    int err = lfs_dir_rawrewind(dir);
+    int err = lfs_dir_rewind_(lfs, dir);
     if (err) {
         return err;
     }
@@ -2094,52 +2825,53 @@ static int lfs_dir_rawseek(lfs_dir_t* dir, lfs_off_t off) {
     off -= dir->pos;
 
     // skip superblock entry
-    dir->id = (off > 0 && lfs_pair_cmp(dir->head, lfs.root) == 0);
+    dir->id = (off > 0 && lfs_pair_cmp(dir->head, lfs->root) == 0);
 
     while (off > 0) {
-        int diff = lfs_min(dir->m.count - dir->id, off);
-        dir->id += diff;
-        dir->pos += diff;
-        off -= diff;
-
         if (dir->id == dir->m.count) {
             if (!dir->m.split) {
                 return LFS_ERR_INVAL;
             }
 
-            err = lfs_dir_fetch(&dir->m, dir->m.tail);
+            err = lfs_dir_fetch(lfs, &dir->m, dir->m.tail);
             if (err) {
                 return err;
             }
 
             dir->id = 0;
         }
+
+        int diff = lfs_min(dir->m.count - dir->id, off);
+        dir->id += diff;
+        dir->pos += diff;
+        off -= diff;
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 
-static lfs_soff_t lfs_dir_rawtell(lfs_dir_t* dir) {
+static lfs_soff_t lfs_dir_tell_(lfs_t *lfs, lfs_dir_t *dir) {
     (void)lfs;
     return dir->pos;
 }
 
-static int lfs_dir_rawrewind(lfs_dir_t* dir) {
+static int lfs_dir_rewind_(lfs_t *lfs, lfs_dir_t *dir) {
     // reload the head dir
-    int err = lfs_dir_fetch(&dir->m, dir->head);
+    int err = lfs_dir_fetch(lfs, &dir->m, dir->head);
     if (err) {
         return err;
     }
 
     dir->id = 0;
     dir->pos = 0;
-    return LFS_ERR_OK;
+    return 0;
 }
 
+
 /// File index list operations ///
-static int lfs_ctz_index(lfs_off_t* off) {
+static int lfs_ctz_index(lfs_t *lfs, lfs_off_t *off) {
     lfs_off_t size = *off;
-    lfs_off_t b = lfs.cfg->block_size - 2 * 4;
+    lfs_off_t b = lfs->cfg->block_size - 2*4;
     lfs_off_t i = size / b;
     if (i == 0) {
         return 0;
@@ -2150,23 +2882,27 @@ static int lfs_ctz_index(lfs_off_t* off) {
     return i;
 }
 
-static int lfs_ctz_find(const lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_block_t head,
-                        lfs_size_t size, lfs_size_t pos, lfs_block_t* block, lfs_off_t* off) {
+static int lfs_ctz_find(lfs_t *lfs,
+        const lfs_cache_t *pcache, lfs_cache_t *rcache,
+        lfs_block_t head, lfs_size_t size,
+        lfs_size_t pos, lfs_block_t *block, lfs_off_t *off) {
     if (size == 0) {
         *block = LFS_BLOCK_NULL;
         *off = 0;
-        return LFS_ERR_OK;
+        return 0;
     }
 
-    lfs_off_t current = lfs_ctz_index(&(lfs_off_t){size - 1});
-    lfs_off_t target = lfs_ctz_index(&pos);
+    lfs_off_t current = lfs_ctz_index(lfs, &(lfs_off_t){size-1});
+    lfs_off_t target = lfs_ctz_index(lfs, &pos);
 
     while (current > target) {
         lfs_size_t skip = lfs_min(
                 lfs_npw2(current-target+1) - 1,
                 lfs_ctz(current));
 
-        int err = lfs_bd_read(pcache, rcache, sizeof(head), head, 4 * skip, &head, sizeof(head));
+        int err = lfs_bd_read(lfs,
+                pcache, rcache, sizeof(head),
+                head, 4*skip, &head, sizeof(head));
         head = lfs_fromle32(head);
         if (err) {
             return err;
@@ -2177,22 +2913,24 @@ static int lfs_ctz_find(const lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_bloc
 
     *block = head;
     *off = pos;
-    return LFS_ERR_OK;
+    return 0;
 }
 
 #ifndef LFS_READONLY
-static int lfs_ctz_extend(lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_block_t head,
-                          lfs_size_t size, lfs_block_t* block, lfs_off_t* off) {
+static int lfs_ctz_extend(lfs_t *lfs,
+        lfs_cache_t *pcache, lfs_cache_t *rcache,
+        lfs_block_t head, lfs_size_t size,
+        lfs_block_t *block, lfs_off_t *off) {
     while (true) {
         // go ahead and grab a block
         lfs_block_t nblock;
-        int err = lfs_alloc(&nblock);
+        int err = lfs_alloc(lfs, &nblock);
         if (err) {
             return err;
         }
 
         {
-            err = lfs_bd_erase(nblock);
+            err = lfs_bd_erase(lfs, nblock);
             if (err) {
                 if (err == LFS_ERR_CORRUPT) {
                     goto relocate;
@@ -2203,23 +2941,27 @@ static int lfs_ctz_extend(lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_block_t
             if (size == 0) {
                 *block = nblock;
                 *off = 0;
-                return LFS_ERR_OK;
+                return 0;
             }
 
             lfs_size_t noff = size - 1;
-            lfs_off_t index = lfs_ctz_index(&noff);
+            lfs_off_t index = lfs_ctz_index(lfs, &noff);
             noff = noff + 1;
 
             // just copy out the last block if it is incomplete
-            if (noff != lfs.cfg->block_size) {
+            if (noff != lfs->cfg->block_size) {
                 for (lfs_off_t i = 0; i < noff; i++) {
                     uint8_t data;
-                    err = lfs_bd_read(NULL, rcache, noff - i, head, i, &data, 1);
+                    err = lfs_bd_read(lfs,
+                            NULL, rcache, noff-i,
+                            head, i, &data, 1);
                     if (err) {
                         return err;
                     }
 
-                    err = lfs_bd_prog(pcache, rcache, true, nblock, i, &data, 1);
+                    err = lfs_bd_prog(lfs,
+                            pcache, rcache, true,
+                            nblock, i, &data, 1);
                     if (err) {
                         if (err == LFS_ERR_CORRUPT) {
                             goto relocate;
@@ -2230,7 +2972,7 @@ static int lfs_ctz_extend(lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_block_t
 
                 *block = nblock;
                 *off = noff;
-                return LFS_ERR_OK;
+                return 0;
             }
 
             // append block
@@ -2239,7 +2981,8 @@ static int lfs_ctz_extend(lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_block_t
             lfs_block_t nhead = head;
             for (lfs_off_t i = 0; i < skips; i++) {
                 nhead = lfs_tole32(nhead);
-                err = lfs_bd_prog(pcache, rcache, true, nblock, 4 * i, &nhead, 4);
+                err = lfs_bd_prog(lfs, pcache, rcache, true,
+                        nblock, 4*i, &nhead, 4);
                 nhead = lfs_fromle32(nhead);
                 if (err) {
                     if (err == LFS_ERR_CORRUPT) {
@@ -2249,8 +2992,9 @@ static int lfs_ctz_extend(lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_block_t
                 }
 
                 if (i != skips-1) {
-                    err = lfs_bd_read(NULL, rcache, sizeof(nhead), nhead, 4 * i, &nhead,
-                                      sizeof(nhead));
+                    err = lfs_bd_read(lfs,
+                            NULL, rcache, sizeof(nhead),
+                            nhead, 4*i, &nhead, sizeof(nhead));
                     nhead = lfs_fromle32(nhead);
                     if (err) {
                         return err;
@@ -2260,25 +3004,27 @@ static int lfs_ctz_extend(lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_block_t
 
             *block = nblock;
             *off = 4*skips;
-            return LFS_ERR_OK;
+            return 0;
         }
 
 relocate:
         LFS_DEBUG("Bad block at 0x%"PRIx32, nblock);
 
         // just clear cache and try a new block
-        lfs_cache_drop(pcache);
+        lfs_cache_drop(lfs, pcache);
     }
 }
 #endif
 
-static int lfs_ctz_traverse(const lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_block_t head,
-                            lfs_size_t size, int (*cb)(void*, lfs_block_t), void* data) {
+static int lfs_ctz_traverse(lfs_t *lfs,
+        const lfs_cache_t *pcache, lfs_cache_t *rcache,
+        lfs_block_t head, lfs_size_t size,
+        int (*cb)(void*, lfs_block_t), void *data) {
     if (size == 0) {
-        return LFS_ERR_OK;
+        return 0;
     }
 
-    lfs_off_t index = lfs_ctz_index(&(lfs_off_t){size - 1});
+    lfs_off_t index = lfs_ctz_index(lfs, &(lfs_off_t){size-1});
 
     while (true) {
         int err = cb(data, head);
@@ -2287,13 +3033,14 @@ static int lfs_ctz_traverse(const lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_
         }
 
         if (index == 0) {
-            return LFS_ERR_OK;
+            return 0;
         }
 
         lfs_block_t heads[2];
         int count = 2 - (index & 1);
-        err = lfs_bd_read(pcache, rcache, count * sizeof(head), head, 0, &heads,
-                          count * sizeof(head));
+        err = lfs_bd_read(lfs,
+                pcache, rcache, count*sizeof(head),
+                head, 0, &heads, count*sizeof(head));
         heads[0] = lfs_fromle32(heads[0]);
         heads[1] = lfs_fromle32(heads[1]);
         if (err) {
@@ -2312,13 +3059,15 @@ static int lfs_ctz_traverse(const lfs_cache_t* pcache, lfs_cache_t* rcache, lfs_
     }
 }
 
+
 /// Top level file operations ///
-static int lfs_file_rawopencfg(lfs_file_t* file, const char* path, int flags,
-                               const struct lfs_file_config* file_cfg) {
+static int lfs_file_opencfg_(lfs_t *lfs, lfs_file_t *file,
+        const char *path, int flags,
+        const struct lfs_file_config *cfg) {
 #ifndef LFS_READONLY
     // deorphan if we haven't yet, needed at most once after poweron
     if ((flags & LFS_O_WRONLY) == LFS_O_WRONLY) {
-        int err = lfs_fs_forceconsistency();
+        int err = lfs_fs_forceconsistency(lfs);
         if (err) {
             return err;
         }
@@ -2329,22 +3078,22 @@ static int lfs_file_rawopencfg(lfs_file_t* file, const char* path, int flags,
 
     // setup simple file details
     int err;
-    file->file_cfg = file_cfg;
+    file->cfg = cfg;
     file->flags = flags;
     file->pos = 0;
     file->off = 0;
     file->cache.buffer = NULL;
 
     // allocate entry for file if it doesn't exist
-    lfs_stag_t tag = lfs_dir_find(&file->m, &path, &file->id);
-    if (tag < 0 && !(tag == LFS_ERR_NOENT && file->id != 0x3ff)) {
+    lfs_stag_t tag = lfs_dir_find(lfs, &file->m, &path, &file->id);
+    if (tag < 0 && !(tag == LFS_ERR_NOENT && lfs_path_islast(path))) {
         err = tag;
         goto cleanup;
     }
 
     // get id, add to list of mdirs to catch update changes
     file->type = LFS_TYPE_REG;
-    lfs_mlist_append((struct lfs_mlist*)file);
+    lfs_mlist_append(lfs, (struct lfs_mlist *)file);
 
 #ifdef LFS_READONLY
     if (tag == LFS_ERR_NOENT) {
@@ -2357,20 +3106,29 @@ static int lfs_file_rawopencfg(lfs_file_t* file, const char* path, int flags,
             goto cleanup;
         }
 
+        // don't allow trailing slashes
+        if (lfs_path_isdir(path)) {
+            err = LFS_ERR_NOTDIR;
+            goto cleanup;
+        }
+
         // check that name fits
-        lfs_size_t nlen = strlen(path);
-        if (nlen > lfs.name_max) {
+        lfs_size_t nlen = lfs_path_namelen(path);
+        if (nlen > lfs->name_max) {
             err = LFS_ERR_NAMETOOLONG;
             goto cleanup;
         }
 
         // get next slot and create entry to remember name
-        err = lfs_dir_commit(&file->m,
-                             LFS_MKATTRS({LFS_MKTAG(LFS_TYPE_CREATE, file->id, 0), NULL},
-                                         {LFS_MKTAG(LFS_TYPE_REG, file->id, nlen), path},
-                                         {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0), NULL}));
+        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(
+                {LFS_MKTAG(LFS_TYPE_CREATE, file->id, 0), NULL},
+                {LFS_MKTAG(LFS_TYPE_REG, file->id, nlen), path},
+                {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0), NULL}));
+
+        // it may happen that the file name doesn't fit in the metadata blocks, e.g., a 256 byte file name will
+        // not fit in a 128 byte block.
+        err = (err == LFS_ERR_NOSPC) ? LFS_ERR_NAMETOOLONG : err;
         if (err) {
-            err = LFS_ERR_NAMETOOLONG;
             goto cleanup;
         }
 
@@ -2390,8 +3148,8 @@ static int lfs_file_rawopencfg(lfs_file_t* file, const char* path, int flags,
 #endif
     } else {
         // try to load what's on disk, if it's inlined we'll fix it later
-        tag = lfs_dir_get(&file->m, LFS_MKTAG(0x700, 0x3ff, 0),
-                          LFS_MKTAG(LFS_TYPE_STRUCT, file->id, 8), &file->ctz);
+        tag = lfs_dir_get(lfs, &file->m, LFS_MKTAG(0x700, 0x3ff, 0),
+                LFS_MKTAG(LFS_TYPE_STRUCT, file->id, 8), &file->ctz);
         if (tag < 0) {
             err = tag;
             goto cleanup;
@@ -2400,14 +3158,14 @@ static int lfs_file_rawopencfg(lfs_file_t* file, const char* path, int flags,
     }
 
     // fetch attrs
-    for (unsigned i = 0; i < file->file_cfg->attr_count; i++) {
+    for (unsigned i = 0; i < file->cfg->attr_count; i++) {
         // if opened for read / read-write operations
         if ((file->flags & LFS_O_RDONLY) == LFS_O_RDONLY) {
-            lfs_stag_t res =
-                lfs_dir_get(&file->m, LFS_MKTAG(0x7ff, 0x3ff, 0),
-                            LFS_MKTAG(LFS_TYPE_USERATTR + file->file_cfg->attrs[i].type, file->id,
-                                      file->file_cfg->attrs[i].size),
-                            file->file_cfg->attrs[i].buffer);
+            lfs_stag_t res = lfs_dir_get(lfs, &file->m,
+                    LFS_MKTAG(0x7ff, 0x3ff, 0),
+                    LFS_MKTAG(LFS_TYPE_USERATTR + file->cfg->attrs[i].type,
+                        file->id, file->cfg->attrs[i].size),
+                        file->cfg->attrs[i].buffer);
             if (res < 0 && res != LFS_ERR_NOENT) {
                 err = res;
                 goto cleanup;
@@ -2417,7 +3175,7 @@ static int lfs_file_rawopencfg(lfs_file_t* file, const char* path, int flags,
 #ifndef LFS_READONLY
         // if opened for write / read-write operations
         if ((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY) {
-            if (file->file_cfg->attrs[i].size > lfs.attr_max) {
+            if (file->cfg->attrs[i].size > lfs->attr_max) {
                 err = LFS_ERR_NOSPC;
                 goto cleanup;
             }
@@ -2428,10 +3186,10 @@ static int lfs_file_rawopencfg(lfs_file_t* file, const char* path, int flags,
     }
 
     // allocate buffer if needed
-    if (file->file_cfg->buffer) {
-        file->cache.buffer = file->file_cfg->buffer;
+    if (file->cfg->buffer) {
+        file->cache.buffer = file->cfg->buffer;
     } else {
-        file->cache.buffer = lfs_malloc(lfs.cfg->cache_size);
+        file->cache.buffer = lfs_malloc(lfs->cfg->cache_size);
         if (!file->cache.buffer) {
             err = LFS_ERR_NOMEM;
             goto cleanup;
@@ -2439,7 +3197,7 @@ static int lfs_file_rawopencfg(lfs_file_t* file, const char* path, int flags,
     }
 
     // zero to avoid information leak
-    lfs_cache_zero(&file->cache);
+    lfs_cache_zero(lfs, &file->cache);
 
     if (lfs_tag_type3(tag) == LFS_TYPE_INLINESTRUCT) {
         // load inline files
@@ -2448,14 +3206,15 @@ static int lfs_file_rawopencfg(lfs_file_t* file, const char* path, int flags,
         file->flags |= LFS_F_INLINE;
         file->cache.block = file->ctz.head;
         file->cache.off = 0;
-        file->cache.size = lfs.cfg->cache_size;
+        file->cache.size = lfs->cfg->cache_size;
 
         // don't always read (may be new/trunc file)
         if (file->ctz.size > 0) {
-            lfs_stag_t res =
-                lfs_dir_get(&file->m, LFS_MKTAG(0x700, 0x3ff, 0),
-                            LFS_MKTAG(LFS_TYPE_STRUCT, file->id, lfs_min(file->cache.size, 0x3fe)),
-                            file->cache.buffer);
+            lfs_stag_t res = lfs_dir_get(lfs, &file->m,
+                    LFS_MKTAG(0x700, 0x3ff, 0),
+                    LFS_MKTAG(LFS_TYPE_STRUCT, file->id,
+                        lfs_min(file->cache.size, 0x3fe)),
+                    file->cache.buffer);
             if (res < 0) {
                 err = res;
                 goto cleanup;
@@ -2463,52 +3222,56 @@ static int lfs_file_rawopencfg(lfs_file_t* file, const char* path, int flags,
         }
     }
 
-    return LFS_ERR_OK;
+    return 0;
 
 cleanup:
     // clean up lingering resources
 #ifndef LFS_READONLY
     file->flags |= LFS_F_ERRED;
 #endif
-    lfs_file_rawclose(file);
+    lfs_file_close_(lfs, file);
     return err;
 }
 
-static int lfs_file_rawopen(lfs_file_t* file, const char* path, int flags) {
+#ifndef LFS_NO_MALLOC
+static int lfs_file_open_(lfs_t *lfs, lfs_file_t *file,
+        const char *path, int flags) {
     static const struct lfs_file_config defaults = {0};
-    int err = lfs_file_rawopencfg(file, path, flags, &defaults);
+    int err = lfs_file_opencfg_(lfs, file, path, flags, &defaults);
     return err;
 }
+#endif
 
-static int lfs_file_rawclose(lfs_file_t* file) {
+static int lfs_file_close_(lfs_t *lfs, lfs_file_t *file) {
 #ifndef LFS_READONLY
-    int err = lfs_file_rawsync(file);
+    int err = lfs_file_sync_(lfs, file);
 #else
     int err = 0;
 #endif
 
     // remove from list of mdirs
-    lfs_mlist_remove((struct lfs_mlist*)file);
+    lfs_mlist_remove(lfs, (struct lfs_mlist*)file);
 
     // clean up memory
-    if (!file->file_cfg->buffer) {
+    if (!file->cfg->buffer) {
         lfs_free(file->cache.buffer);
     }
 
     return err;
 }
 
+
 #ifndef LFS_READONLY
-static int lfs_file_relocate(lfs_file_t* file) {
+static int lfs_file_relocate(lfs_t *lfs, lfs_file_t *file) {
     while (true) {
         // just relocate what exists into new block
         lfs_block_t nblock;
-        int err = lfs_alloc(&nblock);
+        int err = lfs_alloc(lfs, &nblock);
         if (err) {
             return err;
         }
 
-        err = lfs_bd_erase(nblock);
+        err = lfs_bd_erase(lfs, nblock);
         if (err) {
             if (err == LFS_ERR_CORRUPT) {
                 goto relocate;
@@ -2520,22 +3283,27 @@ static int lfs_file_relocate(lfs_file_t* file) {
         for (lfs_off_t i = 0; i < file->off; i++) {
             uint8_t data;
             if (file->flags & LFS_F_INLINE) {
-                err = lfs_dir_getread(&file->m,
-                                      // note we evict inline files before they can be dirty
-                                      NULL, &file->cache, file->off - i, LFS_MKTAG(0xfff, 0x1ff, 0),
-                                      LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0), i, &data, 1);
+                err = lfs_dir_getread(lfs, &file->m,
+                        // note we evict inline files before they can be dirty
+                        NULL, &file->cache, file->off-i,
+                        LFS_MKTAG(0xfff, 0x1ff, 0),
+                        LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),
+                        i, &data, 1);
                 if (err) {
                     return err;
                 }
             } else {
-                err =
-                    lfs_bd_read(&file->cache, &lfs.rcache, file->off - i, file->block, i, &data, 1);
+                err = lfs_bd_read(lfs,
+                        &file->cache, &lfs->rcache, file->off-i,
+                        file->block, i, &data, 1);
                 if (err) {
                     return err;
                 }
             }
 
-            err = lfs_bd_prog(&lfs.pcache, &lfs.rcache, true, nblock, i, &data, 1);
+            err = lfs_bd_prog(lfs,
+                    &lfs->pcache, &lfs->rcache, true,
+                    nblock, i, &data, 1);
             if (err) {
                 if (err == LFS_ERR_CORRUPT) {
                     goto relocate;
@@ -2545,48 +3313,48 @@ static int lfs_file_relocate(lfs_file_t* file) {
         }
 
         // copy over new state of file
-        memcpy(file->cache.buffer, lfs.pcache.buffer, lfs.cfg->cache_size);
-        file->cache.block = lfs.pcache.block;
-        file->cache.off = lfs.pcache.off;
-        file->cache.size = lfs.pcache.size;
-        lfs_cache_zero(&lfs.pcache);
+        memcpy(file->cache.buffer, lfs->pcache.buffer, lfs->cfg->cache_size);
+        file->cache.block = lfs->pcache.block;
+        file->cache.off = lfs->pcache.off;
+        file->cache.size = lfs->pcache.size;
+        lfs_cache_zero(lfs, &lfs->pcache);
 
         file->block = nblock;
         file->flags |= LFS_F_WRITING;
-        return LFS_ERR_OK;
+        return 0;
 
 relocate:
         LFS_DEBUG("Bad block at 0x%"PRIx32, nblock);
 
         // just clear cache and try a new block
-        lfs_cache_drop(&lfs.pcache);
+        lfs_cache_drop(lfs, &lfs->pcache);
     }
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_file_outline(lfs_file_t* file) {
+static int lfs_file_outline(lfs_t *lfs, lfs_file_t *file) {
     file->off = file->pos;
-    lfs_alloc_ack();
-    int err = lfs_file_relocate(file);
+    lfs_alloc_ckpoint(lfs);
+    int err = lfs_file_relocate(lfs, file);
     if (err) {
         return err;
     }
 
     file->flags &= ~LFS_F_INLINE;
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
-#ifndef LFS_READONLY
-static int lfs_file_flush(lfs_file_t* file) {
+static int lfs_file_flush(lfs_t *lfs, lfs_file_t *file) {
     if (file->flags & LFS_F_READING) {
         if (!(file->flags & LFS_F_INLINE)) {
-            lfs_cache_drop(&file->cache);
+            lfs_cache_drop(lfs, &file->cache);
         }
         file->flags &= ~LFS_F_READING;
     }
 
+#ifndef LFS_READONLY
     if (file->flags & LFS_F_WRITING) {
         lfs_off_t pos = file->pos;
 
@@ -2597,34 +3365,34 @@ static int lfs_file_flush(lfs_file_t* file) {
                 .ctz.size = file->ctz.size,
                 .flags = LFS_O_RDONLY,
                 .pos = file->pos,
-                .cache = lfs.rcache,
+                .cache = lfs->rcache,
             };
-            lfs_cache_drop(&lfs.rcache);
+            lfs_cache_drop(lfs, &lfs->rcache);
 
             while (file->pos < file->ctz.size) {
                 // copy over a byte at a time, leave it up to caching
                 // to make this efficient
                 uint8_t data;
-                lfs_ssize_t res = lfs_file_rawread(&orig, &data, 1);
+                lfs_ssize_t res = lfs_file_flushedread(lfs, &orig, &data, 1);
                 if (res < 0) {
                     return res;
                 }
 
-                res = lfs_file_rawwrite(file, &data, 1);
+                res = lfs_file_flushedwrite(lfs, file, &data, 1);
                 if (res < 0) {
                     return res;
                 }
 
                 // keep our reference to the rcache in sync
-                if (lfs.rcache.block != LFS_BLOCK_NULL) {
-                    lfs_cache_drop(&orig.cache);
-                    lfs_cache_drop(&lfs.rcache);
+                if (lfs->rcache.block != LFS_BLOCK_NULL) {
+                    lfs_cache_drop(lfs, &orig.cache);
+                    lfs_cache_drop(lfs, &lfs->rcache);
                 }
             }
 
             // write out what we have
             while (true) {
-                int err = lfs_bd_flush(&file->cache, &lfs.rcache, true);
+                int err = lfs_bd_flush(lfs, &file->cache, &lfs->rcache, true);
                 if (err) {
                     if (err == LFS_ERR_CORRUPT) {
                         goto relocate;
@@ -2636,7 +3404,7 @@ static int lfs_file_flush(lfs_file_t* file) {
 
 relocate:
                 LFS_DEBUG("Bad block at 0x%"PRIx32, file->block);
-                err = lfs_file_relocate(file);
+                err = lfs_file_relocate(lfs, file);
                 if (err) {
                     return err;
                 }
@@ -2653,19 +3421,19 @@ relocate:
 
         file->pos = pos;
     }
+#endif
 
-    return LFS_ERR_OK;
+    return 0;
 }
-#endif
 
 #ifndef LFS_READONLY
-static int lfs_file_rawsync(lfs_file_t* file) {
+static int lfs_file_sync_(lfs_t *lfs, lfs_file_t *file) {
     if (file->flags & LFS_F_ERRED) {
         // it's not safe to do anything if our file errored
-        return LFS_ERR_OK;
+        return 0;
     }
 
-    int err = lfs_file_flush(file);
+    int err = lfs_file_flush(lfs, file);
     if (err) {
         file->flags |= LFS_F_ERRED;
         return err;
@@ -2674,6 +3442,15 @@ static int lfs_file_rawsync(lfs_file_t* file) {
 
     if ((file->flags & LFS_F_DIRTY) &&
             !lfs_pair_isnull(file->m.pair)) {
+        // before we commit metadata, we need sync the disk to make sure
+        // data writes don't complete after metadata writes
+        if (!(file->flags & LFS_F_INLINE)) {
+            err = lfs_bd_sync(lfs, &lfs->pcache, &lfs->rcache, false);
+            if (err) {
+                return err;
+            }
+        }
+
         // update dir entry
         uint16_t type;
         const void *buffer;
@@ -2695,10 +3472,10 @@ static int lfs_file_rawsync(lfs_file_t* file) {
         }
 
         // commit file data and attributes
-        err = lfs_dir_commit(&file->m, LFS_MKATTRS({LFS_MKTAG(type, file->id, size), buffer},
-                                                   {LFS_MKTAG(LFS_FROM_USERATTRS, file->id,
-                                                              file->file_cfg->attr_count),
-                                                    file->file_cfg->attrs}));
+        err = lfs_dir_commit(lfs, &file->m, LFS_MKATTRS(
+                {LFS_MKTAG(type, file->id, size), buffer},
+                {LFS_MKTAG(LFS_FROM_USERATTRS, file->id,
+                    file->cfg->attr_count), file->cfg->attrs}));
         if (err) {
             file->flags |= LFS_F_ERRED;
             return err;
@@ -2707,29 +3484,18 @@ static int lfs_file_rawsync(lfs_file_t* file) {
         file->flags &= ~LFS_F_DIRTY;
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
-static lfs_ssize_t lfs_file_rawread(lfs_file_t* file, void* buffer, lfs_size_t size) {
-    LFS_ASSERT((file->flags & LFS_O_RDONLY) == LFS_O_RDONLY);
-
+static lfs_ssize_t lfs_file_flushedread(lfs_t *lfs, lfs_file_t *file,
+        void *buffer, lfs_size_t size) {
     uint8_t *data = buffer;
     lfs_size_t nsize = size;
 
-#ifndef LFS_READONLY
-    if (file->flags & LFS_F_WRITING) {
-        // flush out any writes
-        int err = lfs_file_flush(file);
-        if (err) {
-            return err;
-        }
-    }
-#endif
-
     if (file->pos >= file->ctz.size) {
         // eof if past end
-        return LFS_ERR_OK;
+        return 0;
     }
 
     size = lfs_min(size, file->ctz.size - file->pos);
@@ -2737,10 +3503,12 @@ static lfs_ssize_t lfs_file_rawread(lfs_file_t* file, void* buffer, lfs_size_t s
 
     while (nsize > 0) {
         // check if we need a new block
-        if (!(file->flags & LFS_F_READING) || file->off == lfs.cfg->block_size) {
+        if (!(file->flags & LFS_F_READING) ||
+                file->off == lfs->cfg->block_size) {
             if (!(file->flags & LFS_F_INLINE)) {
-                int err = lfs_ctz_find(NULL, &file->cache, file->ctz.head, file->ctz.size,
-                                       file->pos, &file->block, &file->off);
+                int err = lfs_ctz_find(lfs, NULL, &file->cache,
+                        file->ctz.head, file->ctz.size,
+                        file->pos, &file->block, &file->off);
                 if (err) {
                     return err;
                 }
@@ -2753,17 +3521,20 @@ static lfs_ssize_t lfs_file_rawread(lfs_file_t* file, void* buffer, lfs_size_t s
         }
 
         // read as much as we can in current block
-        lfs_size_t diff = lfs_min(nsize, lfs.cfg->block_size - file->off);
+        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);
         if (file->flags & LFS_F_INLINE) {
-            int err = lfs_dir_getread(
-                &file->m, NULL, &file->cache, lfs.cfg->block_size, LFS_MKTAG(0xfff, 0x1ff, 0),
-                LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0), file->off, data, diff);
+            int err = lfs_dir_getread(lfs, &file->m,
+                    NULL, &file->cache, lfs->cfg->block_size,
+                    LFS_MKTAG(0xfff, 0x1ff, 0),
+                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, file->id, 0),
+                    file->off, data, diff);
             if (err) {
                 return err;
             }
         } else {
-            int err = lfs_bd_read(NULL, &file->cache, lfs.cfg->block_size, file->block, file->off,
-                                  data, diff);
+            int err = lfs_bd_read(lfs,
+                    NULL, &file->cache, lfs->cfg->block_size,
+                    file->block, file->off, data, diff);
             if (err) {
                 return err;
             }
@@ -2778,51 +3549,34 @@ static lfs_ssize_t lfs_file_rawread(lfs_file_t* file, void* buffer, lfs_size_t s
     return size;
 }
 
-#ifndef LFS_READONLY
-static lfs_ssize_t lfs_file_rawwrite(lfs_file_t* file, const void* buffer, lfs_size_t size) {
-    LFS_ASSERT((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY);
-
-    const uint8_t *data = buffer;
-    lfs_size_t nsize = size;
+static lfs_ssize_t lfs_file_read_(lfs_t *lfs, lfs_file_t *file,
+        void *buffer, lfs_size_t size) {
+    LFS_ASSERT((file->flags & LFS_O_RDONLY) == LFS_O_RDONLY);
 
-    if (file->flags & LFS_F_READING) {
-        // drop any reads
-        int err = lfs_file_flush(file);
+#ifndef LFS_READONLY
+    if (file->flags & LFS_F_WRITING) {
+        // flush out any writes
+        int err = lfs_file_flush(lfs, file);
         if (err) {
             return err;
         }
     }
+#endif
 
-    if ((file->flags & LFS_O_APPEND) && file->pos < file->ctz.size) {
-        file->pos = file->ctz.size;
-    }
-
-    if (file->pos + size > lfs.file_max) {
-        // Larger than file limit?
-        return LFS_ERR_FBIG;
-    }
+    return lfs_file_flushedread(lfs, file, buffer, size);
+}
 
-    if (!(file->flags & LFS_F_WRITING) && file->pos > file->ctz.size) {
-        // fill with zeros
-        lfs_off_t pos = file->pos;
-        file->pos = file->ctz.size;
 
-        while (file->pos < pos) {
-            lfs_ssize_t res = lfs_file_rawwrite(file, &(uint8_t){0}, 1);
-            if (res < 0) {
-                return res;
-            }
-        }
-    }
+#ifndef LFS_READONLY
+static lfs_ssize_t lfs_file_flushedwrite(lfs_t *lfs, lfs_file_t *file,
+        const void *buffer, lfs_size_t size) {
+    const uint8_t *data = buffer;
+    lfs_size_t nsize = size;
 
     if ((file->flags & LFS_F_INLINE) &&
-        lfs_max(file->pos + nsize, file->ctz.size) >
-            lfs_min(0x3fe,
-                    lfs_min(lfs.cfg->cache_size,
-                            (lfs.cfg->metadata_max ? lfs.cfg->metadata_max : lfs.cfg->block_size) /
-                                8))) {
+            lfs_max(file->pos+nsize, file->ctz.size) > lfs->inline_max) {
         // inline file doesn't fit anymore
-        int err = lfs_file_outline(file);
+        int err = lfs_file_outline(lfs, file);
         if (err) {
             file->flags |= LFS_F_ERRED;
             return err;
@@ -2831,25 +3585,28 @@ static lfs_ssize_t lfs_file_rawwrite(lfs_file_t* file, const void* buffer, lfs_s
 
     while (nsize > 0) {
         // check if we need a new block
-        if (!(file->flags & LFS_F_WRITING) || file->off == lfs.cfg->block_size) {
+        if (!(file->flags & LFS_F_WRITING) ||
+                file->off == lfs->cfg->block_size) {
             if (!(file->flags & LFS_F_INLINE)) {
                 if (!(file->flags & LFS_F_WRITING) && file->pos > 0) {
                     // find out which block we're extending from
-                    int err = lfs_ctz_find(NULL, &file->cache, file->ctz.head, file->ctz.size,
-                                           file->pos - 1, &file->block, &file->off);
+                    int err = lfs_ctz_find(lfs, NULL, &file->cache,
+                            file->ctz.head, file->ctz.size,
+                            file->pos-1, &file->block, &(lfs_off_t){0});
                     if (err) {
                         file->flags |= LFS_F_ERRED;
                         return err;
                     }
 
                     // mark cache as dirty since we may have read data into it
-                    lfs_cache_zero(&file->cache);
+                    lfs_cache_zero(lfs, &file->cache);
                 }
 
                 // extend file with new blocks
-                lfs_alloc_ack();
-                int err = lfs_ctz_extend(&file->cache, &lfs.rcache, file->block, file->pos,
-                                         &file->block, &file->off);
+                lfs_alloc_ckpoint(lfs);
+                int err = lfs_ctz_extend(lfs, &file->cache, &lfs->rcache,
+                        file->block, file->pos,
+                        &file->block, &file->off);
                 if (err) {
                     file->flags |= LFS_F_ERRED;
                     return err;
@@ -2863,10 +3620,10 @@ static lfs_ssize_t lfs_file_rawwrite(lfs_file_t* file, const void* buffer, lfs_s
         }
 
         // program as much as we can in current block
-        lfs_size_t diff = lfs_min(nsize, lfs.cfg->block_size - file->off);
+        lfs_size_t diff = lfs_min(nsize, lfs->cfg->block_size - file->off);
         while (true) {
-            int err =
-                lfs_bd_prog(&file->cache, &lfs.rcache, true, file->block, file->off, data, diff);
+            int err = lfs_bd_prog(lfs, &file->cache, &lfs->rcache, true,
+                    file->block, file->off, data, diff);
             if (err) {
                 if (err == LFS_ERR_CORRUPT) {
                     goto relocate;
@@ -2877,11 +3634,11 @@ static lfs_ssize_t lfs_file_rawwrite(lfs_file_t* file, const void* buffer, lfs_s
 
             break;
 relocate:
-    err = lfs_file_relocate(file);
-    if (err) {
-        file->flags |= LFS_F_ERRED;
-        return err;
-    }
+            err = lfs_file_relocate(lfs, file);
+            if (err) {
+                file->flags |= LFS_F_ERRED;
+                return err;
+            }
         }
 
         file->pos += diff;
@@ -2889,26 +3646,72 @@ relocate:
         data += diff;
         nsize -= diff;
 
-        lfs_alloc_ack();
+        lfs_alloc_ckpoint(lfs);
     }
 
-    file->flags &= ~LFS_F_ERRED;
     return size;
 }
+
+static lfs_ssize_t lfs_file_write_(lfs_t *lfs, lfs_file_t *file,
+        const void *buffer, lfs_size_t size) {
+    LFS_ASSERT((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY);
+
+    if (file->flags & LFS_F_READING) {
+        // drop any reads
+        int err = lfs_file_flush(lfs, file);
+        if (err) {
+            return err;
+        }
+    }
+
+    if ((file->flags & LFS_O_APPEND) && file->pos < file->ctz.size) {
+        file->pos = file->ctz.size;
+    }
+
+    if (file->pos + size > lfs->file_max) {
+        // Larger than file limit?
+        return LFS_ERR_FBIG;
+    }
+
+    if (!(file->flags & LFS_F_WRITING) && file->pos > file->ctz.size) {
+        // fill with zeros
+        lfs_off_t pos = file->pos;
+        file->pos = file->ctz.size;
+
+        while (file->pos < pos) {
+            lfs_ssize_t res = lfs_file_flushedwrite(lfs, file, &(uint8_t){0}, 1);
+            if (res < 0) {
+                return res;
+            }
+        }
+    }
+
+    lfs_ssize_t nsize = lfs_file_flushedwrite(lfs, file, buffer, size);
+    if (nsize < 0) {
+        return nsize;
+    }
+
+    file->flags &= ~LFS_F_ERRED;
+    return nsize;
+}
 #endif
 
-static lfs_soff_t lfs_file_rawseek(lfs_file_t* file, lfs_soff_t off, int whence) {
+static lfs_soff_t lfs_file_seek_(lfs_t *lfs, lfs_file_t *file,
+        lfs_soff_t off, int whence) {
     // find new pos
+    //
+    // fortunately for us, littlefs is limited to 31-bit file sizes, so we
+    // don't have to worry too much about integer overflow
     lfs_off_t npos = file->pos;
     if (whence == LFS_SEEK_SET) {
         npos = off;
     } else if (whence == LFS_SEEK_CUR) {
-        npos = file->pos + off;
+        npos = file->pos + (lfs_off_t)off;
     } else if (whence == LFS_SEEK_END) {
-        npos = lfs_file_rawsize(file) + off;
+        npos = (lfs_off_t)lfs_file_size_(lfs, file) + (lfs_off_t)off;
     }
 
-    if (npos > lfs.file_max) {
+    if (npos > lfs->file_max) {
         // file position out of range
         return LFS_ERR_INVAL;
     }
@@ -2918,13 +3721,27 @@ static lfs_soff_t lfs_file_rawseek(lfs_file_t* file, lfs_soff_t off, int whence)
         return npos;
     }
 
-#ifndef LFS_READONLY
+    // if we're only reading and our new offset is still in the file's cache
+    // we can avoid flushing and needing to reread the data
+    if ((file->flags & LFS_F_READING)
+            && file->off != lfs->cfg->block_size) {
+        int oindex = lfs_ctz_index(lfs, &(lfs_off_t){file->pos});
+        lfs_off_t noff = npos;
+        int nindex = lfs_ctz_index(lfs, &noff);
+        if (oindex == nindex
+                && noff >= file->cache.off
+                && noff < file->cache.off + file->cache.size) {
+            file->pos = npos;
+            file->off = noff;
+            return npos;
+        }
+    }
+
     // write out everything beforehand, may be noop if rdonly
-    int err = lfs_file_flush(file);
+    int err = lfs_file_flush(lfs, file);
     if (err) {
         return err;
     }
-#endif
 
     // update pos
     file->pos = npos;
@@ -2932,7 +3749,7 @@ static lfs_soff_t lfs_file_rawseek(lfs_file_t* file, lfs_soff_t off, int whence)
 }
 
 #ifndef LFS_READONLY
-static int lfs_file_rawtruncate(lfs_file_t* file, lfs_off_t size) {
+static int lfs_file_truncate_(lfs_t *lfs, lfs_file_t *file, lfs_off_t size) {
     LFS_ASSERT((file->flags & LFS_O_WRONLY) == LFS_O_WRONLY);
 
     if (size > LFS_FILE_MAX) {
@@ -2940,37 +3757,64 @@ static int lfs_file_rawtruncate(lfs_file_t* file, lfs_off_t size) {
     }
 
     lfs_off_t pos = file->pos;
-    lfs_off_t oldsize = lfs_file_rawsize(file);
+    lfs_off_t oldsize = lfs_file_size_(lfs, file);
     if (size < oldsize) {
-        // need to flush since directly changing metadata
-        int err = lfs_file_flush(file);
-        if (err) {
-            return err;
-        }
+        // revert to inline file?
+        if (size <= lfs->inline_max) {
+            // flush+seek to head
+            lfs_soff_t res = lfs_file_seek_(lfs, file, 0, LFS_SEEK_SET);
+            if (res < 0) {
+                return (int)res;
+            }
 
-        // lookup new head in ctz skip list
-        err = lfs_ctz_find(NULL, &file->cache, file->ctz.head, file->ctz.size, size, &file->block,
-                           &file->off);
-        if (err) {
-            return err;
-        }
+            // read our data into rcache temporarily
+            lfs_cache_drop(lfs, &lfs->rcache);
+            res = lfs_file_flushedread(lfs, file,
+                    lfs->rcache.buffer, size);
+            if (res < 0) {
+                return (int)res;
+            }
 
-        // need to set pos/block/off consistently so seeking back to
-        // the old position does not get confused
-        file->pos = size;
-        file->ctz.head = file->block;
-        file->ctz.size = size;
-        file->flags |= LFS_F_DIRTY | LFS_F_READING;
+            file->ctz.head = LFS_BLOCK_INLINE;
+            file->ctz.size = size;
+            file->flags |= LFS_F_DIRTY | LFS_F_READING | LFS_F_INLINE;
+            file->cache.block = file->ctz.head;
+            file->cache.off = 0;
+            file->cache.size = lfs->cfg->cache_size;
+            memcpy(file->cache.buffer, lfs->rcache.buffer, size);
+
+        } else {
+            // need to flush since directly changing metadata
+            int err = lfs_file_flush(lfs, file);
+            if (err) {
+                return err;
+            }
+
+            // lookup new head in ctz skip list
+            err = lfs_ctz_find(lfs, NULL, &file->cache,
+                    file->ctz.head, file->ctz.size,
+                    size-1, &file->block, &(lfs_off_t){0});
+            if (err) {
+                return err;
+            }
+
+            // need to set pos/block/off consistently so seeking back to
+            // the old position does not get confused
+            file->pos = size;
+            file->ctz.head = file->block;
+            file->ctz.size = size;
+            file->flags |= LFS_F_DIRTY | LFS_F_READING;
+        }
     } else if (size > oldsize) {
         // flush+seek if not already at end
-        lfs_soff_t res = lfs_file_rawseek(file, 0, LFS_SEEK_END);
+        lfs_soff_t res = lfs_file_seek_(lfs, file, 0, LFS_SEEK_END);
         if (res < 0) {
             return (int)res;
         }
 
         // fill with zeros
         while (file->pos < size) {
-            res = lfs_file_rawwrite(file, &(uint8_t){0}, 1);
+            res = lfs_file_write_(lfs, file, &(uint8_t){0}, 1);
             if (res < 0) {
                 return (int)res;
             }
@@ -2978,30 +3822,30 @@ static int lfs_file_rawtruncate(lfs_file_t* file, lfs_off_t size) {
     }
 
     // restore pos
-    lfs_soff_t res = lfs_file_rawseek(file, pos, LFS_SEEK_SET);
+    lfs_soff_t res = lfs_file_seek_(lfs, file, pos, LFS_SEEK_SET);
     if (res < 0) {
       return (int)res;
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
-static lfs_soff_t lfs_file_rawtell(lfs_file_t* file) {
+static lfs_soff_t lfs_file_tell_(lfs_t *lfs, lfs_file_t *file) {
     (void)lfs;
     return file->pos;
 }
 
-static int lfs_file_rawrewind(lfs_file_t* file) {
-    lfs_soff_t res = lfs_file_rawseek(file, 0, LFS_SEEK_SET);
+static int lfs_file_rewind_(lfs_t *lfs, lfs_file_t *file) {
+    lfs_soff_t res = lfs_file_seek_(lfs, file, 0, LFS_SEEK_SET);
     if (res < 0) {
         return (int)res;
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 
-static lfs_soff_t lfs_file_rawsize(lfs_file_t* file) {
+static lfs_soff_t lfs_file_size_(lfs_t *lfs, lfs_file_t *file) {
     (void)lfs;
 
 #ifndef LFS_READONLY
@@ -3013,44 +3857,51 @@ static lfs_soff_t lfs_file_rawsize(lfs_file_t* file) {
     return file->ctz.size;
 }
 
+
 /// General fs operations ///
-static int lfs_rawstat(const char* path, struct lfs_info* info) {
+static int lfs_stat_(lfs_t *lfs, const char *path, struct lfs_info *info) {
     lfs_mdir_t cwd;
-    lfs_stag_t tag = lfs_dir_find(&cwd, &path, NULL);
+    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);
     if (tag < 0) {
         return (int)tag;
     }
 
-    return lfs_dir_getinfo(&cwd, lfs_tag_id(tag), info);
+    // only allow trailing slashes on dirs
+    if (strchr(path, '/') != NULL
+            && lfs_tag_type3(tag) != LFS_TYPE_DIR) {
+        return LFS_ERR_NOTDIR;
+    }
+
+    return lfs_dir_getinfo(lfs, &cwd, lfs_tag_id(tag), info);
 }
 
 #ifndef LFS_READONLY
-static int lfs_rawremove(const char* path) {
+static int lfs_remove_(lfs_t *lfs, const char *path) {
     // deorphan if we haven't yet, needed at most once after poweron
-    int err = lfs_fs_forceconsistency();
+    int err = lfs_fs_forceconsistency(lfs);
     if (err) {
         return err;
     }
 
     lfs_mdir_t cwd;
-    lfs_stag_t tag = lfs_dir_find(&cwd, &path, NULL);
+    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);
     if (tag < 0 || lfs_tag_id(tag) == 0x3ff) {
         return (tag < 0) ? (int)tag : LFS_ERR_INVAL;
     }
 
     struct lfs_mlist dir;
-    dir.next = lfs.mlist;
+    dir.next = lfs->mlist;
     if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {
         // must be empty before removal
         lfs_block_t pair[2];
-        lfs_stag_t res = lfs_dir_get(&cwd, LFS_MKTAG(0x700, 0x3ff, 0),
-                                     LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), pair);
+        lfs_stag_t res = lfs_dir_get(lfs, &cwd, LFS_MKTAG(0x700, 0x3ff, 0),
+                LFS_MKTAG(LFS_TYPE_STRUCT, lfs_tag_id(tag), 8), pair);
         if (res < 0) {
             return (int)res;
         }
         lfs_pair_fromle32(pair);
 
-        err = lfs_dir_fetch(&dir.m, pair);
+        err = lfs_dir_fetch(lfs, &dir.m, pair);
         if (err) {
             return err;
         }
@@ -3060,7 +3911,7 @@ static int lfs_rawremove(const char* path) {
         }
 
         // mark fs as orphaned
-        err = lfs_fs_preporphans(+1);
+        err = lfs_fs_preporphans(lfs, +1);
         if (err) {
             return err;
         }
@@ -3069,50 +3920,53 @@ static int lfs_rawremove(const char* path) {
         // commit (if predecessor is child)
         dir.type = 0;
         dir.id = 0;
-        lfs.mlist = &dir;
+        lfs->mlist = &dir;
     }
 
     // delete the entry
-    err = lfs_dir_commit(&cwd, LFS_MKATTRS({LFS_MKTAG(LFS_TYPE_DELETE, lfs_tag_id(tag), 0), NULL}));
+    err = lfs_dir_commit(lfs, &cwd, LFS_MKATTRS(
+            {LFS_MKTAG(LFS_TYPE_DELETE, lfs_tag_id(tag), 0), NULL}));
     if (err) {
-        lfs.mlist = dir.next;
+        lfs->mlist = dir.next;
         return err;
     }
 
-    lfs.mlist = dir.next;
-    if (lfs_tag_type3(tag) == LFS_TYPE_DIR) {
+    lfs->mlist = dir.next;
+    if (lfs_gstate_hasorphans(&lfs->gstate)) {
+        LFS_ASSERT(lfs_tag_type3(tag) == LFS_TYPE_DIR);
+
         // fix orphan
-        err = lfs_fs_preporphans(-1);
+        err = lfs_fs_preporphans(lfs, -1);
         if (err) {
             return err;
         }
 
-        err = lfs_fs_pred(dir.m.pair, &cwd);
+        err = lfs_fs_pred(lfs, dir.m.pair, &cwd);
         if (err) {
             return err;
         }
 
-        err = lfs_dir_drop(&cwd, &dir.m);
+        err = lfs_dir_drop(lfs, &cwd, &dir.m);
         if (err) {
             return err;
         }
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_rawrename(const char* oldpath, const char* newpath) {
+static int lfs_rename_(lfs_t *lfs, const char *oldpath, const char *newpath) {
     // deorphan if we haven't yet, needed at most once after poweron
-    int err = lfs_fs_forceconsistency();
+    int err = lfs_fs_forceconsistency(lfs);
     if (err) {
         return err;
     }
 
     // find old entry
     lfs_mdir_t oldcwd;
-    lfs_stag_t oldtag = lfs_dir_find(&oldcwd, &oldpath, NULL);
+    lfs_stag_t oldtag = lfs_dir_find(lfs, &oldcwd, &oldpath, NULL);
     if (oldtag < 0 || lfs_tag_id(oldtag) == 0x3ff) {
         return (oldtag < 0) ? (int)oldtag : LFS_ERR_INVAL;
     }
@@ -3120,9 +3974,9 @@ static int lfs_rawrename(const char* oldpath, const char* newpath) {
     // find new entry
     lfs_mdir_t newcwd;
     uint16_t newid;
-    lfs_stag_t prevtag = lfs_dir_find(&newcwd, &newpath, &newid);
+    lfs_stag_t prevtag = lfs_dir_find(lfs, &newcwd, &newpath, &newid);
     if ((prevtag < 0 || lfs_tag_id(prevtag) == 0x3ff) &&
-            !(prevtag == LFS_ERR_NOENT && newid != 0x3ff)) {
+            !(prevtag == LFS_ERR_NOENT && lfs_path_islast(newpath))) {
         return (prevtag < 0) ? (int)prevtag : LFS_ERR_INVAL;
     }
 
@@ -3131,11 +3985,17 @@ static int lfs_rawrename(const char* oldpath, const char* newpath) {
     uint16_t newoldid = lfs_tag_id(oldtag);
 
     struct lfs_mlist prevdir;
-    prevdir.next = lfs.mlist;
+    prevdir.next = lfs->mlist;
     if (prevtag == LFS_ERR_NOENT) {
+        // if we're a file, don't allow trailing slashes
+        if (lfs_path_isdir(newpath)
+                && lfs_tag_type3(oldtag) != LFS_TYPE_DIR) {
+            return LFS_ERR_NOTDIR;
+        }
+
         // check that name fits
-        lfs_size_t nlen = strlen(newpath);
-        if (nlen > lfs.name_max) {
+        lfs_size_t nlen = lfs_path_namelen(newpath);
+        if (nlen > lfs->name_max) {
             return LFS_ERR_NAMETOOLONG;
         }
 
@@ -3146,22 +4006,24 @@ static int lfs_rawrename(const char* oldpath, const char* newpath) {
             newoldid += 1;
         }
     } else if (lfs_tag_type3(prevtag) != lfs_tag_type3(oldtag)) {
-        return LFS_ERR_ISDIR;
+        return (lfs_tag_type3(prevtag) == LFS_TYPE_DIR)
+                ? LFS_ERR_ISDIR
+                : LFS_ERR_NOTDIR;
     } else if (samepair && newid == newoldid) {
         // we're renaming to ourselves??
-        return LFS_ERR_OK;
+        return 0;
     } else if (lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {
         // must be empty before removal
         lfs_block_t prevpair[2];
-        lfs_stag_t res = lfs_dir_get(&newcwd, LFS_MKTAG(0x700, 0x3ff, 0),
-                                     LFS_MKTAG(LFS_TYPE_STRUCT, newid, 8), prevpair);
+        lfs_stag_t res = lfs_dir_get(lfs, &newcwd, LFS_MKTAG(0x700, 0x3ff, 0),
+                LFS_MKTAG(LFS_TYPE_STRUCT, newid, 8), prevpair);
         if (res < 0) {
             return (int)res;
         }
         lfs_pair_fromle32(prevpair);
 
         // must be empty before removal
-        err = lfs_dir_fetch(&prevdir.m, prevpair);
+        err = lfs_dir_fetch(lfs, &prevdir.m, prevpair);
         if (err) {
             return err;
         }
@@ -3171,7 +4033,7 @@ static int lfs_rawrename(const char* oldpath, const char* newpath) {
         }
 
         // mark fs as orphaned
-        err = lfs_fs_preporphans(+1);
+        err = lfs_fs_preporphans(lfs, +1);
         if (err) {
             return err;
         }
@@ -3180,65 +4042,71 @@ static int lfs_rawrename(const char* oldpath, const char* newpath) {
         // commit (if predecessor is child)
         prevdir.type = 0;
         prevdir.id = 0;
-        lfs.mlist = &prevdir;
+        lfs->mlist = &prevdir;
     }
 
     if (!samepair) {
-        lfs_fs_prepmove(newoldid, oldcwd.pair);
+        lfs_fs_prepmove(lfs, newoldid, oldcwd.pair);
     }
 
     // move over all attributes
-    err = lfs_dir_commit(
-        &newcwd,
-        LFS_MKATTRS({LFS_MKTAG_IF(prevtag != LFS_ERR_NOENT, LFS_TYPE_DELETE, newid, 0), NULL},
-                    {LFS_MKTAG(LFS_TYPE_CREATE, newid, 0), NULL},
-                    {LFS_MKTAG(lfs_tag_type3(oldtag), newid, strlen(newpath)), newpath},
-                    {LFS_MKTAG(LFS_FROM_MOVE, newid, lfs_tag_id(oldtag)), &oldcwd},
-                    {LFS_MKTAG_IF(samepair, LFS_TYPE_DELETE, newoldid, 0), NULL}));
+    err = lfs_dir_commit(lfs, &newcwd, LFS_MKATTRS(
+            {LFS_MKTAG_IF(prevtag != LFS_ERR_NOENT,
+                LFS_TYPE_DELETE, newid, 0), NULL},
+            {LFS_MKTAG(LFS_TYPE_CREATE, newid, 0), NULL},
+            {LFS_MKTAG(lfs_tag_type3(oldtag),
+                newid, lfs_path_namelen(newpath)), newpath},
+            {LFS_MKTAG(LFS_FROM_MOVE, newid, lfs_tag_id(oldtag)), &oldcwd},
+            {LFS_MKTAG_IF(samepair,
+                LFS_TYPE_DELETE, newoldid, 0), NULL}));
     if (err) {
-        lfs.mlist = prevdir.next;
+        lfs->mlist = prevdir.next;
         return err;
     }
 
     // let commit clean up after move (if we're different! otherwise move
     // logic already fixed it for us)
-    if (!samepair && lfs_gstate_hasmove(&lfs.gstate)) {
+    if (!samepair && lfs_gstate_hasmove(&lfs->gstate)) {
         // prep gstate and delete move id
-        lfs_fs_prepmove(0x3ff, NULL);
-        err = lfs_dir_commit(
-            &oldcwd, LFS_MKATTRS({LFS_MKTAG(LFS_TYPE_DELETE, lfs_tag_id(oldtag), 0), NULL}));
+        lfs_fs_prepmove(lfs, 0x3ff, NULL);
+        err = lfs_dir_commit(lfs, &oldcwd, LFS_MKATTRS(
+                {LFS_MKTAG(LFS_TYPE_DELETE, lfs_tag_id(oldtag), 0), NULL}));
         if (err) {
-            lfs.mlist = prevdir.next;
+            lfs->mlist = prevdir.next;
             return err;
         }
     }
 
-    lfs.mlist = prevdir.next;
-    if (prevtag != LFS_ERR_NOENT && lfs_tag_type3(prevtag) == LFS_TYPE_DIR) {
+    lfs->mlist = prevdir.next;
+    if (lfs_gstate_hasorphans(&lfs->gstate)) {
+        LFS_ASSERT(prevtag != LFS_ERR_NOENT
+                && lfs_tag_type3(prevtag) == LFS_TYPE_DIR);
+
         // fix orphan
-        err = lfs_fs_preporphans(-1);
+        err = lfs_fs_preporphans(lfs, -1);
         if (err) {
             return err;
         }
 
-        err = lfs_fs_pred(prevdir.m.pair, &newcwd);
+        err = lfs_fs_pred(lfs, prevdir.m.pair, &newcwd);
         if (err) {
             return err;
         }
 
-        err = lfs_dir_drop(&newcwd, &prevdir.m);
+        err = lfs_dir_drop(lfs, &newcwd, &prevdir.m);
         if (err) {
             return err;
         }
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 #endif
 
-static lfs_ssize_t lfs_rawgetattr(const char* path, uint8_t type, void* buffer, lfs_size_t size) {
+static lfs_ssize_t lfs_getattr_(lfs_t *lfs, const char *path,
+        uint8_t type, void *buffer, lfs_size_t size) {
     lfs_mdir_t cwd;
-    lfs_stag_t tag = lfs_dir_find(&cwd, &path, NULL);
+    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);
     if (tag < 0) {
         return tag;
     }
@@ -3247,14 +4115,16 @@ static lfs_ssize_t lfs_rawgetattr(const char* path, uint8_t type, void* buffer,
     if (id == 0x3ff) {
         // special case for root
         id = 0;
-        int err = lfs_dir_fetch(&cwd, lfs.root);
+        int err = lfs_dir_fetch(lfs, &cwd, lfs->root);
         if (err) {
             return err;
         }
     }
 
-    tag = lfs_dir_get(&cwd, LFS_MKTAG(0x7ff, 0x3ff, 0),
-                      LFS_MKTAG(LFS_TYPE_USERATTR + type, id, lfs_min(size, lfs.attr_max)), buffer);
+    tag = lfs_dir_get(lfs, &cwd, LFS_MKTAG(0x7ff, 0x3ff, 0),
+            LFS_MKTAG(LFS_TYPE_USERATTR + type,
+                id, lfs_min(size, lfs->attr_max)),
+            buffer);
     if (tag < 0) {
         if (tag == LFS_ERR_NOENT) {
             return LFS_ERR_NOATTR;
@@ -3267,9 +4137,10 @@ static lfs_ssize_t lfs_rawgetattr(const char* path, uint8_t type, void* buffer,
 }
 
 #ifndef LFS_READONLY
-static int lfs_commitattr(const char* path, uint8_t type, const void* buffer, lfs_size_t size) {
+static int lfs_commitattr(lfs_t *lfs, const char *path,
+        uint8_t type, const void *buffer, lfs_size_t size) {
     lfs_mdir_t cwd;
-    lfs_stag_t tag = lfs_dir_find(&cwd, &path, NULL);
+    lfs_stag_t tag = lfs_dir_find(lfs, &cwd, &path, NULL);
     if (tag < 0) {
         return tag;
     }
@@ -3278,53 +4149,97 @@ static int lfs_commitattr(const char* path, uint8_t type, const void* buffer, lf
     if (id == 0x3ff) {
         // special case for root
         id = 0;
-        int err = lfs_dir_fetch(&cwd, lfs.root);
+        int err = lfs_dir_fetch(lfs, &cwd, lfs->root);
         if (err) {
             return err;
         }
     }
 
-    return lfs_dir_commit(&cwd,
-                          LFS_MKATTRS({LFS_MKTAG(LFS_TYPE_USERATTR + type, id, size), buffer}));
+    return lfs_dir_commit(lfs, &cwd, LFS_MKATTRS(
+            {LFS_MKTAG(LFS_TYPE_USERATTR + type, id, size), buffer}));
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_rawsetattr(const char* path, uint8_t type, const void* buffer, lfs_size_t size) {
-    if (size > lfs.attr_max) {
+static int lfs_setattr_(lfs_t *lfs, const char *path,
+        uint8_t type, const void *buffer, lfs_size_t size) {
+    if (size > lfs->attr_max) {
         return LFS_ERR_NOSPC;
     }
 
-    return lfs_commitattr(path, type, buffer, size);
+    return lfs_commitattr(lfs, path, type, buffer, size);
 }
 #endif
 
 #ifndef LFS_READONLY
-static int lfs_rawremoveattr(const char* path, uint8_t type) {
-    return lfs_commitattr(path, type, NULL, 0x3ff);
+static int lfs_removeattr_(lfs_t *lfs, const char *path, uint8_t type) {
+    return lfs_commitattr(lfs, path, type, NULL, 0x3ff);
 }
 #endif
 
 
 /// Filesystem operations ///
-static int lfs_init(const struct lfs_config* cfg) {
-    lfs.cfg = cfg;
+
+// compile time checks, see lfs.h for why these limits exist
+#if LFS_NAME_MAX > 1022
+#error "Invalid LFS_NAME_MAX, must be <= 1022"
+#endif
+
+#if LFS_FILE_MAX > 2147483647
+#error "Invalid LFS_FILE_MAX, must be <= 2147483647"
+#endif
+
+#if LFS_ATTR_MAX > 1022
+#error "Invalid LFS_ATTR_MAX, must be <= 1022"
+#endif
+
+// common filesystem initialization
+static int lfs_init(lfs_t *lfs, const struct lfs_config *cfg) {
+    lfs->cfg = cfg;
+    lfs->block_count = cfg->block_count;  // May be 0
     int err = 0;
 
+#ifdef LFS_MULTIVERSION
+    // this driver only supports minor version < current minor version
+    LFS_ASSERT(!lfs->cfg->disk_version || (
+            (0xffff & (lfs->cfg->disk_version >> 16))
+                    == LFS_DISK_VERSION_MAJOR
+                && (0xffff & (lfs->cfg->disk_version >> 0))
+                    <= LFS_DISK_VERSION_MINOR));
+#endif
+
+    // check that bool is a truthy-preserving type
+    //
+    // note the most common reason for this failure is a before-c99 compiler,
+    // which littlefs currently does not support
+    LFS_ASSERT((bool)0x80000000);
+
+    // check that the required io functions are provided
+    LFS_ASSERT(lfs->cfg->read != NULL);
+#ifndef LFS_READONLY
+    LFS_ASSERT(lfs->cfg->prog != NULL);
+    LFS_ASSERT(lfs->cfg->erase != NULL);
+    LFS_ASSERT(lfs->cfg->sync != NULL);
+#endif
+
     // validate that the lfs-cfg sizes were initiated properly before
     // performing any arithmetic logics with them
-    LFS_ASSERT(lfs.cfg->read_size != 0);
-    LFS_ASSERT(lfs.cfg->prog_size != 0);
-    LFS_ASSERT(lfs.cfg->cache_size != 0);
+    LFS_ASSERT(lfs->cfg->read_size != 0);
+    LFS_ASSERT(lfs->cfg->prog_size != 0);
+    LFS_ASSERT(lfs->cfg->cache_size != 0);
 
     // check that block size is a multiple of cache size is a multiple
     // of prog and read sizes
-    LFS_ASSERT(lfs.cfg->cache_size % lfs.cfg->read_size == 0);
-    LFS_ASSERT(lfs.cfg->cache_size % lfs.cfg->prog_size == 0);
-    LFS_ASSERT(lfs.cfg->block_size % lfs.cfg->cache_size == 0);
+    LFS_ASSERT(lfs->cfg->cache_size % lfs->cfg->read_size == 0);
+    LFS_ASSERT(lfs->cfg->cache_size % lfs->cfg->prog_size == 0);
+    LFS_ASSERT(lfs->cfg->block_size % lfs->cfg->cache_size == 0);
 
-    // check that the block size is large enough to fit ctz pointers
-    LFS_ASSERT(4 * lfs_npw2(0xffffffff / (lfs.cfg->block_size - 2 * 4)) <= lfs.cfg->block_size);
+    // check that the block size is large enough to fit all ctz pointers
+    LFS_ASSERT(lfs->cfg->block_size >= 128);
+    // this is the exact calculation for all ctz pointers, if this fails
+    // and the simpler assert above does not, math must be broken
+    LFS_ASSERT(4*lfs_npw2(0xffffffff / (lfs->cfg->block_size-2*4))
+            <= lfs->cfg->block_size);
 
     // block_cycles = 0 is no longer supported.
     //
@@ -3332,190 +4247,263 @@ static int lfs_init(const struct lfs_config* cfg) {
     // metadata logs as a part of wear leveling. Suggested values are in the
     // range of 100-1000, or set block_cycles to -1 to disable block-level
     // wear-leveling.
-    LFS_ASSERT(lfs.cfg->block_cycles != 0);
+    LFS_ASSERT(lfs->cfg->block_cycles != 0);
+
+    // check that compact_thresh makes sense
+    //
+    // metadata can't be compacted below block_size/2, and metadata can't
+    // exceed a block_size
+    LFS_ASSERT(lfs->cfg->compact_thresh == 0
+            || lfs->cfg->compact_thresh >= lfs->cfg->block_size/2);
+    LFS_ASSERT(lfs->cfg->compact_thresh == (lfs_size_t)-1
+            || lfs->cfg->compact_thresh <= lfs->cfg->block_size);
+
+    // check that metadata_max is a multiple of read_size and prog_size,
+    // and a factor of the block_size
+    LFS_ASSERT(!lfs->cfg->metadata_max
+            || lfs->cfg->metadata_max % lfs->cfg->read_size == 0);
+    LFS_ASSERT(!lfs->cfg->metadata_max
+            || lfs->cfg->metadata_max % lfs->cfg->prog_size == 0);
+    LFS_ASSERT(!lfs->cfg->metadata_max
+            || lfs->cfg->block_size % lfs->cfg->metadata_max == 0);
 
     // setup read cache
-    if (lfs.cfg->read_buffer) {
-        lfs.rcache.buffer = lfs.cfg->read_buffer;
+    if (lfs->cfg->read_buffer) {
+        lfs->rcache.buffer = lfs->cfg->read_buffer;
     } else {
-        lfs.rcache.buffer = lfs_malloc(lfs.cfg->cache_size);
-        if (!lfs.rcache.buffer) {
+        lfs->rcache.buffer = lfs_malloc(lfs->cfg->cache_size);
+        if (!lfs->rcache.buffer) {
             err = LFS_ERR_NOMEM;
             goto cleanup;
         }
     }
 
     // setup program cache
-    if (lfs.cfg->prog_buffer) {
-        lfs.pcache.buffer = lfs.cfg->prog_buffer;
+    if (lfs->cfg->prog_buffer) {
+        lfs->pcache.buffer = lfs->cfg->prog_buffer;
     } else {
-        lfs.pcache.buffer = lfs_malloc(lfs.cfg->cache_size);
-        if (!lfs.pcache.buffer) {
+        lfs->pcache.buffer = lfs_malloc(lfs->cfg->cache_size);
+        if (!lfs->pcache.buffer) {
             err = LFS_ERR_NOMEM;
             goto cleanup;
         }
     }
 
     // zero to avoid information leaks
-    lfs_cache_zero(&lfs.rcache);
-    lfs_cache_zero(&lfs.pcache);
-
-    // setup lookahead, must be multiple of 64-bits, 32-bit aligned
-    LFS_ASSERT(lfs.cfg->lookahead_size > 0);
-    LFS_ASSERT(lfs.cfg->lookahead_size % 8 == 0 && (uintptr_t)lfs.cfg->lookahead_buffer % 4 == 0);
-    if (lfs.cfg->lookahead_buffer) {
-        lfs.free.buffer = lfs.cfg->lookahead_buffer;
+    lfs_cache_zero(lfs, &lfs->rcache);
+    lfs_cache_zero(lfs, &lfs->pcache);
+
+    // setup lookahead buffer, note mount finishes initializing this after
+    // we establish a decent pseudo-random seed
+    LFS_ASSERT(lfs->cfg->lookahead_size > 0);
+    if (lfs->cfg->lookahead_buffer) {
+        lfs->lookahead.buffer = lfs->cfg->lookahead_buffer;
     } else {
-        lfs.free.buffer = lfs_malloc(lfs.cfg->lookahead_size);
-        if (!lfs.free.buffer) {
+        lfs->lookahead.buffer = lfs_malloc(lfs->cfg->lookahead_size);
+        if (!lfs->lookahead.buffer) {
             err = LFS_ERR_NOMEM;
             goto cleanup;
         }
     }
 
     // check that the size limits are sane
-    LFS_ASSERT(lfs.cfg->name_max <= LFS_NAME_MAX);
-    lfs.name_max = lfs.cfg->name_max;
-    if (!lfs.name_max) {
-        lfs.name_max = LFS_NAME_MAX;
-    }
-
-    LFS_ASSERT(lfs.cfg->file_max <= LFS_FILE_MAX);
-    lfs.file_max = lfs.cfg->file_max;
-    if (!lfs.file_max) {
-        lfs.file_max = LFS_FILE_MAX;
-    }
-
-    LFS_ASSERT(lfs.cfg->attr_max <= LFS_ATTR_MAX);
-    lfs.attr_max = lfs.cfg->attr_max;
-    if (!lfs.attr_max) {
-        lfs.attr_max = LFS_ATTR_MAX;
+    LFS_ASSERT(lfs->cfg->name_max <= LFS_NAME_MAX);
+    lfs->name_max = lfs->cfg->name_max;
+    if (!lfs->name_max) {
+        lfs->name_max = LFS_NAME_MAX;
+    }
+
+    LFS_ASSERT(lfs->cfg->file_max <= LFS_FILE_MAX);
+    lfs->file_max = lfs->cfg->file_max;
+    if (!lfs->file_max) {
+        lfs->file_max = LFS_FILE_MAX;
+    }
+
+    LFS_ASSERT(lfs->cfg->attr_max <= LFS_ATTR_MAX);
+    lfs->attr_max = lfs->cfg->attr_max;
+    if (!lfs->attr_max) {
+        lfs->attr_max = LFS_ATTR_MAX;
+    }
+
+    LFS_ASSERT(lfs->cfg->metadata_max <= lfs->cfg->block_size);
+
+    LFS_ASSERT(lfs->cfg->inline_max == (lfs_size_t)-1
+            || lfs->cfg->inline_max <= lfs->cfg->cache_size);
+    LFS_ASSERT(lfs->cfg->inline_max == (lfs_size_t)-1
+            || lfs->cfg->inline_max <= lfs->attr_max);
+    LFS_ASSERT(lfs->cfg->inline_max == (lfs_size_t)-1
+            || lfs->cfg->inline_max <= ((lfs->cfg->metadata_max)
+                ? lfs->cfg->metadata_max
+                : lfs->cfg->block_size)/8);
+    lfs->inline_max = lfs->cfg->inline_max;
+    if (lfs->inline_max == (lfs_size_t)-1) {
+        lfs->inline_max = 0;
+    } else if (lfs->inline_max == 0) {
+        lfs->inline_max = lfs_min(
+                lfs->cfg->cache_size,
+                lfs_min(
+                    lfs->attr_max,
+                    ((lfs->cfg->metadata_max)
+                        ? lfs->cfg->metadata_max
+                        : lfs->cfg->block_size)/8));
     }
 
-    LFS_ASSERT(lfs.cfg->metadata_max <= lfs.cfg->block_size);
-
     // setup default state
-    lfs.root[0] = LFS_BLOCK_NULL;
-    lfs.root[1] = LFS_BLOCK_NULL;
-    lfs.mlist = NULL;
-    lfs.seed = 0;
-    lfs.gdisk = (lfs_gstate_t){0};
-    lfs.gstate = (lfs_gstate_t){0};
-    lfs.gdelta = (lfs_gstate_t){0};
+    lfs->root[0] = LFS_BLOCK_NULL;
+    lfs->root[1] = LFS_BLOCK_NULL;
+    lfs->mlist = NULL;
+    lfs->seed = 0;
+    lfs->gdisk = (lfs_gstate_t){0};
+    lfs->gstate = (lfs_gstate_t){0};
+    lfs->gdelta = (lfs_gstate_t){0};
+#ifdef LFS_MIGRATE
+    lfs->lfs1 = NULL;
+#endif
 
-    return LFS_ERR_OK;
+    return 0;
 
 cleanup:
-    lfs_deinit();
+    lfs_deinit(lfs);
     return err;
 }
 
-static int lfs_deinit(void) {
+static int lfs_deinit(lfs_t *lfs) {
     // free allocated memory
-    if (!lfs.cfg->read_buffer) {
-        lfs_free(lfs.rcache.buffer);
+    if (!lfs->cfg->read_buffer) {
+        lfs_free(lfs->rcache.buffer);
     }
 
-    if (!lfs.cfg->prog_buffer) {
-        lfs_free(lfs.pcache.buffer);
+    if (!lfs->cfg->prog_buffer) {
+        lfs_free(lfs->pcache.buffer);
     }
 
-    if (!lfs.cfg->lookahead_buffer) {
-        lfs_free(lfs.free.buffer);
+    if (!lfs->cfg->lookahead_buffer) {
+        lfs_free(lfs->lookahead.buffer);
     }
 
-    return LFS_ERR_OK;
+    return 0;
 }
 
-// Thread-safe wrappers if enabled
-#if LIB_PICO_MULTICORE
-#define LFS_LOCK lfs.cfg->lock()
-#define LFS_UNLOCK lfs.cfg->unlock()
-#else
-#define LFS_LOCK LFS_ERR_OK
-#define LFS_UNLOCK LFS_ERR_OK
-#endif
+
 
 #ifndef LFS_READONLY
-static int lfs_rawformat(const struct lfs_config* cfg) {
-    int err = lfs_init(cfg);
-    if (err) {
-        return err;
-    }
-    LFS_LOCK;
+static int lfs_format_(lfs_t *lfs, const struct lfs_config *cfg) {
+    int err = 0;
+    {
+        err = lfs_init(lfs, cfg);
+        if (err) {
+            return err;
+        }
 
-    // create free lookahead
-    memset(lfs.free.buffer, 0, lfs.cfg->lookahead_size);
-    lfs.free.off = 0;
-    lfs.free.size = lfs_min(8 * lfs.cfg->lookahead_size, lfs.cfg->block_count);
-    lfs.free.i = 0;
-    lfs_alloc_ack();
+        LFS_ASSERT(cfg->block_count != 0);
 
-    // create root dir
-    lfs_mdir_t root;
-    err = lfs_dir_alloc(&root);
-    if (err) {
-        goto cleanup;
-    }
+        // create free lookahead
+        memset(lfs->lookahead.buffer, 0, lfs->cfg->lookahead_size);
+        lfs->lookahead.start = 0;
+        lfs->lookahead.size = lfs_min(8*lfs->cfg->lookahead_size,
+                lfs->block_count);
+        lfs->lookahead.next = 0;
+        lfs_alloc_ckpoint(lfs);
 
-    // write one superblock
-    lfs_superblock_t superblock = {
-        .version = LFS_DISK_VERSION,
-        .block_size = lfs.cfg->block_size,
-        .block_count = lfs.cfg->block_count,
-        .name_max = lfs.name_max,
-        .file_max = lfs.file_max,
-        .attr_max = lfs.attr_max,
-    };
+        // create root dir
+        lfs_mdir_t root;
+        err = lfs_dir_alloc(lfs, &root);
+        if (err) {
+            goto cleanup;
+        }
 
-    lfs_superblock_tole32(&superblock);
-    err = lfs_dir_commit(
-        &root, LFS_MKATTRS({LFS_MKTAG(LFS_TYPE_CREATE, 0, 0), NULL},
-                           {LFS_MKTAG(LFS_TYPE_SUPERBLOCK, 0, 8), "littlefs"},
-                           {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)), &superblock}));
-    if (err) {
-        goto cleanup;
-    }
+        // write one superblock
+        lfs_superblock_t superblock = {
+            .version     = lfs_fs_disk_version(lfs),
+            .block_size  = lfs->cfg->block_size,
+            .block_count = lfs->block_count,
+            .name_max    = lfs->name_max,
+            .file_max    = lfs->file_max,
+            .attr_max    = lfs->attr_max,
+        };
 
-    // force compaction to prevent accidentally mounting any
-    // older version of littlefs that may live on disk
-    root.erased = false;
-    err = lfs_dir_commit(&root, NULL, 0);
-    if (err) {
-        goto cleanup;
-    }
+        lfs_superblock_tole32(&superblock);
+        err = lfs_dir_commit(lfs, &root, LFS_MKATTRS(
+                {LFS_MKTAG(LFS_TYPE_CREATE, 0, 0), NULL},
+                {LFS_MKTAG(LFS_TYPE_SUPERBLOCK, 0, 8), "littlefs"},
+                {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),
+                    &superblock}));
+        if (err) {
+            goto cleanup;
+        }
+
+        // force compaction to prevent accidentally mounting any
+        // older version of littlefs that may live on disk
+        root.erased = false;
+        err = lfs_dir_commit(lfs, &root, NULL, 0);
+        if (err) {
+            goto cleanup;
+        }
 
-    // sanity check that fetch works
-    err = lfs_dir_fetch(&root, (const lfs_block_t[2]){0, 1});
+        // sanity check that fetch works
+        err = lfs_dir_fetch(lfs, &root, (const lfs_block_t[2]){0, 1});
+        if (err) {
+            goto cleanup;
+        }
+    }
 
 cleanup:
-    LFS_UNLOCK;
-    lfs_deinit();
+    lfs_deinit(lfs);
     return err;
+
 }
 #endif
 
-static int lfs_rawmount(const struct lfs_config* cfg) {
-    int err = lfs_init(cfg);
+struct lfs_tortoise_t {
+    lfs_block_t pair[2];
+    lfs_size_t i;
+    lfs_size_t period;
+};
+
+static int lfs_tortoise_detectcycles(
+    const lfs_mdir_t *dir, struct lfs_tortoise_t *tortoise) {
+    // detect cycles with Brent's algorithm
+    if (lfs_pair_issync(dir->tail, tortoise->pair)) {
+        LFS_WARN("Cycle detected in tail list");
+        return LFS_ERR_CORRUPT;
+    }
+    if (tortoise->i == tortoise->period) {
+        tortoise->pair[0] = dir->tail[0];
+        tortoise->pair[1] = dir->tail[1];
+        tortoise->i = 0;
+        tortoise->period *= 2;
+    }
+    tortoise->i += 1;
+
+    return LFS_ERR_OK;
+}
+
+static int lfs_mount_(lfs_t *lfs, const struct lfs_config *cfg) {
+    int err = lfs_init(lfs, cfg);
     if (err) {
         return err;
     }
-    LFS_LOCK;
+
     // scan directory blocks for superblock and any global updates
     lfs_mdir_t dir = {.tail = {0, 1}};
-    lfs_block_t cycle = 0;
+    struct lfs_tortoise_t tortoise = {
+        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},
+        .i = 1,
+        .period = 1,
+    };
     while (!lfs_pair_isnull(dir.tail)) {
-        if (cycle >= lfs.cfg->block_count / 2) {
-            // loop detected
-            err = LFS_ERR_CORRUPT;
+        err = lfs_tortoise_detectcycles(&dir, &tortoise);
+        if (err < 0) {
             goto cleanup;
         }
-        cycle += 1;
 
         // fetch next block in tail list
-        lfs_stag_t tag = lfs_dir_fetchmatch(
-            &dir, dir.tail, LFS_MKTAG(0x7ff, 0x3ff, 0), LFS_MKTAG(LFS_TYPE_SUPERBLOCK, 0, 8), NULL,
-            lfs_dir_find_match, &(struct lfs_dir_find_match){"littlefs", 8});
+        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, &dir, dir.tail,
+                LFS_MKTAG(0x7ff, 0x3ff, 0),
+                LFS_MKTAG(LFS_TYPE_SUPERBLOCK, 0, 8),
+                NULL,
+                lfs_dir_find_match, &(struct lfs_dir_find_match){
+                    lfs, "littlefs", 8});
         if (tag < 0) {
             err = tag;
             goto cleanup;
@@ -3524,13 +4512,14 @@ static int lfs_rawmount(const struct lfs_config* cfg) {
         // has superblock?
         if (tag && !lfs_tag_isdelete(tag)) {
             // update root
-            lfs.root[0] = dir.pair[0];
-            lfs.root[1] = dir.pair[1];
+            lfs->root[0] = dir.pair[0];
+            lfs->root[1] = dir.pair[1];
 
             // grab superblock
             lfs_superblock_t superblock;
-            tag = lfs_dir_get(&dir, LFS_MKTAG(0x7ff, 0x3ff, 0),
-                              LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)), &superblock);
+            tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),
+                    LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),
+                    &superblock);
             if (tag < 0) {
                 err = tag;
                 goto cleanup;
@@ -3540,97 +4529,196 @@ static int lfs_rawmount(const struct lfs_config* cfg) {
             // check version
             uint16_t major_version = (0xffff & (superblock.version >> 16));
             uint16_t minor_version = (0xffff & (superblock.version >>  0));
-            if ((major_version != LFS_DISK_VERSION_MAJOR ||
-                 minor_version > LFS_DISK_VERSION_MINOR)) {
-                LFS_ERROR("Invalid version v%"PRIu16".%"PRIu16,
-                        major_version, minor_version);
+            if (major_version != lfs_fs_disk_version_major(lfs)
+                    || minor_version > lfs_fs_disk_version_minor(lfs)) {
+                LFS_ERROR("Invalid version "
+                        "v%"PRIu16".%"PRIu16" != v%"PRIu16".%"PRIu16,
+                        major_version,
+                        minor_version,
+                        lfs_fs_disk_version_major(lfs),
+                        lfs_fs_disk_version_minor(lfs));
                 err = LFS_ERR_INVAL;
                 goto cleanup;
             }
 
+            // found older minor version? set an in-device only bit in the
+            // gstate so we know we need to rewrite the superblock before
+            // the first write
+            bool needssuperblock = false;
+            if (minor_version < lfs_fs_disk_version_minor(lfs)) {
+                LFS_DEBUG("Found older minor version "
+                        "v%"PRIu16".%"PRIu16" < v%"PRIu16".%"PRIu16,
+                        major_version,
+                        minor_version,
+                        lfs_fs_disk_version_major(lfs),
+                        lfs_fs_disk_version_minor(lfs));
+                needssuperblock = true;
+            }
+            // note this bit is reserved on disk, so fetching more gstate
+            // will not interfere here
+            lfs_fs_prepsuperblock(lfs, needssuperblock);
+
             // check superblock configuration
             if (superblock.name_max) {
-                if (superblock.name_max > lfs.name_max) {
-                    LFS_ERROR("Unsupported name_max (%" PRIu32 " > %" PRIu32 ")",
-                              superblock.name_max, lfs.name_max);
+                if (superblock.name_max > lfs->name_max) {
+                    LFS_ERROR("Unsupported name_max (%"PRIu32" > %"PRIu32")",
+                            superblock.name_max, lfs->name_max);
                     err = LFS_ERR_INVAL;
                     goto cleanup;
                 }
 
-                lfs.name_max = superblock.name_max;
+                lfs->name_max = superblock.name_max;
             }
 
             if (superblock.file_max) {
-                if (superblock.file_max > lfs.file_max) {
-                    LFS_ERROR("Unsupported file_max (%" PRIu32 " > %" PRIu32 ")",
-                              superblock.file_max, lfs.file_max);
+                if (superblock.file_max > lfs->file_max) {
+                    LFS_ERROR("Unsupported file_max (%"PRIu32" > %"PRIu32")",
+                            superblock.file_max, lfs->file_max);
                     err = LFS_ERR_INVAL;
                     goto cleanup;
                 }
 
-                lfs.file_max = superblock.file_max;
+                lfs->file_max = superblock.file_max;
             }
 
             if (superblock.attr_max) {
-                if (superblock.attr_max > lfs.attr_max) {
-                    LFS_ERROR("Unsupported attr_max (%" PRIu32 " > %" PRIu32 ")",
-                              superblock.attr_max, lfs.attr_max);
+                if (superblock.attr_max > lfs->attr_max) {
+                    LFS_ERROR("Unsupported attr_max (%"PRIu32" > %"PRIu32")",
+                            superblock.attr_max, lfs->attr_max);
                     err = LFS_ERR_INVAL;
                     goto cleanup;
                 }
 
-                lfs.attr_max = superblock.attr_max;
+                lfs->attr_max = superblock.attr_max;
+
+                // we also need to update inline_max in case attr_max changed
+                lfs->inline_max = lfs_min(lfs->inline_max, lfs->attr_max);
+            }
+
+            // this is where we get the block_count from disk if block_count=0
+            if (lfs->cfg->block_count
+                    && superblock.block_count != lfs->cfg->block_count) {
+                LFS_ERROR("Invalid block count (%"PRIu32" != %"PRIu32")",
+                        superblock.block_count, lfs->cfg->block_count);
+                err = LFS_ERR_INVAL;
+                goto cleanup;
+            }
+
+            lfs->block_count = superblock.block_count;
+
+            if (superblock.block_size != lfs->cfg->block_size) {
+                LFS_ERROR("Invalid block size (%"PRIu32" != %"PRIu32")",
+                        superblock.block_size, lfs->cfg->block_size);
+                err = LFS_ERR_INVAL;
+                goto cleanup;
             }
         }
 
         // has gstate?
-        err = lfs_dir_getgstate(&dir, &lfs.gstate);
+        err = lfs_dir_getgstate(lfs, &dir, &lfs->gstate);
         if (err) {
             goto cleanup;
         }
     }
 
-    // found superblock?
-    if (lfs_pair_isnull(lfs.root)) {
-        err = LFS_ERR_INVAL;
-        goto cleanup;
-    }
-
     // update littlefs with gstate
-    if (!lfs_gstate_iszero(&lfs.gstate)) {
-        LFS_DEBUG("Found pending gstate 0x%08" PRIx32 "%08" PRIx32 "%08" PRIx32, lfs.gstate.tag,
-                  lfs.gstate.pair[0], lfs.gstate.pair[1]);
+    if (!lfs_gstate_iszero(&lfs->gstate)) {
+        LFS_DEBUG("Found pending gstate 0x%08"PRIx32"%08"PRIx32"%08"PRIx32,
+                lfs->gstate.tag,
+                lfs->gstate.pair[0],
+                lfs->gstate.pair[1]);
     }
-    lfs.gstate.tag += !lfs_tag_isvalid(lfs.gstate.tag);
-    lfs.gdisk = lfs.gstate;
+    lfs->gstate.tag += !lfs_tag_isvalid(lfs->gstate.tag);
+    lfs->gdisk = lfs->gstate;
 
     // setup free lookahead, to distribute allocations uniformly across
     // boots, we start the allocator at a random location
-    lfs.free.off = lfs.seed % lfs.cfg->block_count;
-    lfs_alloc_drop();
-    LFS_UNLOCK;
-    return LFS_ERR_OK;
+    lfs->lookahead.start = lfs->seed % lfs->block_count;
+    lfs_alloc_drop(lfs);
+
+    return 0;
 
 cleanup:
-    lfs_rawunmount();
-    LFS_UNLOCK;
+    lfs_unmount_(lfs);
     return err;
 }
 
-static int lfs_rawunmount(void) { return lfs_deinit(); }
+static int lfs_unmount_(lfs_t *lfs) {
+    return lfs_deinit(lfs);
+}
+
 
 /// Filesystem filesystem operations ///
-int lfs_fs_rawtraverse(int (*cb)(void* data, lfs_block_t block), void* data, bool includeorphans) {
+static int lfs_fs_stat_(lfs_t *lfs, struct lfs_fsinfo *fsinfo) {
+    // if the superblock is up-to-date, we must be on the most recent
+    // minor version of littlefs
+    if (!lfs_gstate_needssuperblock(&lfs->gstate)) {
+        fsinfo->disk_version = lfs_fs_disk_version(lfs);
+
+    // otherwise we need to read the minor version on disk
+    } else {
+        // fetch the superblock
+        lfs_mdir_t dir;
+        int err = lfs_dir_fetch(lfs, &dir, lfs->root);
+        if (err) {
+            return err;
+        }
+
+        lfs_superblock_t superblock;
+        lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x7ff, 0x3ff, 0),
+                LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),
+                &superblock);
+        if (tag < 0) {
+            return tag;
+        }
+        lfs_superblock_fromle32(&superblock);
+
+        // read the on-disk version
+        fsinfo->disk_version = superblock.version;
+    }
+
+    // filesystem geometry
+    fsinfo->block_size = lfs->cfg->block_size;
+    fsinfo->block_count = lfs->block_count;
+
+    // other on-disk configuration, we cache all of these for internal use
+    fsinfo->name_max = lfs->name_max;
+    fsinfo->file_max = lfs->file_max;
+    fsinfo->attr_max = lfs->attr_max;
+
+    return 0;
+}
+
+int lfs_fs_traverse_(lfs_t *lfs,
+        int (*cb)(void *data, lfs_block_t block), void *data,
+        bool includeorphans) {
     // iterate over metadata pairs
     lfs_mdir_t dir = {.tail = {0, 1}};
 
-    lfs_block_t cycle = 0;
+#ifdef LFS_MIGRATE
+    // also consider v1 blocks during migration
+    if (lfs->lfs1) {
+        int err = lfs1_traverse(lfs, cb, data);
+        if (err) {
+            return err;
+        }
+
+        dir.tail[0] = lfs->root[0];
+        dir.tail[1] = lfs->root[1];
+    }
+#endif
+
+    struct lfs_tortoise_t tortoise = {
+        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},
+        .i = 1,
+        .period = 1,
+    };
+    int err = LFS_ERR_OK;
     while (!lfs_pair_isnull(dir.tail)) {
-        if (cycle >= lfs.cfg->block_count / 2) {
-            // loop detected
+        err = lfs_tortoise_detectcycles(&dir, &tortoise);
+        if (err < 0) {
             return LFS_ERR_CORRUPT;
         }
-        cycle += 1;
 
         for (int i = 0; i < 2; i++) {
             int err = cb(data, dir.tail[i]);
@@ -3640,15 +4728,15 @@ int lfs_fs_rawtraverse(int (*cb)(void* data, lfs_block_t block), void* data, boo
         }
 
         // iterate through ids in directory
-        int err = lfs_dir_fetch(&dir, dir.tail);
+        int err = lfs_dir_fetch(lfs, &dir, dir.tail);
         if (err) {
             return err;
         }
 
         for (uint16_t id = 0; id < dir.count; id++) {
             struct lfs_ctz ctz;
-            lfs_stag_t tag = lfs_dir_get(&dir, LFS_MKTAG(0x700, 0x3ff, 0),
-                                         LFS_MKTAG(LFS_TYPE_STRUCT, id, sizeof(ctz)), &ctz);
+            lfs_stag_t tag = lfs_dir_get(lfs, &dir, LFS_MKTAG(0x700, 0x3ff, 0),
+                    LFS_MKTAG(LFS_TYPE_STRUCT, id, sizeof(ctz)), &ctz);
             if (tag < 0) {
                 if (tag == LFS_ERR_NOENT) {
                     continue;
@@ -3658,7 +4746,8 @@ int lfs_fs_rawtraverse(int (*cb)(void* data, lfs_block_t block), void* data, boo
             lfs_ctz_fromle32(&ctz);
 
             if (lfs_tag_type3(tag) == LFS_TYPE_CTZSTRUCT) {
-                err = lfs_ctz_traverse(NULL, &lfs.rcache, ctz.head, ctz.size, cb, data);
+                err = lfs_ctz_traverse(lfs, NULL, &lfs->rcache,
+                        ctz.head, ctz.size, cb, data);
                 if (err) {
                     return err;
                 }
@@ -3676,20 +4765,22 @@ int lfs_fs_rawtraverse(int (*cb)(void* data, lfs_block_t block), void* data, boo
 
 #ifndef LFS_READONLY
     // iterate over any open files
-    for (lfs_file_t* f = (lfs_file_t*)lfs.mlist; f; f = f->next) {
+    for (lfs_file_t *f = (lfs_file_t*)lfs->mlist; f; f = f->next) {
         if (f->type != LFS_TYPE_REG) {
             continue;
         }
 
         if ((f->flags & LFS_F_DIRTY) && !(f->flags & LFS_F_INLINE)) {
-            int err = lfs_ctz_traverse(&f->cache, &lfs.rcache, f->ctz.head, f->ctz.size, cb, data);
+            int err = lfs_ctz_traverse(lfs, &f->cache, &lfs->rcache,
+                    f->ctz.head, f->ctz.size, cb, data);
             if (err) {
                 return err;
             }
         }
 
         if ((f->flags & LFS_F_WRITING) && !(f->flags & LFS_F_INLINE)) {
-            int err = lfs_ctz_traverse(&f->cache, &lfs.rcache, f->block, f->pos, cb, data);
+            int err = lfs_ctz_traverse(lfs, &f->cache, &lfs->rcache,
+                    f->block, f->pos, cb, data);
             if (err) {
                 return err;
             }
@@ -3697,27 +4788,32 @@ int lfs_fs_rawtraverse(int (*cb)(void* data, lfs_block_t block), void* data, boo
     }
 #endif
 
-    return LFS_ERR_OK;
+    return 0;
 }
 
 #ifndef LFS_READONLY
-static int lfs_fs_pred(const lfs_block_t pair[2], lfs_mdir_t* pdir) {
+static int lfs_fs_pred(lfs_t *lfs,
+        const lfs_block_t pair[2], lfs_mdir_t *pdir) {
     // iterate over all directory directory entries
     pdir->tail[0] = 0;
     pdir->tail[1] = 1;
-    lfs_block_t cycle = 0;
+    struct lfs_tortoise_t tortoise = {
+        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},
+        .i = 1,
+        .period = 1,
+    };
+    int err = LFS_ERR_OK;
     while (!lfs_pair_isnull(pdir->tail)) {
-        if (cycle >= lfs.cfg->block_count / 2) {
-            // loop detected
+        err = lfs_tortoise_detectcycles(pdir, &tortoise);
+        if (err < 0) {
             return LFS_ERR_CORRUPT;
         }
-        cycle += 1;
 
         if (lfs_pair_cmp(pdir->tail, pair) == 0) {
-            return LFS_ERR_OK;
+            return 0;
         }
 
-        int err = lfs_dir_fetch(pdir, pdir->tail);
+        int err = lfs_dir_fetch(lfs, pdir, pdir->tail);
         if (err) {
             return err;
         }
@@ -3729,6 +4825,7 @@ static int lfs_fs_pred(const lfs_block_t pair[2], lfs_mdir_t* pdir) {
 
 #ifndef LFS_READONLY
 struct lfs_fs_parent_match {
+    lfs_t *lfs;
     const lfs_block_t pair[2];
 };
 #endif
@@ -3737,12 +4834,14 @@ struct lfs_fs_parent_match {
 static int lfs_fs_parent_match(void *data,
         lfs_tag_t tag, const void *buffer) {
     struct lfs_fs_parent_match *find = data;
+    lfs_t *lfs = find->lfs;
     const struct lfs_diskoff *disk = buffer;
     (void)tag;
 
     lfs_block_t child[2];
-    int err = lfs_bd_read(&lfs.pcache, &lfs.rcache, lfs.cfg->block_size, disk->block, disk->off,
-                          &child, sizeof(child));
+    int err = lfs_bd_read(lfs,
+            &lfs->pcache, &lfs->rcache, lfs->cfg->block_size,
+            disk->block, disk->off, &child, sizeof(child));
     if (err) {
         return err;
     }
@@ -3753,21 +4852,29 @@ static int lfs_fs_parent_match(void *data,
 #endif
 
 #ifndef LFS_READONLY
-static lfs_stag_t lfs_fs_parent(const lfs_block_t pair[2], lfs_mdir_t* parent) {
+static lfs_stag_t lfs_fs_parent(lfs_t *lfs, const lfs_block_t pair[2],
+        lfs_mdir_t *parent) {
     // use fetchmatch with callback to find pairs
     parent->tail[0] = 0;
     parent->tail[1] = 1;
-    lfs_block_t cycle = 0;
+    struct lfs_tortoise_t tortoise = {
+        .pair = {LFS_BLOCK_NULL, LFS_BLOCK_NULL},
+        .i = 1,
+        .period = 1,
+    };
+    int err = LFS_ERR_OK;
     while (!lfs_pair_isnull(parent->tail)) {
-        if (cycle >= lfs.cfg->block_count / 2) {
-            // loop detected
-            return LFS_ERR_CORRUPT;
+        err = lfs_tortoise_detectcycles(parent, &tortoise);
+        if (err < 0) {
+            return err;
         }
-        cycle += 1;
 
-        lfs_stag_t tag = lfs_dir_fetchmatch(
-            parent, parent->tail, LFS_MKTAG(0x7ff, 0, 0x3ff), LFS_MKTAG(LFS_TYPE_DIRSTRUCT, 0, 8),
-            NULL, lfs_fs_parent_match, &(struct lfs_fs_parent_match){{pair[0], pair[1]}});
+        lfs_stag_t tag = lfs_dir_fetchmatch(lfs, parent, parent->tail,
+                LFS_MKTAG(0x7ff, 0, 0x3ff),
+                LFS_MKTAG(LFS_TYPE_DIRSTRUCT, 0, 8),
+                NULL,
+                lfs_fs_parent_match, &(struct lfs_fs_parent_match){
+                    lfs, {pair[0], pair[1]}});
         if (tag && tag != LFS_ERR_NOENT) {
             return tag;
         }
@@ -3777,274 +4884,1097 @@ static lfs_stag_t lfs_fs_parent(const lfs_block_t pair[2], lfs_mdir_t* parent) {
 }
 #endif
 
-#ifndef LFS_READONLY
-static int lfs_fs_relocate(const lfs_block_t oldpair[2], lfs_block_t newpair[2]) {
-    // update internal root
-    if (lfs_pair_cmp(oldpair, lfs.root) == 0) {
-        lfs.root[0] = newpair[0];
-        lfs.root[1] = newpair[1];
+static void lfs_fs_prepsuperblock(lfs_t *lfs, bool needssuperblock) {
+    lfs->gstate.tag = (lfs->gstate.tag & ~LFS_MKTAG(0, 0, 0x200))
+            | (uint32_t)needssuperblock << 9;
+}
+
+#ifndef LFS_READONLY
+static int lfs_fs_preporphans(lfs_t *lfs, int8_t orphans) {
+    LFS_ASSERT(lfs_tag_size(lfs->gstate.tag) > 0x000 || orphans >= 0);
+    LFS_ASSERT(lfs_tag_size(lfs->gstate.tag) < 0x1ff || orphans <= 0);
+    lfs->gstate.tag += orphans;
+    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x800, 0, 0)) |
+            ((uint32_t)lfs_gstate_hasorphans(&lfs->gstate) << 31));
+
+    return 0;
+}
+#endif
+
+#ifndef LFS_READONLY
+static void lfs_fs_prepmove(lfs_t *lfs,
+        uint16_t id, const lfs_block_t pair[2]) {
+    lfs->gstate.tag = ((lfs->gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
+            ((id != 0x3ff) ? LFS_MKTAG(LFS_TYPE_DELETE, id, 0) : 0));
+    lfs->gstate.pair[0] = (id != 0x3ff) ? pair[0] : 0;
+    lfs->gstate.pair[1] = (id != 0x3ff) ? pair[1] : 0;
+}
+#endif
+
+#ifndef LFS_READONLY
+static int lfs_fs_desuperblock(lfs_t *lfs) {
+    if (!lfs_gstate_needssuperblock(&lfs->gstate)) {
+        return 0;
+    }
+
+    LFS_DEBUG("Rewriting superblock {0x%"PRIx32", 0x%"PRIx32"}",
+            lfs->root[0],
+            lfs->root[1]);
+
+    lfs_mdir_t root;
+    int err = lfs_dir_fetch(lfs, &root, lfs->root);
+    if (err) {
+        return err;
+    }
+
+    // write a new superblock
+    lfs_superblock_t superblock = {
+        .version     = lfs_fs_disk_version(lfs),
+        .block_size  = lfs->cfg->block_size,
+        .block_count = lfs->block_count,
+        .name_max    = lfs->name_max,
+        .file_max    = lfs->file_max,
+        .attr_max    = lfs->attr_max,
+    };
+
+    lfs_superblock_tole32(&superblock);
+    err = lfs_dir_commit(lfs, &root, LFS_MKATTRS(
+            {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),
+                &superblock}));
+    if (err) {
+        return err;
+    }
+
+    lfs_fs_prepsuperblock(lfs, false);
+    return 0;
+}
+#endif
+
+#ifndef LFS_READONLY
+static int lfs_fs_demove(lfs_t *lfs) {
+    if (!lfs_gstate_hasmove(&lfs->gdisk)) {
+        return 0;
+    }
+
+    // Fix bad moves
+    LFS_DEBUG("Fixing move {0x%"PRIx32", 0x%"PRIx32"} 0x%"PRIx16,
+            lfs->gdisk.pair[0],
+            lfs->gdisk.pair[1],
+            lfs_tag_id(lfs->gdisk.tag));
+
+    // no other gstate is supported at this time, so if we found something else
+    // something most likely went wrong in gstate calculation
+    LFS_ASSERT(lfs_tag_type3(lfs->gdisk.tag) == LFS_TYPE_DELETE);
+
+    // fetch and delete the moved entry
+    lfs_mdir_t movedir;
+    int err = lfs_dir_fetch(lfs, &movedir, lfs->gdisk.pair);
+    if (err) {
+        return err;
+    }
+
+    // prep gstate and delete move id
+    uint16_t moveid = lfs_tag_id(lfs->gdisk.tag);
+    lfs_fs_prepmove(lfs, 0x3ff, NULL);
+    err = lfs_dir_commit(lfs, &movedir, LFS_MKATTRS(
+            {LFS_MKTAG(LFS_TYPE_DELETE, moveid, 0), NULL}));
+    if (err) {
+        return err;
+    }
+
+    return 0;
+}
+#endif
+
+#ifndef LFS_READONLY
+static int lfs_fs_deorphan(lfs_t *lfs, bool powerloss) {
+    if (!lfs_gstate_hasorphans(&lfs->gstate)) {
+        return 0;
+    }
+
+    // Check for orphans in two separate passes:
+    // - 1 for half-orphans (relocations)
+    // - 2 for full-orphans (removes/renames)
+    //
+    // Two separate passes are needed as half-orphans can contain outdated
+    // references to full-orphans, effectively hiding them from the deorphan
+    // search.
+    //
+    int pass = 0;
+    while (pass < 2) {
+        // Fix any orphans
+        lfs_mdir_t pdir = {.split = true, .tail = {0, 1}};
+        lfs_mdir_t dir;
+        bool moreorphans = false;
+
+        // iterate over all directory directory entries
+        while (!lfs_pair_isnull(pdir.tail)) {
+            int err = lfs_dir_fetch(lfs, &dir, pdir.tail);
+            if (err) {
+                return err;
+            }
+
+            // check head blocks for orphans
+            if (!pdir.split) {
+                // check if we have a parent
+                lfs_mdir_t parent;
+                lfs_stag_t tag = lfs_fs_parent(lfs, pdir.tail, &parent);
+                if (tag < 0 && tag != LFS_ERR_NOENT) {
+                    return tag;
+                }
+
+                if (pass == 0 && tag != LFS_ERR_NOENT) {
+                    lfs_block_t pair[2];
+                    lfs_stag_t state = lfs_dir_get(lfs, &parent,
+                            LFS_MKTAG(0x7ff, 0x3ff, 0), tag, pair);
+                    if (state < 0) {
+                        return state;
+                    }
+                    lfs_pair_fromle32(pair);
+
+                    if (!lfs_pair_issync(pair, pdir.tail)) {
+                        // we have desynced
+                        LFS_DEBUG("Fixing half-orphan "
+                                "{0x%"PRIx32", 0x%"PRIx32"} "
+                                "-> {0x%"PRIx32", 0x%"PRIx32"}",
+                                pdir.tail[0], pdir.tail[1], pair[0], pair[1]);
+
+                        // fix pending move in this pair? this looks like an
+                        // optimization but is in fact _required_ since
+                        // relocating may outdate the move.
+                        uint16_t moveid = 0x3ff;
+                        if (lfs_gstate_hasmovehere(&lfs->gstate, pdir.pair)) {
+                            moveid = lfs_tag_id(lfs->gstate.tag);
+                            LFS_DEBUG("Fixing move while fixing orphans "
+                                    "{0x%"PRIx32", 0x%"PRIx32"} 0x%"PRIx16"\n",
+                                    pdir.pair[0], pdir.pair[1], moveid);
+                            lfs_fs_prepmove(lfs, 0x3ff, NULL);
+                        }
+
+                        lfs_pair_tole32(pair);
+                        state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(
+                                {LFS_MKTAG_IF(moveid != 0x3ff,
+                                    LFS_TYPE_DELETE, moveid, 0), NULL},
+                                {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8),
+                                    pair}));
+                        lfs_pair_fromle32(pair);
+                        if (state < 0) {
+                            return state;
+                        }
+
+                        // did our commit create more orphans?
+                        if (state == LFS_OK_ORPHANED) {
+                            moreorphans = true;
+                        }
+
+                        // refetch tail
+                        continue;
+                    }
+                }
+
+                // note we only check for full orphans if we may have had a
+                // power-loss, otherwise orphans are created intentionally
+                // during operations such as lfs_mkdir
+                if (pass == 1 && tag == LFS_ERR_NOENT && powerloss) {
+                    // we are an orphan
+                    LFS_DEBUG("Fixing orphan {0x%"PRIx32", 0x%"PRIx32"}",
+                            pdir.tail[0], pdir.tail[1]);
+
+                    // steal state
+                    err = lfs_dir_getgstate(lfs, &dir, &lfs->gdelta);
+                    if (err) {
+                        return err;
+                    }
+
+                    // steal tail
+                    lfs_pair_tole32(dir.tail);
+                    int state = lfs_dir_orphaningcommit(lfs, &pdir, LFS_MKATTRS(
+                            {LFS_MKTAG(LFS_TYPE_TAIL + dir.split, 0x3ff, 8),
+                                dir.tail}));
+                    lfs_pair_fromle32(dir.tail);
+                    if (state < 0) {
+                        return state;
+                    }
+
+                    // did our commit create more orphans?
+                    if (state == LFS_OK_ORPHANED) {
+                        moreorphans = true;
+                    }
+
+                    // refetch tail
+                    continue;
+                }
+            }
+
+            pdir = dir;
+        }
+
+        pass = moreorphans ? 0 : pass+1;
+    }
+
+    // mark orphans as fixed
+    return lfs_fs_preporphans(lfs, -lfs_gstate_getorphans(&lfs->gstate));
+}
+#endif
+
+#ifndef LFS_READONLY
+static int lfs_fs_forceconsistency(lfs_t *lfs) {
+    int err = lfs_fs_desuperblock(lfs);
+    if (err) {
+        return err;
+    }
+
+    err = lfs_fs_demove(lfs);
+    if (err) {
+        return err;
+    }
+
+    err = lfs_fs_deorphan(lfs, true);
+    if (err) {
+        return err;
+    }
+
+    return 0;
+}
+#endif
+
+#ifndef LFS_READONLY
+static int lfs_fs_mkconsistent_(lfs_t *lfs) {
+    // lfs_fs_forceconsistency does most of the work here
+    int err = lfs_fs_forceconsistency(lfs);
+    if (err) {
+        return err;
+    }
+
+    // do we have any pending gstate?
+    lfs_gstate_t delta = {0};
+    lfs_gstate_xor(&delta, &lfs->gdisk);
+    lfs_gstate_xor(&delta, &lfs->gstate);
+    if (!lfs_gstate_iszero(&delta)) {
+        // lfs_dir_commit will implicitly write out any pending gstate
+        lfs_mdir_t root;
+        err = lfs_dir_fetch(lfs, &root, lfs->root);
+        if (err) {
+            return err;
+        }
+
+        err = lfs_dir_commit(lfs, &root, NULL, 0);
+        if (err) {
+            return err;
+        }
+    }
+
+    return 0;
+}
+#endif
+
+static int lfs_fs_size_count(void *p, lfs_block_t block) {
+    (void)block;
+    lfs_size_t *size = p;
+    *size += 1;
+    return 0;
+}
+
+static lfs_ssize_t lfs_fs_size_(lfs_t *lfs) {
+    lfs_size_t size = 0;
+    int err = lfs_fs_traverse_(lfs, lfs_fs_size_count, &size, false);
+    if (err) {
+        return err;
+    }
+
+    return size;
+}
+
+// explicit garbage collection
+#ifndef LFS_READONLY
+static int lfs_fs_gc_(lfs_t *lfs) {
+    // force consistency, even if we're not necessarily going to write,
+    // because this function is supposed to take care of janitorial work
+    // isn't it?
+    int err = lfs_fs_forceconsistency(lfs);
+    if (err) {
+        return err;
+    }
+
+    // try to compact metadata pairs, note we can't really accomplish
+    // anything if compact_thresh doesn't at least leave a prog_size
+    // available
+    if (lfs->cfg->compact_thresh
+            < lfs->cfg->block_size - lfs->cfg->prog_size) {
+        // iterate over all mdirs
+        lfs_mdir_t mdir = {.tail = {0, 1}};
+        while (!lfs_pair_isnull(mdir.tail)) {
+            err = lfs_dir_fetch(lfs, &mdir, mdir.tail);
+            if (err) {
+                return err;
+            }
+
+            // not erased? exceeds our compaction threshold?
+            if (!mdir.erased || ((lfs->cfg->compact_thresh == 0)
+                    ? mdir.off > lfs->cfg->block_size - lfs->cfg->block_size/8
+                    : mdir.off > lfs->cfg->compact_thresh)) {
+                // the easiest way to trigger a compaction is to mark
+                // the mdir as unerased and add an empty commit
+                mdir.erased = false;
+                err = lfs_dir_commit(lfs, &mdir, NULL, 0);
+                if (err) {
+                    return err;
+                }
+            }
+        }
+    }
+
+    // try to populate the lookahead buffer, unless it's already full
+    if (lfs->lookahead.size < 8*lfs->cfg->lookahead_size) {
+        err = lfs_alloc_scan(lfs);
+        if (err) {
+            return err;
+        }
+    }
+
+    return 0;
+}
+#endif
+
+#ifndef LFS_READONLY
+#ifdef LFS_SHRINKNONRELOCATING
+static int lfs_shrink_checkblock(void *data, lfs_block_t block) {
+    lfs_size_t threshold = *((lfs_size_t*)data);
+    if (block >= threshold) {
+        return LFS_ERR_NOTEMPTY;
+    }
+    return 0;
+}
+#endif
+
+static int lfs_fs_grow_(lfs_t *lfs, lfs_size_t block_count) {
+    int err;
+
+    if (block_count == lfs->block_count) {
+        return 0;
+    }
+
+    
+#ifndef LFS_SHRINKNONRELOCATING
+    // shrinking is not supported
+    LFS_ASSERT(block_count >= lfs->block_count);
+#endif
+#ifdef LFS_SHRINKNONRELOCATING
+    if (block_count < lfs->block_count) {
+        err = lfs_fs_traverse_(lfs, lfs_shrink_checkblock, &block_count, true);
+        if (err) {
+            return err;
+        }
+    }
+#endif
+
+    lfs->block_count = block_count;
+
+    // fetch the root
+    lfs_mdir_t root;
+    err = lfs_dir_fetch(lfs, &root, lfs->root);
+    if (err) {
+        return err;
+    }
+
+    // update the superblock
+    lfs_superblock_t superblock;
+    lfs_stag_t tag = lfs_dir_get(lfs, &root, LFS_MKTAG(0x7ff, 0x3ff, 0),
+            LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),
+            &superblock);
+    if (tag < 0) {
+        return tag;
+    }
+    lfs_superblock_fromle32(&superblock);
+
+    superblock.block_count = lfs->block_count;
+
+    lfs_superblock_tole32(&superblock);
+    err = lfs_dir_commit(lfs, &root, LFS_MKATTRS(
+            {tag, &superblock}));
+    if (err) {
+        return err;
+    }
+    return 0;
+}
+#endif
+
+#ifdef LFS_MIGRATE
+////// Migration from littelfs v1 below this //////
+
+/// Version info ///
+
+// Software library version
+// Major (top-nibble), incremented on backwards incompatible changes
+// Minor (bottom-nibble), incremented on feature additions
+#define LFS1_VERSION 0x00010007
+#define LFS1_VERSION_MAJOR (0xffff & (LFS1_VERSION >> 16))
+#define LFS1_VERSION_MINOR (0xffff & (LFS1_VERSION >>  0))
+
+// Version of On-disk data structures
+// Major (top-nibble), incremented on backwards incompatible changes
+// Minor (bottom-nibble), incremented on feature additions
+#define LFS1_DISK_VERSION 0x00010001
+#define LFS1_DISK_VERSION_MAJOR (0xffff & (LFS1_DISK_VERSION >> 16))
+#define LFS1_DISK_VERSION_MINOR (0xffff & (LFS1_DISK_VERSION >>  0))
+
+
+/// v1 Definitions ///
+
+// File types
+enum lfs1_type {
+    LFS1_TYPE_REG        = 0x11,
+    LFS1_TYPE_DIR        = 0x22,
+    LFS1_TYPE_SUPERBLOCK = 0x2e,
+};
+
+typedef struct lfs1 {
+    lfs_block_t root[2];
+} lfs1_t;
+
+typedef struct lfs1_entry {
+    lfs_off_t off;
+
+    struct lfs1_disk_entry {
+        uint8_t type;
+        uint8_t elen;
+        uint8_t alen;
+        uint8_t nlen;
+        union {
+            struct {
+                lfs_block_t head;
+                lfs_size_t size;
+            } file;
+            lfs_block_t dir[2];
+        } u;
+    } d;
+} lfs1_entry_t;
+
+typedef struct lfs1_dir {
+    struct lfs1_dir *next;
+    lfs_block_t pair[2];
+    lfs_off_t off;
+
+    lfs_block_t head[2];
+    lfs_off_t pos;
+
+    struct lfs1_disk_dir {
+        uint32_t rev;
+        lfs_size_t size;
+        lfs_block_t tail[2];
+    } d;
+} lfs1_dir_t;
+
+typedef struct lfs1_superblock {
+    lfs_off_t off;
+
+    struct lfs1_disk_superblock {
+        uint8_t type;
+        uint8_t elen;
+        uint8_t alen;
+        uint8_t nlen;
+        lfs_block_t root[2];
+        uint32_t block_size;
+        uint32_t block_count;
+        uint32_t version;
+        char magic[8];
+    } d;
+} lfs1_superblock_t;
+
+
+/// Low-level wrappers v1->v2 ///
+static void lfs1_crc(uint32_t *crc, const void *buffer, size_t size) {
+    *crc = lfs_crc(*crc, buffer, size);
+}
+
+static int lfs1_bd_read(lfs_t *lfs, lfs_block_t block,
+        lfs_off_t off, void *buffer, lfs_size_t size) {
+    // if we ever do more than writes to alternating pairs,
+    // this may need to consider pcache
+    return lfs_bd_read(lfs, &lfs->pcache, &lfs->rcache, size,
+            block, off, buffer, size);
+}
+
+static int lfs1_bd_crc(lfs_t *lfs, lfs_block_t block,
+        lfs_off_t off, lfs_size_t size, uint32_t *crc) {
+    for (lfs_off_t i = 0; i < size; i++) {
+        uint8_t c;
+        int err = lfs1_bd_read(lfs, block, off+i, &c, 1);
+        if (err) {
+            return err;
+        }
+
+        lfs1_crc(crc, &c, 1);
+    }
+
+    return 0;
+}
+
+
+/// Endian swapping functions ///
+static void lfs1_dir_fromle32(struct lfs1_disk_dir *d) {
+    d->rev     = lfs_fromle32(d->rev);
+    d->size    = lfs_fromle32(d->size);
+    d->tail[0] = lfs_fromle32(d->tail[0]);
+    d->tail[1] = lfs_fromle32(d->tail[1]);
+}
+
+static void lfs1_dir_tole32(struct lfs1_disk_dir *d) {
+    d->rev     = lfs_tole32(d->rev);
+    d->size    = lfs_tole32(d->size);
+    d->tail[0] = lfs_tole32(d->tail[0]);
+    d->tail[1] = lfs_tole32(d->tail[1]);
+}
+
+static void lfs1_entry_fromle32(struct lfs1_disk_entry *d) {
+    d->u.dir[0] = lfs_fromle32(d->u.dir[0]);
+    d->u.dir[1] = lfs_fromle32(d->u.dir[1]);
+}
+
+static void lfs1_entry_tole32(struct lfs1_disk_entry *d) {
+    d->u.dir[0] = lfs_tole32(d->u.dir[0]);
+    d->u.dir[1] = lfs_tole32(d->u.dir[1]);
+}
+
+static void lfs1_superblock_fromle32(struct lfs1_disk_superblock *d) {
+    d->root[0]     = lfs_fromle32(d->root[0]);
+    d->root[1]     = lfs_fromle32(d->root[1]);
+    d->block_size  = lfs_fromle32(d->block_size);
+    d->block_count = lfs_fromle32(d->block_count);
+    d->version     = lfs_fromle32(d->version);
+}
+
+
+///// Metadata pair and directory operations ///
+static inline lfs_size_t lfs1_entry_size(const lfs1_entry_t *entry) {
+    return 4 + entry->d.elen + entry->d.alen + entry->d.nlen;
+}
+
+static int lfs1_dir_fetch(lfs_t *lfs,
+        lfs1_dir_t *dir, const lfs_block_t pair[2]) {
+    // copy out pair, otherwise may be aliasing dir
+    const lfs_block_t tpair[2] = {pair[0], pair[1]};
+    bool valid = false;
+
+    // check both blocks for the most recent revision
+    for (int i = 0; i < 2; i++) {
+        struct lfs1_disk_dir test;
+        int err = lfs1_bd_read(lfs, tpair[i], 0, &test, sizeof(test));
+        lfs1_dir_fromle32(&test);
+        if (err) {
+            if (err == LFS_ERR_CORRUPT) {
+                continue;
+            }
+            return err;
+        }
+
+        if (valid && lfs_scmp(test.rev, dir->d.rev) < 0) {
+            continue;
+        }
+
+        if ((0x7fffffff & test.size) < sizeof(test)+4 ||
+            (0x7fffffff & test.size) > lfs->cfg->block_size) {
+            continue;
+        }
+
+        uint32_t crc = 0xffffffff;
+        lfs1_dir_tole32(&test);
+        lfs1_crc(&crc, &test, sizeof(test));
+        lfs1_dir_fromle32(&test);
+        err = lfs1_bd_crc(lfs, tpair[i], sizeof(test),
+                (0x7fffffff & test.size) - sizeof(test), &crc);
+        if (err) {
+            if (err == LFS_ERR_CORRUPT) {
+                continue;
+            }
+            return err;
+        }
+
+        if (crc != 0) {
+            continue;
+        }
+
+        valid = true;
+
+        // setup dir in case it's valid
+        dir->pair[0] = tpair[(i+0) % 2];
+        dir->pair[1] = tpair[(i+1) % 2];
+        dir->off = sizeof(dir->d);
+        dir->d = test;
+    }
+
+    if (!valid) {
+        LFS_ERROR("Corrupted dir pair at {0x%"PRIx32", 0x%"PRIx32"}",
+                tpair[0], tpair[1]);
+        return LFS_ERR_CORRUPT;
+    }
+
+    return 0;
+}
+
+static int lfs1_dir_next(lfs_t *lfs, lfs1_dir_t *dir, lfs1_entry_t *entry) {
+    while (dir->off + sizeof(entry->d) > (0x7fffffff & dir->d.size)-4) {
+        if (!(0x80000000 & dir->d.size)) {
+            entry->off = dir->off;
+            return LFS_ERR_NOENT;
+        }
+
+        int err = lfs1_dir_fetch(lfs, dir, dir->d.tail);
+        if (err) {
+            return err;
+        }
+
+        dir->off = sizeof(dir->d);
+        dir->pos += sizeof(dir->d) + 4;
+    }
+
+    int err = lfs1_bd_read(lfs, dir->pair[0], dir->off,
+            &entry->d, sizeof(entry->d));
+    lfs1_entry_fromle32(&entry->d);
+    if (err) {
+        return err;
+    }
+
+    entry->off = dir->off;
+    dir->off += lfs1_entry_size(entry);
+    dir->pos += lfs1_entry_size(entry);
+    return 0;
+}
+
+/// littlefs v1 specific operations ///
+int lfs1_traverse(lfs_t *lfs, int (*cb)(void*, lfs_block_t), void *data) {
+    if (lfs_pair_isnull(lfs->lfs1->root)) {
+        return 0;
+    }
+
+    // iterate over metadata pairs
+    lfs1_dir_t dir;
+    lfs1_entry_t entry;
+    lfs_block_t cwd[2] = {0, 1};
+
+    while (true) {
+        for (int i = 0; i < 2; i++) {
+            int err = cb(data, cwd[i]);
+            if (err) {
+                return err;
+            }
+        }
+
+        int err = lfs1_dir_fetch(lfs, &dir, cwd);
+        if (err) {
+            return err;
+        }
+
+        // iterate over contents
+        while (dir.off + sizeof(entry.d) <= (0x7fffffff & dir.d.size)-4) {
+            err = lfs1_bd_read(lfs, dir.pair[0], dir.off,
+                    &entry.d, sizeof(entry.d));
+            lfs1_entry_fromle32(&entry.d);
+            if (err) {
+                return err;
+            }
+
+            dir.off += lfs1_entry_size(&entry);
+            if ((0x70 & entry.d.type) == (0x70 & LFS1_TYPE_REG)) {
+                err = lfs_ctz_traverse(lfs, NULL, &lfs->rcache,
+                        entry.d.u.file.head, entry.d.u.file.size, cb, data);
+                if (err) {
+                    return err;
+                }
+            }
+        }
+
+        // we also need to check if we contain a threaded v2 directory
+        lfs_mdir_t dir2 = {.split=true, .tail={cwd[0], cwd[1]}};
+        while (dir2.split) {
+            err = lfs_dir_fetch(lfs, &dir2, dir2.tail);
+            if (err) {
+                break;
+            }
+
+            for (int i = 0; i < 2; i++) {
+                err = cb(data, dir2.pair[i]);
+                if (err) {
+                    return err;
+                }
+            }
+        }
+
+        cwd[0] = dir.d.tail[0];
+        cwd[1] = dir.d.tail[1];
+
+        if (lfs_pair_isnull(cwd)) {
+            break;
+        }
     }
 
-    // update internally tracked dirs
-    for (struct lfs_mlist* d = lfs.mlist; d; d = d->next) {
-        if (lfs_pair_cmp(oldpair, d->m.pair) == 0) {
-            d->m.pair[0] = newpair[0];
-            d->m.pair[1] = newpair[1];
-        }
+    return 0;
+}
 
-        if (d->type == LFS_TYPE_DIR &&
-                lfs_pair_cmp(oldpair, ((lfs_dir_t*)d)->head) == 0) {
-            ((lfs_dir_t*)d)->head[0] = newpair[0];
-            ((lfs_dir_t*)d)->head[1] = newpair[1];
-        }
+static int lfs1_moved(lfs_t *lfs, const void *e) {
+    if (lfs_pair_isnull(lfs->lfs1->root)) {
+        return 0;
     }
 
-    // find parent
-    lfs_mdir_t parent;
-    lfs_stag_t tag = lfs_fs_parent(oldpair, &parent);
-    if (tag < 0 && tag != LFS_ERR_NOENT) {
-        return tag;
+    // skip superblock
+    lfs1_dir_t cwd;
+    int err = lfs1_dir_fetch(lfs, &cwd, (const lfs_block_t[2]){0, 1});
+    if (err) {
+        return err;
     }
 
-    if (tag != LFS_ERR_NOENT) {
-        // update disk, this creates a desync
-        int err = lfs_fs_preporphans(+1);
+    // iterate over all directory directory entries
+    lfs1_entry_t entry;
+    while (!lfs_pair_isnull(cwd.d.tail)) {
+        err = lfs1_dir_fetch(lfs, &cwd, cwd.d.tail);
         if (err) {
             return err;
         }
 
-        // fix pending move in this pair? this looks like an optimization but
-        // is in fact _required_ since relocating may outdate the move.
-        uint16_t moveid = 0x3ff;
-        if (lfs_gstate_hasmovehere(&lfs.gstate, parent.pair)) {
-            moveid = lfs_tag_id(lfs.gstate.tag);
-            LFS_DEBUG("Fixing move while relocating "
-                    "{0x%"PRIx32", 0x%"PRIx32"} 0x%"PRIx16"\n",
-                    parent.pair[0], parent.pair[1], moveid);
-            lfs_fs_prepmove(0x3ff, NULL);
-            if (moveid < lfs_tag_id(tag)) {
-                tag -= LFS_MKTAG(0, 1, 0);
+        while (true) {
+            err = lfs1_dir_next(lfs, &cwd, &entry);
+            if (err && err != LFS_ERR_NOENT) {
+                return err;
+            }
+
+            if (err == LFS_ERR_NOENT) {
+                break;
+            }
+
+            if (!(0x80 & entry.d.type) &&
+                 memcmp(&entry.d.u, e, sizeof(entry.d.u)) == 0) {
+                return true;
             }
         }
+    }
+
+    return false;
+}
 
-        lfs_pair_tole32(newpair);
-        err = lfs_dir_commit(
-            &parent, LFS_MKATTRS({LFS_MKTAG_IF(moveid != 0x3ff, LFS_TYPE_DELETE, moveid, 0), NULL},
-                                 {tag, newpair}));
-        lfs_pair_fromle32(newpair);
+/// Filesystem operations ///
+static int lfs1_mount(lfs_t *lfs, struct lfs1 *lfs1,
+        const struct lfs_config *cfg) {
+    int err = 0;
+    {
+        err = lfs_init(lfs, cfg);
         if (err) {
             return err;
         }
 
-        // next step, clean up orphans
-        err = lfs_fs_preporphans(-1);
-        if (err) {
-            return err;
+        lfs->lfs1 = lfs1;
+        lfs->lfs1->root[0] = LFS_BLOCK_NULL;
+        lfs->lfs1->root[1] = LFS_BLOCK_NULL;
+
+        // setup free lookahead
+        lfs->lookahead.start = 0;
+        lfs->lookahead.size = 0;
+        lfs->lookahead.next = 0;
+        lfs_alloc_ckpoint(lfs);
+
+        // load superblock
+        lfs1_dir_t dir;
+        lfs1_superblock_t superblock;
+        err = lfs1_dir_fetch(lfs, &dir, (const lfs_block_t[2]){0, 1});
+        if (err && err != LFS_ERR_CORRUPT) {
+            goto cleanup;
         }
-    }
 
-    // find pred
-    int err = lfs_fs_pred(oldpair, &parent);
-    if (err && err != LFS_ERR_NOENT) {
-        return err;
-    }
+        if (!err) {
+            err = lfs1_bd_read(lfs, dir.pair[0], sizeof(dir.d),
+                    &superblock.d, sizeof(superblock.d));
+            lfs1_superblock_fromle32(&superblock.d);
+            if (err) {
+                goto cleanup;
+            }
 
-    // if we can't find dir, it must be new
-    if (err != LFS_ERR_NOENT) {
-        // fix pending move in this pair? this looks like an optimization but
-        // is in fact _required_ since relocating may outdate the move.
-        uint16_t moveid = 0x3ff;
-        if (lfs_gstate_hasmovehere(&lfs.gstate, parent.pair)) {
-            moveid = lfs_tag_id(lfs.gstate.tag);
-            LFS_DEBUG("Fixing move while relocating "
-                    "{0x%"PRIx32", 0x%"PRIx32"} 0x%"PRIx16"\n",
-                    parent.pair[0], parent.pair[1], moveid);
-            lfs_fs_prepmove(0x3ff, NULL);
-        }
-
-        // replace bad pair, either we clean up desync, or no desync occured
-        lfs_pair_tole32(newpair);
-        err = lfs_dir_commit(
-            &parent, LFS_MKATTRS({LFS_MKTAG_IF(moveid != 0x3ff, LFS_TYPE_DELETE, moveid, 0), NULL},
-                                 {LFS_MKTAG(LFS_TYPE_TAIL + parent.split, 0x3ff, 8), newpair}));
-        lfs_pair_fromle32(newpair);
-        if (err) {
-            return err;
+            lfs->lfs1->root[0] = superblock.d.root[0];
+            lfs->lfs1->root[1] = superblock.d.root[1];
         }
-    }
 
-    return LFS_ERR_OK;
-}
-#endif
+        if (err || memcmp(superblock.d.magic, "littlefs", 8) != 0) {
+            LFS_ERROR("Invalid superblock at {0x%"PRIx32", 0x%"PRIx32"}",
+                    0, 1);
+            err = LFS_ERR_CORRUPT;
+            goto cleanup;
+        }
 
-#ifndef LFS_READONLY
-static int lfs_fs_preporphans(int8_t orphans) {
-    LFS_ASSERT(lfs_tag_size(lfs.gstate.tag) > 0 || orphans >= 0);
-    lfs.gstate.tag += orphans;
-    lfs.gstate.tag = ((lfs.gstate.tag & ~LFS_MKTAG(0x800, 0, 0)) |
-                      ((uint32_t)lfs_gstate_hasorphans(&lfs.gstate) << 31));
+        uint16_t major_version = (0xffff & (superblock.d.version >> 16));
+        uint16_t minor_version = (0xffff & (superblock.d.version >>  0));
+        if ((major_version != LFS1_DISK_VERSION_MAJOR ||
+             minor_version > LFS1_DISK_VERSION_MINOR)) {
+            LFS_ERROR("Invalid version v%d.%d", major_version, minor_version);
+            err = LFS_ERR_INVAL;
+            goto cleanup;
+        }
 
-    return LFS_ERR_OK;
+        return 0;
+    }
+
+cleanup:
+    lfs_deinit(lfs);
+    return err;
 }
-#endif
 
-#ifndef LFS_READONLY
-static void lfs_fs_prepmove(uint16_t id, const lfs_block_t pair[2]) {
-    lfs.gstate.tag = ((lfs.gstate.tag & ~LFS_MKTAG(0x7ff, 0x3ff, 0)) |
-                      ((id != 0x3ff) ? LFS_MKTAG(LFS_TYPE_DELETE, id, 0) : 0));
-    lfs.gstate.pair[0] = (id != 0x3ff) ? pair[0] : 0;
-    lfs.gstate.pair[1] = (id != 0x3ff) ? pair[1] : 0;
+static int lfs1_unmount(lfs_t *lfs) {
+    return lfs_deinit(lfs);
 }
-#endif
 
-#ifndef LFS_READONLY
-static int lfs_fs_demove(void) {
-    if (!lfs_gstate_hasmove(&lfs.gdisk)) {
-        return LFS_ERR_OK;
-    }
+/// v1 migration ///
+static int lfs_migrate_(lfs_t *lfs, const struct lfs_config *cfg) {
+    struct lfs1 lfs1;
 
-    // Fix bad moves
-    LFS_DEBUG("Fixing move {0x%" PRIx32 ", 0x%" PRIx32 "} 0x%" PRIx16, lfs.gdisk.pair[0],
-              lfs.gdisk.pair[1], lfs_tag_id(lfs.gdisk.tag));
+    // Indeterminate filesystem size not allowed for migration.
+    LFS_ASSERT(cfg->block_count != 0);
 
-    // fetch and delete the moved entry
-    lfs_mdir_t movedir;
-    int err = lfs_dir_fetch(&movedir, lfs.gdisk.pair);
+    int err = lfs1_mount(lfs, &lfs1, cfg);
     if (err) {
         return err;
     }
 
-    // prep gstate and delete move id
-    uint16_t moveid = lfs_tag_id(lfs.gdisk.tag);
-    lfs_fs_prepmove(0x3ff, NULL);
-    err = lfs_dir_commit(&movedir, LFS_MKATTRS({LFS_MKTAG(LFS_TYPE_DELETE, moveid, 0), NULL}));
-    if (err) {
-        return err;
-    }
+    {
+        // iterate through each directory, copying over entries
+        // into new directory
+        lfs1_dir_t dir1;
+        lfs_mdir_t dir2;
+        dir1.d.tail[0] = lfs->lfs1->root[0];
+        dir1.d.tail[1] = lfs->lfs1->root[1];
+        while (!lfs_pair_isnull(dir1.d.tail)) {
+            // iterate old dir
+            err = lfs1_dir_fetch(lfs, &dir1, dir1.d.tail);
+            if (err) {
+                goto cleanup;
+            }
 
-    return LFS_ERR_OK;
-}
-#endif
+            // create new dir and bind as temporary pretend root
+            err = lfs_dir_alloc(lfs, &dir2);
+            if (err) {
+                goto cleanup;
+            }
 
-#ifndef LFS_READONLY
-static int lfs_fs_deorphan(void) {
-    if (!lfs_gstate_hasorphans(&lfs.gstate)) {
-        return LFS_ERR_OK;
-    }
+            dir2.rev = dir1.d.rev;
+            dir1.head[0] = dir1.pair[0];
+            dir1.head[1] = dir1.pair[1];
+            lfs->root[0] = dir2.pair[0];
+            lfs->root[1] = dir2.pair[1];
 
-    // Fix any orphans
-    lfs_mdir_t pdir = {.split = true, .tail = {0, 1}};
-    lfs_mdir_t dir;
+            err = lfs_dir_commit(lfs, &dir2, NULL, 0);
+            if (err) {
+                goto cleanup;
+            }
 
-    // iterate over all directory directory entries
-    while (!lfs_pair_isnull(pdir.tail)) {
-        int err = lfs_dir_fetch(&dir, pdir.tail);
-        if (err) {
-            return err;
-        }
+            while (true) {
+                lfs1_entry_t entry1;
+                err = lfs1_dir_next(lfs, &dir1, &entry1);
+                if (err && err != LFS_ERR_NOENT) {
+                    goto cleanup;
+                }
 
-        // check head blocks for orphans
-        if (!pdir.split) {
-            // check if we have a parent
-            lfs_mdir_t parent;
-            lfs_stag_t tag = lfs_fs_parent(pdir.tail, &parent);
-            if (tag < 0 && tag != LFS_ERR_NOENT) {
-                return tag;
+                if (err == LFS_ERR_NOENT) {
+                    break;
+                }
+
+                // check that entry has not been moved
+                if (entry1.d.type & 0x80) {
+                    int moved = lfs1_moved(lfs, &entry1.d.u);
+                    if (moved < 0) {
+                        err = moved;
+                        goto cleanup;
+                    }
+
+                    if (moved) {
+                        continue;
+                    }
+
+                    entry1.d.type &= ~0x80;
+                }
+
+                // also fetch name
+                char name[LFS_NAME_MAX+1];
+                memset(name, 0, sizeof(name));
+                err = lfs1_bd_read(lfs, dir1.pair[0],
+                        entry1.off + 4+entry1.d.elen+entry1.d.alen,
+                        name, entry1.d.nlen);
+                if (err) {
+                    goto cleanup;
+                }
+
+                bool isdir = (entry1.d.type == LFS1_TYPE_DIR);
+
+                // create entry in new dir
+                err = lfs_dir_fetch(lfs, &dir2, lfs->root);
+                if (err) {
+                    goto cleanup;
+                }
+
+                uint16_t id;
+                err = lfs_dir_find(lfs, &dir2, &(const char*){name}, &id);
+                if (!(err == LFS_ERR_NOENT && id != 0x3ff)) {
+                    err = (err < 0) ? err : LFS_ERR_EXIST;
+                    goto cleanup;
+                }
+
+                lfs1_entry_tole32(&entry1.d);
+                err = lfs_dir_commit(lfs, &dir2, LFS_MKATTRS(
+                        {LFS_MKTAG(LFS_TYPE_CREATE, id, 0), NULL},
+                        {LFS_MKTAG_IF_ELSE(isdir,
+                            LFS_TYPE_DIR, id, entry1.d.nlen,
+                            LFS_TYPE_REG, id, entry1.d.nlen),
+                                name},
+                        {LFS_MKTAG_IF_ELSE(isdir,
+                            LFS_TYPE_DIRSTRUCT, id, sizeof(entry1.d.u),
+                            LFS_TYPE_CTZSTRUCT, id, sizeof(entry1.d.u)),
+                                &entry1.d.u}));
+                lfs1_entry_fromle32(&entry1.d);
+                if (err) {
+                    goto cleanup;
+                }
             }
 
-            if (tag == LFS_ERR_NOENT) {
-                // we are an orphan
-                LFS_DEBUG("Fixing orphan {0x%"PRIx32", 0x%"PRIx32"}",
-                        pdir.tail[0], pdir.tail[1]);
+            if (!lfs_pair_isnull(dir1.d.tail)) {
+                // find last block and update tail to thread into fs
+                err = lfs_dir_fetch(lfs, &dir2, lfs->root);
+                if (err) {
+                    goto cleanup;
+                }
+
+                while (dir2.split) {
+                    err = lfs_dir_fetch(lfs, &dir2, dir2.tail);
+                    if (err) {
+                        goto cleanup;
+                    }
+                }
 
-                err = lfs_dir_drop(&pdir, &dir);
+                lfs_pair_tole32(dir2.pair);
+                err = lfs_dir_commit(lfs, &dir2, LFS_MKATTRS(
+                        {LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), dir1.d.tail}));
+                lfs_pair_fromle32(dir2.pair);
                 if (err) {
-                    return err;
+                    goto cleanup;
                 }
+            }
 
-                // refetch tail
-                continue;
+            // Copy over first block to thread into fs. Unfortunately
+            // if this fails there is not much we can do.
+            LFS_DEBUG("Migrating {0x%"PRIx32", 0x%"PRIx32"} "
+                        "-> {0x%"PRIx32", 0x%"PRIx32"}",
+                    lfs->root[0], lfs->root[1], dir1.head[0], dir1.head[1]);
+
+            err = lfs_bd_erase(lfs, dir1.head[1]);
+            if (err) {
+                goto cleanup;
             }
 
-            lfs_block_t pair[2];
-            lfs_stag_t res = lfs_dir_get(&parent, LFS_MKTAG(0x7ff, 0x3ff, 0), tag, pair);
-            if (res < 0) {
-                return res;
+            err = lfs_dir_fetch(lfs, &dir2, lfs->root);
+            if (err) {
+                goto cleanup;
             }
-            lfs_pair_fromle32(pair);
 
-            if (!lfs_pair_sync(pair, pdir.tail)) {
-                // we have desynced
-                LFS_DEBUG("Fixing half-orphan {0x%"PRIx32", 0x%"PRIx32"} "
-                            "-> {0x%"PRIx32", 0x%"PRIx32"}",
-                        pdir.tail[0], pdir.tail[1], pair[0], pair[1]);
+            for (lfs_off_t i = 0; i < dir2.off; i++) {
+                uint8_t dat;
+                err = lfs_bd_read(lfs,
+                        NULL, &lfs->rcache, dir2.off,
+                        dir2.pair[0], i, &dat, 1);
+                if (err) {
+                    goto cleanup;
+                }
 
-                lfs_pair_tole32(pair);
-                err = lfs_dir_commit(&pdir,
-                                     LFS_MKATTRS({LFS_MKTAG(LFS_TYPE_SOFTTAIL, 0x3ff, 8), pair}));
-                lfs_pair_fromle32(pair);
+                err = lfs_bd_prog(lfs,
+                        &lfs->pcache, &lfs->rcache, true,
+                        dir1.head[1], i, &dat, 1);
                 if (err) {
-                    return err;
+                    goto cleanup;
                 }
+            }
 
-                // refetch tail
-                continue;
+            err = lfs_bd_flush(lfs, &lfs->pcache, &lfs->rcache, true);
+            if (err) {
+                goto cleanup;
             }
         }
 
-        pdir = dir;
-    }
+        // Create new superblock. This marks a successful migration!
+        err = lfs1_dir_fetch(lfs, &dir1, (const lfs_block_t[2]){0, 1});
+        if (err) {
+            goto cleanup;
+        }
 
-    // mark orphans as fixed
-    return lfs_fs_preporphans(-lfs_gstate_getorphans(&lfs.gstate));
-}
-#endif
+        dir2.pair[0] = dir1.pair[0];
+        dir2.pair[1] = dir1.pair[1];
+        dir2.rev = dir1.d.rev;
+        dir2.off = sizeof(dir2.rev);
+        dir2.etag = 0xffffffff;
+        dir2.count = 0;
+        dir2.tail[0] = lfs->lfs1->root[0];
+        dir2.tail[1] = lfs->lfs1->root[1];
+        dir2.erased = false;
+        dir2.split = true;
+
+        lfs_superblock_t superblock = {
+            .version     = LFS_DISK_VERSION,
+            .block_size  = lfs->cfg->block_size,
+            .block_count = lfs->cfg->block_count,
+            .name_max    = lfs->name_max,
+            .file_max    = lfs->file_max,
+            .attr_max    = lfs->attr_max,
+        };
 
-#ifndef LFS_READONLY
-static int lfs_fs_forceconsistency(void) {
-    int err = lfs_fs_demove();
-    if (err) {
-        return err;
-    }
+        lfs_superblock_tole32(&superblock);
+        err = lfs_dir_commit(lfs, &dir2, LFS_MKATTRS(
+                {LFS_MKTAG(LFS_TYPE_CREATE, 0, 0), NULL},
+                {LFS_MKTAG(LFS_TYPE_SUPERBLOCK, 0, 8), "littlefs"},
+                {LFS_MKTAG(LFS_TYPE_INLINESTRUCT, 0, sizeof(superblock)),
+                    &superblock}));
+        if (err) {
+            goto cleanup;
+        }
 
-    err = lfs_fs_deorphan();
-    if (err) {
-        return err;
-    }
+        // sanity check that fetch works
+        err = lfs_dir_fetch(lfs, &dir2, (const lfs_block_t[2]){0, 1});
+        if (err) {
+            goto cleanup;
+        }
 
-    return LFS_ERR_OK;
-}
-#endif
+        // force compaction to prevent accidentally mounting v1
+        dir2.erased = false;
+        err = lfs_dir_commit(lfs, &dir2, NULL, 0);
+        if (err) {
+            goto cleanup;
+        }
+    }
 
-static int lfs_fs_size_count(void *p, lfs_block_t block) {
-    (void)block;
-    lfs_size_t *size = p;
-    *size += 1;
-    return LFS_ERR_OK;
+cleanup:
+    lfs1_unmount(lfs);
+    return err;
 }
 
-static lfs_ssize_t lfs_fs_rawsize(void) {
-    lfs_size_t size = 0;
-    int err = lfs_fs_rawtraverse(lfs_fs_size_count, &size, false);
-    if (err) {
-        return err;
-    }
+#endif
 
-    return size;
-}
 
 /// Public API wrappers ///
 
 // Here we can add tracing/thread safety easily
 
+// Thread-safe wrappers if enabled
+#ifdef LFS_THREADSAFE
+#define LFS_LOCK(cfg)   cfg->lock(cfg)
+#define LFS_UNLOCK(cfg) cfg->unlock(cfg)
+#else
+#define LFS_LOCK(cfg)   ((void)cfg, 0)
+#define LFS_UNLOCK(cfg) ((void)cfg)
+#endif
+
 // Public API
 #ifndef LFS_READONLY
-int lfs_format(const struct lfs_config* cfg) {
+int lfs_format(lfs_t *lfs, const struct lfs_config *cfg) {
+    int err = LFS_LOCK(cfg);
+    if (err) {
+        return err;
+    }
     LFS_TRACE("lfs_format(%p, %p {.context=%p, "
                 ".read=%p, .prog=%p, .erase=%p, .sync=%p, "
                 ".read_size=%"PRIu32", .prog_size=%"PRIu32", "
                 ".block_size=%"PRIu32", .block_count=%"PRIu32", "
-                ".block_cycles=%"PRIu32", .cache_size=%"PRIu32", "
+                ".block_cycles=%"PRId32", .cache_size=%"PRIu32", "
                 ".lookahead_size=%"PRIu32", .read_buffer=%p, "
                 ".prog_buffer=%p, .lookahead_buffer=%p, "
                 ".name_max=%"PRIu32", .file_max=%"PRIu32", "
@@ -4057,19 +5987,24 @@ int lfs_format(const struct lfs_config* cfg) {
             cfg->read_buffer, cfg->prog_buffer, cfg->lookahead_buffer,
             cfg->name_max, cfg->file_max, cfg->attr_max);
 
-    int err = lfs_rawformat(cfg);
+    err = lfs_format_(lfs, cfg);
 
     LFS_TRACE("lfs_format -> %d", err);
+    LFS_UNLOCK(cfg);
     return err;
 }
 #endif
 
-int lfs_mount(const struct lfs_config* cfg) {
+int lfs_mount(lfs_t *lfs, const struct lfs_config *cfg) {
+    int err = LFS_LOCK(cfg);
+    if (err) {
+        return err;
+    }
     LFS_TRACE("lfs_mount(%p, %p {.context=%p, "
                 ".read=%p, .prog=%p, .erase=%p, .sync=%p, "
                 ".read_size=%"PRIu32", .prog_size=%"PRIu32", "
                 ".block_size=%"PRIu32", .block_count=%"PRIu32", "
-                ".block_cycles=%"PRIu32", .cache_size=%"PRIu32", "
+                ".block_cycles=%"PRId32", .cache_size=%"PRIu32", "
                 ".lookahead_size=%"PRIu32", .read_buffer=%p, "
                 ".prog_buffer=%p, .lookahead_buffer=%p, "
                 ".name_max=%"PRIu32", .file_max=%"PRIu32", "
@@ -4082,438 +6017,530 @@ int lfs_mount(const struct lfs_config* cfg) {
             cfg->read_buffer, cfg->prog_buffer, cfg->lookahead_buffer,
             cfg->name_max, cfg->file_max, cfg->attr_max);
 
-    int err = lfs_rawmount(cfg);
+    err = lfs_mount_(lfs, cfg);
 
     LFS_TRACE("lfs_mount -> %d", err);
+    LFS_UNLOCK(cfg);
     return err;
 }
 
-int lfs_unmount(void) {
+int lfs_unmount(lfs_t *lfs) {
+    int err = LFS_LOCK(lfs->cfg);
+    if (err) {
+        return err;
+    }
     LFS_TRACE("lfs_unmount(%p)", (void*)lfs);
-    int err = lfs_rawunmount();
+
+    err = lfs_unmount_(lfs);
+
     LFS_TRACE("lfs_unmount -> %d", err);
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 
 #ifndef LFS_READONLY
-int lfs_remove(const char* path) {
-    int err = LFS_LOCK;
+int lfs_remove(lfs_t *lfs, const char *path) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_remove(%p, \"%s\")", (void*)lfs, path);
 
-    err = lfs_rawremove(path);
+    err = lfs_remove_(lfs, path);
 
     LFS_TRACE("lfs_remove -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 #endif
 
 #ifndef LFS_READONLY
-int lfs_rename(const char* oldpath, const char* newpath) {
-    int err = LFS_LOCK;
+int lfs_rename(lfs_t *lfs, const char *oldpath, const char *newpath) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_rename(%p, \"%s\", \"%s\")", (void*)lfs, oldpath, newpath);
 
-    err = lfs_rawrename(oldpath, newpath);
+    err = lfs_rename_(lfs, oldpath, newpath);
 
     LFS_TRACE("lfs_rename -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 #endif
 
-int lfs_stat(const char* path, struct lfs_info* info) {
-    int err = LFS_LOCK;
+int lfs_stat(lfs_t *lfs, const char *path, struct lfs_info *info) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_stat(%p, \"%s\", %p)", (void*)lfs, path, (void*)info);
 
-    err = lfs_rawstat(path, info);
+    err = lfs_stat_(lfs, path, info);
 
     LFS_TRACE("lfs_stat -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 
-lfs_ssize_t lfs_getattr(const char* path, uint8_t type, void* buffer, lfs_size_t size) {
-    int err = LFS_LOCK;
+lfs_ssize_t lfs_getattr(lfs_t *lfs, const char *path,
+        uint8_t type, void *buffer, lfs_size_t size) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_getattr(%p, \"%s\", %"PRIu8", %p, %"PRIu32")",
             (void*)lfs, path, type, buffer, size);
 
-    lfs_ssize_t res = lfs_rawgetattr(path, type, buffer, size);
+    lfs_ssize_t res = lfs_getattr_(lfs, path, type, buffer, size);
 
     LFS_TRACE("lfs_getattr -> %"PRId32, res);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return res;
 }
 
 #ifndef LFS_READONLY
-int lfs_setattr(const char* path, uint8_t type, const void* buffer, lfs_size_t size) {
-    int err = LFS_LOCK;
+int lfs_setattr(lfs_t *lfs, const char *path,
+        uint8_t type, const void *buffer, lfs_size_t size) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_setattr(%p, \"%s\", %"PRIu8", %p, %"PRIu32")",
             (void*)lfs, path, type, buffer, size);
 
-    err = lfs_rawsetattr(path, type, buffer, size);
+    err = lfs_setattr_(lfs, path, type, buffer, size);
 
     LFS_TRACE("lfs_setattr -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 #endif
 
 #ifndef LFS_READONLY
-int lfs_removeattr(const char* path, uint8_t type) {
-    int err = LFS_LOCK;
+int lfs_removeattr(lfs_t *lfs, const char *path, uint8_t type) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_removeattr(%p, \"%s\", %"PRIu8")", (void*)lfs, path, type);
 
-    err = lfs_rawremoveattr(path, type);
+    err = lfs_removeattr_(lfs, path, type);
 
     LFS_TRACE("lfs_removeattr -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 #endif
 
-int lfs_file_open(lfs_file_t* file, const char* path, int flags) {
-    int err = LFS_LOCK;
+#ifndef LFS_NO_MALLOC
+int lfs_file_open(lfs_t *lfs, lfs_file_t *file, const char *path, int flags) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_file_open(%p, %p, \"%s\", %x)",
-            (void*)lfs, (void*)file, path, flags);
-    LFS_ASSERT(!lfs_mlist_isopen(lfs.mlist, (struct lfs_mlist*)file));
+            (void*)lfs, (void*)file, path, (unsigned)flags);
+    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));
 
-    err = lfs_file_rawopen(file, path, flags);
+    err = lfs_file_open_(lfs, file, path, flags);
 
     LFS_TRACE("lfs_file_open -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
+#endif
 
-int lfs_file_opencfg(lfs_file_t* file, const char* path, int flags,
-                     const struct lfs_file_config* cfg) {
-    int err = LFS_LOCK;
+int lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,
+        const char *path, int flags,
+        const struct lfs_file_config *cfg) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_file_opencfg(%p, %p, \"%s\", %x, %p {"
                  ".buffer=%p, .attrs=%p, .attr_count=%"PRIu32"})",
-            (void*)lfs, (void*)file, path, flags,
+            (void*)lfs, (void*)file, path, (unsigned)flags,
             (void*)cfg, cfg->buffer, (void*)cfg->attrs, cfg->attr_count);
-    LFS_ASSERT(!lfs_mlist_isopen(lfs.mlist, (struct lfs_mlist*)file));
+    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));
 
-    err = lfs_file_rawopencfg(file, path, flags, cfg);
+    err = lfs_file_opencfg_(lfs, file, path, flags, cfg);
 
     LFS_TRACE("lfs_file_opencfg -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 
-int lfs_file_close(lfs_file_t* file) {
-    int err = LFS_LOCK;
+int lfs_file_close(lfs_t *lfs, lfs_file_t *file) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_file_close(%p, %p)", (void*)lfs, (void*)file);
-    LFS_ASSERT(lfs_mlist_isopen(lfs.mlist, (struct lfs_mlist*)file));
+    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));
 
-    err = lfs_file_rawclose(file);
+    err = lfs_file_close_(lfs, file);
 
     LFS_TRACE("lfs_file_close -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 
 #ifndef LFS_READONLY
-int lfs_file_sync(lfs_file_t* file) {
-    int err = LFS_LOCK;
+int lfs_file_sync(lfs_t *lfs, lfs_file_t *file) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_file_sync(%p, %p)", (void*)lfs, (void*)file);
-    LFS_ASSERT(lfs_mlist_isopen(lfs.mlist, (struct lfs_mlist*)file));
+    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));
 
-    err = lfs_file_rawsync(file);
+    err = lfs_file_sync_(lfs, file);
 
     LFS_TRACE("lfs_file_sync -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 #endif
 
-lfs_ssize_t lfs_file_read(lfs_file_t* file, void* buffer, lfs_size_t size) {
-    int err = LFS_LOCK;
+lfs_ssize_t lfs_file_read(lfs_t *lfs, lfs_file_t *file,
+        void *buffer, lfs_size_t size) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_file_read(%p, %p, %p, %"PRIu32")",
             (void*)lfs, (void*)file, buffer, size);
-    LFS_ASSERT(lfs_mlist_isopen(lfs.mlist, (struct lfs_mlist*)file));
+    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));
 
-    lfs_ssize_t res = lfs_file_rawread(file, buffer, size);
+    lfs_ssize_t res = lfs_file_read_(lfs, file, buffer, size);
 
     LFS_TRACE("lfs_file_read -> %"PRId32, res);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return res;
 }
 
 #ifndef LFS_READONLY
-lfs_ssize_t lfs_file_write(lfs_file_t* file, const void* buffer, lfs_size_t size) {
-    int err = LFS_LOCK;
+lfs_ssize_t lfs_file_write(lfs_t *lfs, lfs_file_t *file,
+        const void *buffer, lfs_size_t size) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_file_write(%p, %p, %p, %"PRIu32")",
             (void*)lfs, (void*)file, buffer, size);
-    LFS_ASSERT(lfs_mlist_isopen(lfs.mlist, (struct lfs_mlist*)file));
+    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));
 
-    lfs_ssize_t res = lfs_file_rawwrite(file, buffer, size);
+    lfs_ssize_t res = lfs_file_write_(lfs, file, buffer, size);
 
     LFS_TRACE("lfs_file_write -> %"PRId32, res);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return res;
 }
 #endif
 
-lfs_soff_t lfs_file_seek(lfs_file_t* file, lfs_soff_t off, int whence) {
-    int err = LFS_LOCK;
+lfs_soff_t lfs_file_seek(lfs_t *lfs, lfs_file_t *file,
+        lfs_soff_t off, int whence) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_file_seek(%p, %p, %"PRId32", %d)",
             (void*)lfs, (void*)file, off, whence);
-    LFS_ASSERT(lfs_mlist_isopen(lfs.mlist, (struct lfs_mlist*)file));
+    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));
 
-    lfs_soff_t res = lfs_file_rawseek(file, off, whence);
+    lfs_soff_t res = lfs_file_seek_(lfs, file, off, whence);
 
     LFS_TRACE("lfs_file_seek -> %"PRId32, res);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return res;
 }
 
 #ifndef LFS_READONLY
-int lfs_file_truncate(lfs_file_t* file, lfs_off_t size) {
-    int err = LFS_LOCK;
+int lfs_file_truncate(lfs_t *lfs, lfs_file_t *file, lfs_off_t size) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_file_truncate(%p, %p, %"PRIu32")",
             (void*)lfs, (void*)file, size);
-    LFS_ASSERT(lfs_mlist_isopen(lfs.mlist, (struct lfs_mlist*)file));
+    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));
 
-    err = lfs_file_rawtruncate(file, size);
+    err = lfs_file_truncate_(lfs, file, size);
 
     LFS_TRACE("lfs_file_truncate -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 #endif
 
-lfs_soff_t lfs_file_tell(lfs_file_t* file) {
-    int err = LFS_LOCK;
+lfs_soff_t lfs_file_tell(lfs_t *lfs, lfs_file_t *file) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_file_tell(%p, %p)", (void*)lfs, (void*)file);
-    LFS_ASSERT(lfs_mlist_isopen(lfs.mlist, (struct lfs_mlist*)file));
+    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));
 
-    lfs_soff_t res = lfs_file_rawtell(file);
+    lfs_soff_t res = lfs_file_tell_(lfs, file);
 
     LFS_TRACE("lfs_file_tell -> %"PRId32, res);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return res;
 }
 
-int lfs_file_rewind(lfs_file_t* file) {
-    int err = LFS_LOCK;
+int lfs_file_rewind(lfs_t *lfs, lfs_file_t *file) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_file_rewind(%p, %p)", (void*)lfs, (void*)file);
 
-    err = lfs_file_rawrewind(file);
+    err = lfs_file_rewind_(lfs, file);
 
     LFS_TRACE("lfs_file_rewind -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 
-lfs_soff_t lfs_file_size(lfs_file_t* file) {
-    int err = LFS_LOCK;
+lfs_soff_t lfs_file_size(lfs_t *lfs, lfs_file_t *file) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_file_size(%p, %p)", (void*)lfs, (void*)file);
-    LFS_ASSERT(lfs_mlist_isopen(lfs.mlist, (struct lfs_mlist*)file));
+    LFS_ASSERT(lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)file));
 
-    lfs_soff_t res = lfs_file_rawsize(file);
+    lfs_soff_t res = lfs_file_size_(lfs, file);
 
-    LFS_TRACE("lfs_file_size -> %"PRId32, res);
-    LFS_UNLOCK;
+    LFS_TRACE("lfs_file_size -> %"PRIu32, res);
+    LFS_UNLOCK(lfs->cfg);
     return res;
 }
 
 #ifndef LFS_READONLY
-int lfs_mkdir(const char* path) {
-    int err = LFS_LOCK;
+int lfs_mkdir(lfs_t *lfs, const char *path) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_mkdir(%p, \"%s\")", (void*)lfs, path);
 
-    err = lfs_rawmkdir(path);
+    err = lfs_mkdir_(lfs, path);
 
     LFS_TRACE("lfs_mkdir -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 #endif
 
-int lfs_dir_open(lfs_dir_t* dir, const char* path) {
-    int err = LFS_LOCK;
+int lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_dir_open(%p, %p, \"%s\")", (void*)lfs, (void*)dir, path);
-    LFS_ASSERT(!lfs_mlist_isopen(lfs.mlist, (struct lfs_mlist*)dir));
+    LFS_ASSERT(!lfs_mlist_isopen(lfs->mlist, (struct lfs_mlist*)dir));
 
-    err = lfs_dir_rawopen(dir, path);
+    err = lfs_dir_open_(lfs, dir, path);
 
     LFS_TRACE("lfs_dir_open -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 
-int lfs_dir_close(lfs_dir_t* dir) {
-    int err = LFS_LOCK;
+int lfs_dir_close(lfs_t *lfs, lfs_dir_t *dir) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_dir_close(%p, %p)", (void*)lfs, (void*)dir);
 
-    err = lfs_dir_rawclose(dir);
+    err = lfs_dir_close_(lfs, dir);
 
     LFS_TRACE("lfs_dir_close -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 
-int lfs_dir_read(lfs_dir_t* dir, struct lfs_info* info) {
-    int err = LFS_LOCK;
+int lfs_dir_read(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_dir_read(%p, %p, %p)",
             (void*)lfs, (void*)dir, (void*)info);
 
-    err = lfs_dir_rawread(dir, info);
+    err = lfs_dir_read_(lfs, dir, info);
 
     LFS_TRACE("lfs_dir_read -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 
-int lfs_dir_seek(lfs_dir_t* dir, lfs_off_t off) {
-    int err = LFS_LOCK;
+int lfs_dir_seek(lfs_t *lfs, lfs_dir_t *dir, lfs_off_t off) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_dir_seek(%p, %p, %"PRIu32")",
             (void*)lfs, (void*)dir, off);
 
-    err = lfs_dir_rawseek(dir, off);
+    err = lfs_dir_seek_(lfs, dir, off);
 
     LFS_TRACE("lfs_dir_seek -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 
-lfs_soff_t lfs_dir_tell(lfs_dir_t* dir) {
-    int err = LFS_LOCK;
+lfs_soff_t lfs_dir_tell(lfs_t *lfs, lfs_dir_t *dir) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_dir_tell(%p, %p)", (void*)lfs, (void*)dir);
 
-    lfs_soff_t res = lfs_dir_rawtell(dir);
+    lfs_soff_t res = lfs_dir_tell_(lfs, dir);
 
     LFS_TRACE("lfs_dir_tell -> %"PRId32, res);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return res;
 }
 
-int lfs_dir_rewind(lfs_dir_t* dir) {
-    int err = LFS_LOCK;
+int lfs_dir_rewind(lfs_t *lfs, lfs_dir_t *dir) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_dir_rewind(%p, %p)", (void*)lfs, (void*)dir);
 
-    err = lfs_dir_rawrewind(dir);
+    err = lfs_dir_rewind_(lfs, dir);
 
     LFS_TRACE("lfs_dir_rewind -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
+    return err;
+}
+
+int lfs_fs_stat(lfs_t *lfs, struct lfs_fsinfo *fsinfo) {
+    int err = LFS_LOCK(lfs->cfg);
+    if (err) {
+        return err;
+    }
+    LFS_TRACE("lfs_fs_stat(%p, %p)", (void*)lfs, (void*)fsinfo);
+
+    err = lfs_fs_stat_(lfs, fsinfo);
+
+    LFS_TRACE("lfs_fs_stat -> %d", err);
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 
-lfs_ssize_t lfs_fs_size(void) {
-    int err = LFS_LOCK;
+lfs_ssize_t lfs_fs_size(lfs_t *lfs) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_fs_size(%p)", (void*)lfs);
 
-    lfs_ssize_t res = lfs_fs_rawsize();
+    lfs_ssize_t res = lfs_fs_size_(lfs);
 
     LFS_TRACE("lfs_fs_size -> %"PRId32, res);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return res;
 }
 
-int lfs_fs_traverse(int (*cb)(void*, lfs_block_t), void* data) {
-    int err = LFS_LOCK;
+int lfs_fs_traverse(lfs_t *lfs, int (*cb)(void *, lfs_block_t), void *data) {
+    int err = LFS_LOCK(lfs->cfg);
     if (err) {
         return err;
     }
     LFS_TRACE("lfs_fs_traverse(%p, %p, %p)",
             (void*)lfs, (void*)(uintptr_t)cb, data);
 
-    err = lfs_fs_rawtraverse(cb, data, true);
+    err = lfs_fs_traverse_(lfs, cb, data, true);
 
     LFS_TRACE("lfs_fs_traverse -> %d", err);
-    LFS_UNLOCK;
+    LFS_UNLOCK(lfs->cfg);
     return err;
 }
 
-// Software CRC implementation with small lookup table
-uint32_t lfs_crc(uint32_t crc, const void* buffer, size_t size) {
-    static const uint32_t rtable[16] = {
-        0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4,
-        0x4db26158, 0x5005713c, 0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
-        0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c,
-    };
+#ifndef LFS_READONLY
+int lfs_fs_mkconsistent(lfs_t *lfs) {
+    int err = LFS_LOCK(lfs->cfg);
+    if (err) {
+        return err;
+    }
+    LFS_TRACE("lfs_fs_mkconsistent(%p)", (void*)lfs);
+
+    err = lfs_fs_mkconsistent_(lfs);
+
+    LFS_TRACE("lfs_fs_mkconsistent -> %d", err);
+    LFS_UNLOCK(lfs->cfg);
+    return err;
+}
+#endif
+
+#ifndef LFS_READONLY
+int lfs_fs_gc(lfs_t *lfs) {
+    int err = LFS_LOCK(lfs->cfg);
+    if (err) {
+        return err;
+    }
+    LFS_TRACE("lfs_fs_gc(%p)", (void*)lfs);
+
+    err = lfs_fs_gc_(lfs);
+
+    LFS_TRACE("lfs_fs_gc -> %d", err);
+    LFS_UNLOCK(lfs->cfg);
+    return err;
+}
+#endif
+
+#ifndef LFS_READONLY
+int lfs_fs_grow(lfs_t *lfs, lfs_size_t block_count) {
+    int err = LFS_LOCK(lfs->cfg);
+    if (err) {
+        return err;
+    }
+    LFS_TRACE("lfs_fs_grow(%p, %"PRIu32")", (void*)lfs, block_count);
 
-    const uint8_t* data = buffer;
+    err = lfs_fs_grow_(lfs, block_count);
 
-    for (size_t i = 0; i < size; i++) {
-        crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 0)) & 0xf];
-        crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 4)) & 0xf];
+    LFS_TRACE("lfs_fs_grow -> %d", err);
+    LFS_UNLOCK(lfs->cfg);
+    return err;
+}
+#endif
+
+#ifdef LFS_MIGRATE
+int lfs_migrate(lfs_t *lfs, const struct lfs_config *cfg) {
+    int err = LFS_LOCK(cfg);
+    if (err) {
+        return err;
     }
+    LFS_TRACE("lfs_migrate(%p, %p {.context=%p, "
+                ".read=%p, .prog=%p, .erase=%p, .sync=%p, "
+                ".read_size=%"PRIu32", .prog_size=%"PRIu32", "
+                ".block_size=%"PRIu32", .block_count=%"PRIu32", "
+                ".block_cycles=%"PRId32", .cache_size=%"PRIu32", "
+                ".lookahead_size=%"PRIu32", .read_buffer=%p, "
+                ".prog_buffer=%p, .lookahead_buffer=%p, "
+                ".name_max=%"PRIu32", .file_max=%"PRIu32", "
+                ".attr_max=%"PRIu32"})",
+            (void*)lfs, (void*)cfg, cfg->context,
+            (void*)(uintptr_t)cfg->read, (void*)(uintptr_t)cfg->prog,
+            (void*)(uintptr_t)cfg->erase, (void*)(uintptr_t)cfg->sync,
+            cfg->read_size, cfg->prog_size, cfg->block_size, cfg->block_count,
+            cfg->block_cycles, cfg->cache_size, cfg->lookahead_size,
+            cfg->read_buffer, cfg->prog_buffer, cfg->lookahead_buffer,
+            cfg->name_max, cfg->file_max, cfg->attr_max);
 
-    return crc;
+    err = lfs_migrate_(lfs, cfg);
+
+    LFS_TRACE("lfs_migrate -> %d", err);
+    LFS_UNLOCK(cfg);
+    return err;
 }
+#endif
+
diff --git a/lfs.h b/lfs.h
index 481cc8b..215309c 100644
--- a/lfs.h
+++ b/lfs.h
@@ -1,14 +1,13 @@
 /*
  * The little filesystem
  *
+ * Copyright (c) 2022, The littlefs authors.
  * Copyright (c) 2017, Arm Limited. All rights reserved.
  * SPDX-License-Identifier: BSD-3-Clause
  */
 #ifndef LFS_H
 #define LFS_H
 
-#include <stdint.h>
-#include <stdbool.h>
 #include "lfs_util.h"
 
 #ifdef __cplusplus
@@ -22,14 +21,14 @@ extern "C"
 // Software library version
 // Major (top-nibble), incremented on backwards incompatible changes
 // Minor (bottom-nibble), incremented on feature additions
-#define LFS_VERSION 0x00020004
+#define LFS_VERSION 0x0002000b
 #define LFS_VERSION_MAJOR (0xffff & (LFS_VERSION >> 16))
 #define LFS_VERSION_MINOR (0xffff & (LFS_VERSION >>  0))
 
 // Version of On-disk data structures
 // Major (top-nibble), incremented on backwards incompatible changes
 // Minor (bottom-nibble), incremented on feature additions
-#define LFS_DISK_VERSION 0x00020000
+#define LFS_DISK_VERSION 0x00020001
 #define LFS_DISK_VERSION_MAJOR (0xffff & (LFS_DISK_VERSION >> 16))
 #define LFS_DISK_VERSION_MINOR (0xffff & (LFS_DISK_VERSION >>  0))
 
@@ -53,16 +52,15 @@ typedef uint32_t lfs_block_t;
 #endif
 
 // Maximum size of a file in bytes, may be redefined to limit to support other
-// drivers. Limited on disk to <= 4294967296. However, above 2147483647 the
-// functions lfs_file_seek, lfs_file_size, and lfs_file_tell will return
-// incorrect values due to using signed integers. Stored in superblock and
-// must be respected by other littlefs drivers.
+// drivers. Limited on disk to <= 2147483647. Stored in superblock and must be
+// respected by other littlefs drivers.
 #ifndef LFS_FILE_MAX
 #define LFS_FILE_MAX 2147483647
 #endif
 
 // Maximum size of custom attributes in bytes, may be redefined, but there is
-// no real benefit to using a smaller LFS_ATTR_MAX. Limited to <= 1022.
+// no real benefit to using a smaller LFS_ATTR_MAX. Limited to <= 1022. Stored
+// in superblock and must be respected by other littlefs drivers.
 #ifndef LFS_ATTR_MAX
 #define LFS_ATTR_MAX 1022
 #endif
@@ -70,21 +68,21 @@ typedef uint32_t lfs_block_t;
 // Possible error codes, these are negative to allow
 // valid positive return values
 enum lfs_error {
-    LFS_ERR_OK = 0,           // No error
-    LFS_ERR_IO = -1,          // Error during device operation
-    LFS_ERR_CORRUPT = -2,     // Corrupted
-    LFS_ERR_NOENT = -3,       // No directory entry
-    LFS_ERR_EXIST = -4,       // Entry already exists
-    LFS_ERR_NOTDIR = -5,      // Entry is not a dir
-    LFS_ERR_ISDIR = -5,       // Entry is a dir
-    LFS_ERR_NOTEMPTY = -7,    // Dir is not empty
-    LFS_ERR_BADF = -8,        // Bad file number
-    LFS_ERR_FBIG = -9,        // File too large
-    LFS_ERR_INVAL = -10,      // Invalid parameter
-    LFS_ERR_NOSPC = -11,      // No space left on device
-    LFS_ERR_NOMEM = -12,      // No more memory available
-    LFS_ERR_NOATTR = -13,     // No data/attr available
-    LFS_ERR_NAMETOOLONG = -14 // File name too long
+    LFS_ERR_OK          = 0,    // No error
+    LFS_ERR_IO          = -5,   // Error during device operation
+    LFS_ERR_CORRUPT     = -84,  // Corrupted
+    LFS_ERR_NOENT       = -2,   // No directory entry
+    LFS_ERR_EXIST       = -17,  // Entry already exists
+    LFS_ERR_NOTDIR      = -20,  // Entry is not a dir
+    LFS_ERR_ISDIR       = -21,  // Entry is a dir
+    LFS_ERR_NOTEMPTY    = -39,  // Dir is not empty
+    LFS_ERR_BADF        = -9,   // Bad file number
+    LFS_ERR_FBIG        = -27,  // File too large
+    LFS_ERR_INVAL       = -22,  // Invalid parameter
+    LFS_ERR_NOSPC       = -28,  // No space left on device
+    LFS_ERR_NOMEM       = -12,  // No more memory available
+    LFS_ERR_NOATTR      = -61,  // No data/attr available
+    LFS_ERR_NAMETOOLONG = -36,  // File name too long
 };
 
 // File types
@@ -113,6 +111,8 @@ enum lfs_type {
     LFS_TYPE_SOFTTAIL       = 0x600,
     LFS_TYPE_HARDTAIL       = 0x601,
     LFS_TYPE_MOVESTATE      = 0x7ff,
+    LFS_TYPE_CCRC           = 0x500,
+    LFS_TYPE_FCRC           = 0x5ff,
 
     // internal chip sources
     LFS_FROM_NOOP           = 0x000,
@@ -159,46 +159,53 @@ struct lfs_config {
     // information to the block device operations
     void *context;
 
-    // Read a region in a block. Negative error codes are propogated
+    // Read a region in a block. Negative error codes are propagated
     // to the user.
-    int (*read)(lfs_block_t block, lfs_off_t off, void* buffer, lfs_size_t size);
+    int (*read)(const struct lfs_config *c, lfs_block_t block,
+            lfs_off_t off, void *buffer, lfs_size_t size);
 
     // Program a region in a block. The block must have previously
-    // been erased. Negative error codes are propogated to the user.
+    // been erased. Negative error codes are propagated to the user.
     // May return LFS_ERR_CORRUPT if the block should be considered bad.
-    int (*prog)(lfs_block_t block, lfs_off_t off, const void* buffer, lfs_size_t size);
+    int (*prog)(const struct lfs_config *c, lfs_block_t block,
+            lfs_off_t off, const void *buffer, lfs_size_t size);
 
     // Erase a block. A block must be erased before being programmed.
     // The state of an erased block is undefined. Negative error codes
-    // are propogated to the user.
+    // are propagated to the user.
     // May return LFS_ERR_CORRUPT if the block should be considered bad.
-    int (*erase)(lfs_block_t block);
+    int (*erase)(const struct lfs_config *c, lfs_block_t block);
+
+    // Sync the state of the underlying block device. Negative error codes
+    // are propagated to the user.
+    int (*sync)(const struct lfs_config *c);
 
-#if LIB_PICO_MULTICORE
+#ifdef LFS_THREADSAFE
     // Lock the underlying block device. Negative error codes
-    // are propogated to the user.
-    int (*lock)(void);
+    // are propagated to the user.
+    int (*lock)(const struct lfs_config *c);
 
     // Unlock the underlying block device. Negative error codes
-    // are propogated to the user.
-    int (*unlock)(void);
+    // are propagated to the user.
+    int (*unlock)(const struct lfs_config *c);
 #endif
 
-    // Minimum size of a block read. All read operations will be a
+    // Minimum size of a block read in bytes. All read operations will be a
     // multiple of this value.
     lfs_size_t read_size;
 
-    // Minimum size of a block program. All program operations will be a
-    // multiple of this value.
+    // Minimum size of a block program in bytes. All program operations will be
+    // a multiple of this value.
     lfs_size_t prog_size;
 
-    // Size of an erasable block. This does not impact ram consumption and
-    // may be larger than the physical erase size. However, non-inlined files
-    // take up at minimum one block. Must be a multiple of the read
-    // and program sizes.
+    // Size of an erasable block in bytes. This does not impact ram consumption
+    // and may be larger than the physical erase size. However, non-inlined
+    // files take up at minimum one block. Must be a multiple of the read and
+    // program sizes.
     lfs_size_t block_size;
 
-    // Number of erasable blocks on the device.
+    // Number of erasable blocks on the device. Defaults to block_count stored
+    // on disk when zero.
     lfs_size_t block_count;
 
     // Number of erase cycles before littlefs evicts metadata logs and moves
@@ -209,19 +216,30 @@ struct lfs_config {
     // Set to -1 to disable block-level wear-leveling.
     int32_t block_cycles;
 
-    // Size of block caches. Each cache buffers a portion of a block in RAM.
-    // The littlefs needs a read cache, a program cache, and one additional
+    // Size of block caches in bytes. Each cache buffers a portion of a block in
+    // RAM. The littlefs needs a read cache, a program cache, and one additional
     // cache per file. Larger caches can improve performance by storing more
-    // data and reducing the number of disk accesses. Must be a multiple of
-    // the read and program sizes, and a factor of the block size.
+    // data and reducing the number of disk accesses. Must be a multiple of the
+    // read and program sizes, and a factor of the block size.
     lfs_size_t cache_size;
 
     // Size of the lookahead buffer in bytes. A larger lookahead buffer
     // increases the number of blocks found during an allocation pass. The
     // lookahead buffer is stored as a compact bitmap, so each byte of RAM
-    // can track 8 blocks. Must be a multiple of 8.
+    // can track 8 blocks.
     lfs_size_t lookahead_size;
 
+    // Threshold for metadata compaction during lfs_fs_gc in bytes. Metadata
+    // pairs that exceed this threshold will be compacted during lfs_fs_gc.
+    // Defaults to ~88% block_size when zero, though the default may change
+    // in the future.
+    //
+    // Note this only affects lfs_fs_gc. Normal compactions still only occur
+    // when full.
+    //
+    // Set to -1 to disable metadata compaction during lfs_fs_gc.
+    lfs_size_t compact_thresh;
+
     // Optional statically allocated read buffer. Must be cache_size.
     // By default lfs_malloc is used to allocate this buffer.
     void *read_buffer;
@@ -230,25 +248,24 @@ struct lfs_config {
     // By default lfs_malloc is used to allocate this buffer.
     void *prog_buffer;
 
-    // Optional statically allocated lookahead buffer. Must be lookahead_size
-    // and aligned to a 32-bit boundary. By default lfs_malloc is used to
-    // allocate this buffer.
+    // Optional statically allocated lookahead buffer. Must be lookahead_size.
+    // By default lfs_malloc is used to allocate this buffer.
     void *lookahead_buffer;
 
     // Optional upper limit on length of file names in bytes. No downside for
     // larger names except the size of the info struct which is controlled by
-    // the LFS_NAME_MAX define. Defaults to LFS_NAME_MAX when zero. Stored in
-    // superblock and must be respected by other littlefs drivers.
+    // the LFS_NAME_MAX define. Defaults to LFS_NAME_MAX or name_max stored on
+    // disk when zero.
     lfs_size_t name_max;
 
     // Optional upper limit on files in bytes. No downside for larger files
-    // but must be <= LFS_FILE_MAX. Defaults to LFS_FILE_MAX when zero. Stored
-    // in superblock and must be respected by other littlefs drivers.
+    // but must be <= LFS_FILE_MAX. Defaults to LFS_FILE_MAX or file_max stored
+    // on disk when zero.
     lfs_size_t file_max;
 
     // Optional upper limit on custom attributes in bytes. No downside for
     // larger attributes size but must be <= LFS_ATTR_MAX. Defaults to
-    // LFS_ATTR_MAX when zero.
+    // LFS_ATTR_MAX or attr_max stored on disk when zero.
     lfs_size_t attr_max;
 
     // Optional upper limit on total space given to metadata pairs in bytes. On
@@ -256,6 +273,23 @@ struct lfs_config {
     // can help bound the metadata compaction time. Must be <= block_size.
     // Defaults to block_size when zero.
     lfs_size_t metadata_max;
+
+    // Optional upper limit on inlined files in bytes. Inlined files live in
+    // metadata and decrease storage requirements, but may be limited to
+    // improve metadata-related performance. Must be <= cache_size, <=
+    // attr_max, and <= block_size/8. Defaults to the largest possible
+    // inline_max when zero.
+    //
+    // Set to -1 to disable inlined files.
+    lfs_size_t inline_max;
+
+#ifdef LFS_MULTIVERSION
+    // On-disk version to use when writing in the form of 16-bit major version
+    // + 16-bit minor version. This limiting metadata to what is supported by
+    // older minor versions. Note that some features will be lost. Defaults to 
+    // to the most recent minor version when zero.
+    uint32_t disk_version;
+#endif
 };
 
 // File info structure
@@ -273,6 +307,27 @@ struct lfs_info {
     char name[LFS_NAME_MAX+1];
 };
 
+// Filesystem info structure
+struct lfs_fsinfo {
+    // On-disk version.
+    uint32_t disk_version;
+
+    // Size of a logical block in bytes.
+    lfs_size_t block_size;
+
+    // Number of logical blocks in filesystem.
+    lfs_size_t block_count;
+
+    // Upper limit on the length of file names in bytes.
+    lfs_size_t name_max;
+
+    // Upper limit on the size of files in bytes.
+    lfs_size_t file_max;
+
+    // Upper limit on the size of custom attributes in bytes.
+    lfs_size_t attr_max;
+};
+
 // Custom attribute structure, used to describe custom attributes
 // committed atomically during file writes.
 struct lfs_attr {
@@ -296,7 +351,7 @@ struct lfs_file_config {
     // Optional list of custom attributes related to the file. If the file
     // is opened with read access, these attributes will be read from disk
     // during the open call. If the file is opened with write access, the
-    // attributes will be written to disk every close. This
+    // attributes will be written to disk every file sync or close. This
     // write occurs atomically with update to the file's contents.
     //
     // Custom attributes are uniquely identified by an 8-bit type and limited
@@ -359,7 +414,7 @@ typedef struct lfs_file {
     lfs_off_t off;
     lfs_cache_t cache;
 
-    const struct lfs_file_config* file_cfg;
+    const struct lfs_file_config *cfg;
 } lfs_file_t;
 
 typedef struct lfs_superblock {
@@ -394,22 +449,26 @@ typedef struct lfs {
     lfs_gstate_t gdisk;
     lfs_gstate_t gdelta;
 
-    struct lfs_free {
-        lfs_block_t off;
+    struct lfs_lookahead {
+        lfs_block_t start;
         lfs_block_t size;
-        lfs_block_t i;
-        lfs_block_t ack;
-        uint32_t *buffer;
-    } free;
+        lfs_block_t next;
+        lfs_block_t ckpoint;
+        uint8_t *buffer;
+    } lookahead;
 
-    const struct lfs_config* cfg;
+    const struct lfs_config *cfg;
+    lfs_size_t block_count;
     lfs_size_t name_max;
     lfs_size_t file_max;
     lfs_size_t attr_max;
+    lfs_size_t inline_max;
 
+#ifdef LFS_MIGRATE
+    struct lfs1 *lfs1;
+#endif
 } lfs_t;
 
-extern lfs_t lfs;
 
 /// Filesystem functions ///
 
@@ -421,7 +480,7 @@ extern lfs_t lfs;
 // be zeroed for defaults and backwards compatibility.
 //
 // Returns a negative error code on failure.
-int lfs_format(const struct lfs_config* config);
+int lfs_format(lfs_t *lfs, const struct lfs_config *config);
 #endif
 
 // Mounts a littlefs
@@ -432,13 +491,13 @@ int lfs_format(const struct lfs_config* config);
 // be zeroed for defaults and backwards compatibility.
 //
 // Returns a negative error code on failure.
-int lfs_mount(const struct lfs_config* config);
+int lfs_mount(lfs_t *lfs, const struct lfs_config *config);
 
 // Unmounts a littlefs
 //
 // Does nothing besides releasing any allocated resources.
 // Returns a negative error code on failure.
-int lfs_unmount(void);
+int lfs_unmount(lfs_t *lfs);
 
 /// General operations ///
 
@@ -447,7 +506,7 @@ int lfs_unmount(void);
 //
 // If removing a directory, the directory must be empty.
 // Returns a negative error code on failure.
-int lfs_remove(const char* path);
+int lfs_remove(lfs_t *lfs, const char *path);
 #endif
 
 #ifndef LFS_READONLY
@@ -457,14 +516,14 @@ int lfs_remove(const char* path);
 // If the destination is a directory, the directory must be empty.
 //
 // Returns a negative error code on failure.
-int lfs_rename(const char* oldpath, const char* newpath);
+int lfs_rename(lfs_t *lfs, const char *oldpath, const char *newpath);
 #endif
 
 // Find info about a file or directory
 //
 // Fills out the info structure, based on the specified file or directory.
 // Returns a negative error code on failure.
-int lfs_stat(const char* path, struct lfs_info* info);
+int lfs_stat(lfs_t *lfs, const char *path, struct lfs_info *info);
 
 // Get a custom attribute
 //
@@ -477,8 +536,9 @@ int lfs_stat(const char* path, struct lfs_info* info);
 // Returns the size of the attribute, or a negative error code on failure.
 // Note, the returned size is the size of the attribute on disk, irrespective
 // of the size of the buffer. This can be used to dynamically allocate a buffer
-// or check for existance.
-lfs_ssize_t lfs_getattr(const char* path, uint8_t type, void* buffer, lfs_size_t size);
+// or check for existence.
+lfs_ssize_t lfs_getattr(lfs_t *lfs, const char *path,
+        uint8_t type, void *buffer, lfs_size_t size);
 
 #ifndef LFS_READONLY
 // Set custom attributes
@@ -488,7 +548,8 @@ lfs_ssize_t lfs_getattr(const char* path, uint8_t type, void* buffer, lfs_size_t
 // implicitly created.
 //
 // Returns a negative error code on failure.
-int lfs_setattr(const char* path, uint8_t type, const void* buffer, lfs_size_t size);
+int lfs_setattr(lfs_t *lfs, const char *path,
+        uint8_t type, const void *buffer, lfs_size_t size);
 #endif
 
 #ifndef LFS_READONLY
@@ -497,19 +558,25 @@ int lfs_setattr(const char* path, uint8_t type, const void* buffer, lfs_size_t s
 // If an attribute is not found, nothing happens.
 //
 // Returns a negative error code on failure.
-int lfs_removeattr(const char* path, uint8_t type);
+int lfs_removeattr(lfs_t *lfs, const char *path, uint8_t type);
 #endif
 
 
 /// File operations ///
 
+#ifndef LFS_NO_MALLOC
 // Open a file
 //
 // The mode that the file is opened in is determined by the flags, which
 // are values from the enum lfs_open_flags that are bitwise-ored together.
 //
 // Returns a negative error code on failure.
-int lfs_file_open(lfs_file_t* file, const char* path, int flags);
+int lfs_file_open(lfs_t *lfs, lfs_file_t *file,
+        const char *path, int flags);
+
+// if LFS_NO_MALLOC is defined, lfs_file_open() will fail with LFS_ERR_NOMEM
+// thus use lfs_file_opencfg() with config.buffer set.
+#endif
 
 // Open a file with extra configuration
 //
@@ -517,12 +584,13 @@ int lfs_file_open(lfs_file_t* file, const char* path, int flags);
 // are values from the enum lfs_open_flags that are bitwise-ored together.
 //
 // The config struct provides additional config options per file as described
-// above. The config struct must be allocated while the file is open, and the
-// config struct must be zeroed for defaults and backwards compatibility.
+// above. The config struct must remain allocated while the file is open, and
+// the config struct must be zeroed for defaults and backwards compatibility.
 //
 // Returns a negative error code on failure.
-int lfs_file_opencfg(lfs_file_t* file, const char* path, int flags,
-                     const struct lfs_file_config* config);
+int lfs_file_opencfg(lfs_t *lfs, lfs_file_t *file,
+        const char *path, int flags,
+        const struct lfs_file_config *config);
 
 // Close a file
 //
@@ -530,19 +598,20 @@ int lfs_file_opencfg(lfs_file_t* file, const char* path, int flags,
 // sync had been called and releases any allocated resources.
 //
 // Returns a negative error code on failure.
-int lfs_file_close(lfs_file_t* file);
+int lfs_file_close(lfs_t *lfs, lfs_file_t *file);
 
 // Synchronize a file on storage
 //
 // Any pending writes are written out to storage.
 // Returns a negative error code on failure.
-int lfs_file_sync(lfs_file_t* file);
+int lfs_file_sync(lfs_t *lfs, lfs_file_t *file);
 
 // Read data from file
 //
 // Takes a buffer and size indicating where to store the read data.
 // Returns the number of bytes read, or a negative error code on failure.
-lfs_ssize_t lfs_file_read(lfs_file_t* file, void* buffer, lfs_size_t size);
+lfs_ssize_t lfs_file_read(lfs_t *lfs, lfs_file_t *file,
+        void *buffer, lfs_size_t size);
 
 #ifndef LFS_READONLY
 // Write data to file
@@ -551,39 +620,42 @@ lfs_ssize_t lfs_file_read(lfs_file_t* file, void* buffer, lfs_size_t size);
 // actually be updated on the storage until either sync or close is called.
 //
 // Returns the number of bytes written, or a negative error code on failure.
-lfs_ssize_t lfs_file_write(lfs_file_t* file, const void* buffer, lfs_size_t size);
+lfs_ssize_t lfs_file_write(lfs_t *lfs, lfs_file_t *file,
+        const void *buffer, lfs_size_t size);
 #endif
 
 // Change the position of the file
 //
 // The change in position is determined by the offset and whence flag.
 // Returns the new position of the file, or a negative error code on failure.
-lfs_soff_t lfs_file_seek(lfs_file_t* file, lfs_soff_t off, int whence);
+lfs_soff_t lfs_file_seek(lfs_t *lfs, lfs_file_t *file,
+        lfs_soff_t off, int whence);
 
 #ifndef LFS_READONLY
 // Truncates the size of the file to the specified size
 //
 // Returns a negative error code on failure.
-int lfs_file_truncate(lfs_file_t* file, lfs_off_t size);
+int lfs_file_truncate(lfs_t *lfs, lfs_file_t *file, lfs_off_t size);
 #endif
 
 // Return the position of the file
 //
 // Equivalent to lfs_file_seek(lfs, file, 0, LFS_SEEK_CUR)
 // Returns the position of the file, or a negative error code on failure.
-lfs_soff_t lfs_file_tell(lfs_file_t* file);
+lfs_soff_t lfs_file_tell(lfs_t *lfs, lfs_file_t *file);
 
 // Change the position of the file to the beginning of the file
 //
 // Equivalent to lfs_file_seek(lfs, file, 0, LFS_SEEK_SET)
 // Returns a negative error code on failure.
-int lfs_file_rewind(lfs_file_t* file);
+int lfs_file_rewind(lfs_t *lfs, lfs_file_t *file);
 
 // Return the size of the file
 //
 // Similar to lfs_file_seek(lfs, file, 0, LFS_SEEK_END)
 // Returns the size of the file, or a negative error code on failure.
-lfs_soff_t lfs_file_size(lfs_file_t* file);
+lfs_soff_t lfs_file_size(lfs_t *lfs, lfs_file_t *file);
+
 
 /// Directory operations ///
 
@@ -591,27 +663,27 @@ lfs_soff_t lfs_file_size(lfs_file_t* file);
 // Create a directory
 //
 // Returns a negative error code on failure.
-int lfs_mkdir(const char* path);
+int lfs_mkdir(lfs_t *lfs, const char *path);
 #endif
 
 // Open a directory
 //
 // Once open a directory can be used with read to iterate over files.
 // Returns a negative error code on failure.
-int lfs_dir_open(lfs_dir_t* dir, const char* path);
+int lfs_dir_open(lfs_t *lfs, lfs_dir_t *dir, const char *path);
 
 // Close a directory
 //
 // Releases any allocated resources.
 // Returns a negative error code on failure.
-int lfs_dir_close(lfs_dir_t* dir);
+int lfs_dir_close(lfs_t *lfs, lfs_dir_t *dir);
 
 // Read an entry in the directory
 //
 // Fills out the info structure, based on the specified file or directory.
 // Returns a positive value on success, 0 at the end of directory,
 // or a negative error code on failure.
-int lfs_dir_read(lfs_dir_t* dir, struct lfs_info* info);
+int lfs_dir_read(lfs_t *lfs, lfs_dir_t *dir, struct lfs_info *info);
 
 // Change the position of the directory
 //
@@ -619,7 +691,7 @@ int lfs_dir_read(lfs_dir_t* dir, struct lfs_info* info);
 // an absolute offset in the directory seek.
 //
 // Returns a negative error code on failure.
-int lfs_dir_seek(lfs_dir_t* dir, lfs_off_t off);
+int lfs_dir_seek(lfs_t *lfs, lfs_dir_t *dir, lfs_off_t off);
 
 // Return the position of the directory
 //
@@ -627,22 +699,29 @@ int lfs_dir_seek(lfs_dir_t* dir, lfs_off_t off);
 // sense, but does indicate the current position in the directory iteration.
 //
 // Returns the position of the directory, or a negative error code on failure.
-lfs_soff_t lfs_dir_tell(lfs_dir_t* dir);
+lfs_soff_t lfs_dir_tell(lfs_t *lfs, lfs_dir_t *dir);
 
 // Change the position of the directory to the beginning of the directory
 //
 // Returns a negative error code on failure.
-int lfs_dir_rewind(lfs_dir_t* dir);
+int lfs_dir_rewind(lfs_t *lfs, lfs_dir_t *dir);
+
 
 /// Filesystem-level filesystem operations
 
+// Find on-disk info about the filesystem
+//
+// Fills out the fsinfo structure based on the filesystem found on-disk.
+// Returns a negative error code on failure.
+int lfs_fs_stat(lfs_t *lfs, struct lfs_fsinfo *fsinfo);
+
 // Finds the current size of the filesystem
 //
 // Note: Result is best effort. If files share COW structures, the returned
 // size may be larger than the filesystem actually is.
 //
 // Returns the number of allocated blocks, or a negative error code on failure.
-lfs_ssize_t lfs_fs_size(void);
+lfs_ssize_t lfs_fs_size(lfs_t *lfs);
 
 // Traverse through all blocks in use by the filesystem
 //
@@ -651,13 +730,69 @@ lfs_ssize_t lfs_fs_size(void);
 // blocks are in use or how much of the storage is available.
 //
 // Returns a negative error code on failure.
-int lfs_fs_traverse(int (*cb)(void*, lfs_block_t), void* data);
+int lfs_fs_traverse(lfs_t *lfs, int (*cb)(void*, lfs_block_t), void *data);
+
+#ifndef LFS_READONLY
+// Attempt to make the filesystem consistent and ready for writing
+//
+// Calling this function is not required, consistency will be implicitly
+// enforced on the first operation that writes to the filesystem, but this
+// function allows the work to be performed earlier and without other
+// filesystem changes.
+//
+// Returns a negative error code on failure.
+int lfs_fs_mkconsistent(lfs_t *lfs);
+#endif
+
+#ifndef LFS_READONLY
+// Attempt any janitorial work
+//
+// This currently:
+// 1. Calls mkconsistent if not already consistent
+// 2. Compacts metadata > compact_thresh
+// 3. Populates the block allocator
+//
+// Though additional janitorial work may be added in the future.
+//
+// Calling this function is not required, but may allow the offloading of
+// expensive janitorial work to a less time-critical code path.
+//
+// Returns a negative error code on failure. Accomplishing nothing is not
+// an error.
+int lfs_fs_gc(lfs_t *lfs);
+#endif
+
+#ifndef LFS_READONLY
+// Grows the filesystem to a new size, updating the superblock with the new
+// block count.
+//
+// If LFS_SHRINKNONRELOCATING is defined, this function will also accept
+// block_counts smaller than the current configuration, after checking
+// that none of the blocks that are being removed are in use.
+// Note that littlefs's pseudorandom block allocation means that
+// this is very unlikely to work in the general case.
+//
+// Returns a negative error code on failure.
+int lfs_fs_grow(lfs_t *lfs, lfs_size_t block_count);
+#endif
+
+#ifndef LFS_READONLY
+#ifdef LFS_MIGRATE
+// Attempts to migrate a previous version of littlefs
+//
+// Behaves similarly to the lfs_format function. Attempts to mount
+// the previous version of littlefs and update the filesystem so it can be
+// mounted with the current version of littlefs.
+//
+// Requires a littlefs object and config struct. This clobbers the littlefs
+// object, and does not leave the filesystem mounted. The config struct must
+// be zeroed for defaults and backwards compatibility.
+//
+// Returns a negative error code on failure.
+int lfs_migrate(lfs_t *lfs, const struct lfs_config *cfg);
+#endif
+#endif
 
-// Allocate memory, only used if buffers are not provided to littlefs
-// Note, memory must be 64-bit aligned
-static inline void* lfs_malloc(size_t size) {
-    return malloc(size);
-}
 
 #ifdef __cplusplus
 } /* extern "C" */
diff --git a/lfs_util.c b/lfs_util.c
new file mode 100644
index 0000000..dac72ab
--- /dev/null
+++ b/lfs_util.c
@@ -0,0 +1,37 @@
+/*
+ * lfs util functions
+ *
+ * Copyright (c) 2022, The littlefs authors.
+ * Copyright (c) 2017, Arm Limited. All rights reserved.
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#include "lfs_util.h"
+
+// Only compile if user does not provide custom config
+#ifndef LFS_CONFIG
+
+
+// If user provides their own CRC impl we don't need this
+#ifndef LFS_CRC
+// Software CRC implementation with small lookup table
+uint32_t lfs_crc(uint32_t crc, const void *buffer, size_t size) {
+    static const uint32_t rtable[16] = {
+        0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
+        0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
+        0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
+        0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c,
+    };
+
+    const uint8_t *data = buffer;
+
+    for (size_t i = 0; i < size; i++) {
+        crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 0)) & 0xf];
+        crc = (crc >> 4) ^ rtable[(crc ^ (data[i] >> 4)) & 0xf];
+    }
+
+    return crc;
+}
+#endif
+
+
+#endif
diff --git a/lfs_util.h b/lfs_util.h
index 844235b..c1999fa 100644
--- a/lfs_util.h
+++ b/lfs_util.h
@@ -1,12 +1,43 @@
 /*
  * lfs utility functions
  *
+ * Copyright (c) 2022, The littlefs authors.
  * Copyright (c) 2017, Arm Limited. All rights reserved.
  * SPDX-License-Identifier: BSD-3-Clause
  */
 #ifndef LFS_UTIL_H
 #define LFS_UTIL_H
 
+#define LFS_STRINGIZE(x) LFS_STRINGIZE2(x)
+#define LFS_STRINGIZE2(x) #x
+
+// Users can override lfs_util.h with their own configuration by defining
+// LFS_CONFIG as a header file to include (-DLFS_CONFIG=lfs_config.h).
+//
+// If LFS_CONFIG is used, none of the default utils will be emitted and must be
+// provided by the config file. To start, I would suggest copying lfs_util.h
+// and modifying as needed.
+#ifdef LFS_CONFIG
+#include LFS_STRINGIZE(LFS_CONFIG)
+#else
+
+// Alternatively, users can provide a header file which defines
+// macros and other things consumed by littlefs.
+//
+// For example, provide my_defines.h, which contains
+// something like:
+//
+// #include <stddef.h>
+// extern void *my_malloc(size_t sz);
+// #define LFS_MALLOC(sz) my_malloc(sz)
+//
+// And build littlefs with the header by defining LFS_DEFINES.
+// (-DLFS_DEFINES=my_defines.h)
+
+#ifdef LFS_DEFINES
+#include LFS_STRINGIZE(LFS_DEFINES)
+#endif
+
 // System includes
 #include <stdint.h>
 #include <stdbool.h>
@@ -19,9 +50,10 @@
 #ifndef LFS_NO_ASSERT
 #include <assert.h>
 #endif
-
-#if !defined(LFS_NO_DEBUG) || !defined(LFS_NO_WARN) || !defined(LFS_NO_ERROR) ||                   \
-    defined(LFS_YES_TRACE)
+#if !defined(LFS_NO_DEBUG) || \
+        !defined(LFS_NO_WARN) || \
+        !defined(LFS_NO_ERROR) || \
+        defined(LFS_YES_TRACE)
 #include <stdio.h>
 #endif
 
@@ -85,6 +117,11 @@ extern "C"
 #endif
 #endif
 
+
+// Builtin functions, these may be replaced by more efficient
+// toolchain-specific implementations. LFS_NO_INTRINSICS falls back to a more
+// expensive basic C implementation for debugging purposes
+
 // Min/max functions for unsigned 32-bit numbers
 static inline uint32_t lfs_max(uint32_t a, uint32_t b) {
     return (a > b) ? a : b;
@@ -105,18 +142,39 @@ static inline uint32_t lfs_alignup(uint32_t a, uint32_t alignment) {
 
 // Find the smallest power of 2 greater than or equal to a
 static inline uint32_t lfs_npw2(uint32_t a) {
+#if !defined(LFS_NO_INTRINSICS) && (defined(__GNUC__) || defined(__CC_ARM))
     return 32 - __builtin_clz(a-1);
+#else
+    uint32_t r = 0;
+    uint32_t s;
+    a -= 1;
+    s = (a > 0xffff) << 4; a >>= s; r |= s;
+    s = (a > 0xff  ) << 3; a >>= s; r |= s;
+    s = (a > 0xf   ) << 2; a >>= s; r |= s;
+    s = (a > 0x3   ) << 1; a >>= s; r |= s;
+    return (r | (a >> 1)) + 1;
+#endif
 }
 
 // Count the number of trailing binary zeros in a
 // lfs_ctz(0) may be undefined
 static inline uint32_t lfs_ctz(uint32_t a) {
+#if !defined(LFS_NO_INTRINSICS) && defined(__GNUC__)
     return __builtin_ctz(a);
+#else
+    return lfs_npw2((a & -a) + 1) - 1;
+#endif
 }
 
 // Count the number of binary ones in a
 static inline uint32_t lfs_popc(uint32_t a) {
+#if !defined(LFS_NO_INTRINSICS) && (defined(__GNUC__) || defined(__CC_ARM))
     return __builtin_popcount(a);
+#else
+    a = a - ((a >> 1) & 0x55555555);
+    a = (a & 0x33333333) + ((a >> 2) & 0x33333333);
+    return (((a + (a >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;
+#endif
 }
 
 // Find the sequence comparison of a and b, this is the distance
@@ -127,7 +185,21 @@ static inline int lfs_scmp(uint32_t a, uint32_t b) {
 
 // Convert between 32-bit little-endian and native order
 static inline uint32_t lfs_fromle32(uint32_t a) {
+#if (defined(  BYTE_ORDER  ) && defined(  ORDER_LITTLE_ENDIAN  ) &&   BYTE_ORDER   ==   ORDER_LITTLE_ENDIAN  ) || \
+    (defined(__BYTE_ORDER  ) && defined(__ORDER_LITTLE_ENDIAN  ) && __BYTE_ORDER   == __ORDER_LITTLE_ENDIAN  ) || \
+    (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
     return a;
+#elif !defined(LFS_NO_INTRINSICS) && ( \
+    (defined(  BYTE_ORDER  ) && defined(  ORDER_BIG_ENDIAN  ) &&   BYTE_ORDER   ==   ORDER_BIG_ENDIAN  ) || \
+    (defined(__BYTE_ORDER  ) && defined(__ORDER_BIG_ENDIAN  ) && __BYTE_ORDER   == __ORDER_BIG_ENDIAN  ) || \
+    (defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__))
+    return __builtin_bswap32(a);
+#else
+    return ((uint32_t)((uint8_t*)&a)[0] <<  0) |
+           ((uint32_t)((uint8_t*)&a)[1] <<  8) |
+           ((uint32_t)((uint8_t*)&a)[2] << 16) |
+           ((uint32_t)((uint8_t*)&a)[3] << 24);
+#endif
 }
 
 static inline uint32_t lfs_tole32(uint32_t a) {
@@ -136,7 +208,21 @@ static inline uint32_t lfs_tole32(uint32_t a) {
 
 // Convert between 32-bit big-endian and native order
 static inline uint32_t lfs_frombe32(uint32_t a) {
+#if !defined(LFS_NO_INTRINSICS) && ( \
+    (defined(  BYTE_ORDER  ) && defined(  ORDER_LITTLE_ENDIAN  ) &&   BYTE_ORDER   ==   ORDER_LITTLE_ENDIAN  ) || \
+    (defined(__BYTE_ORDER  ) && defined(__ORDER_LITTLE_ENDIAN  ) && __BYTE_ORDER   == __ORDER_LITTLE_ENDIAN  ) || \
+    (defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))
     return __builtin_bswap32(a);
+#elif (defined(  BYTE_ORDER  ) && defined(  ORDER_BIG_ENDIAN  ) &&   BYTE_ORDER   ==   ORDER_BIG_ENDIAN  ) || \
+    (defined(__BYTE_ORDER  ) && defined(__ORDER_BIG_ENDIAN  ) && __BYTE_ORDER   == __ORDER_BIG_ENDIAN  ) || \
+    (defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+    return a;
+#else
+    return ((uint32_t)((uint8_t*)&a)[0] << 24) |
+           ((uint32_t)((uint8_t*)&a)[1] << 16) |
+           ((uint32_t)((uint8_t*)&a)[2] <<  8) |
+           ((uint32_t)((uint8_t*)&a)[3] <<  0);
+#endif
 }
 
 static inline uint32_t lfs_tobe32(uint32_t a) {
@@ -144,11 +230,34 @@ static inline uint32_t lfs_tobe32(uint32_t a) {
 }
 
 // Calculate CRC-32 with polynomial = 0x04c11db7
+#ifdef LFS_CRC
+static inline uint32_t lfs_crc(uint32_t crc, const void *buffer, size_t size) {
+    return LFS_CRC(crc, buffer, size);
+}
+#else
 uint32_t lfs_crc(uint32_t crc, const void *buffer, size_t size);
+#endif
+
+// Allocate memory, only used if buffers are not provided to littlefs
+//
+// littlefs current has no alignment requirements, as it only allocates
+// byte-level buffers.
+static inline void *lfs_malloc(size_t size) {
+#if defined(LFS_MALLOC)
+    return LFS_MALLOC(size);
+#elif !defined(LFS_NO_MALLOC)
+    return malloc(size);
+#else
+    (void)size;
+    return NULL;
+#endif
+}
 
 // Deallocate memory, only used if buffers are not provided to littlefs
 static inline void lfs_free(void *p) {
-#ifndef LFS_NO_MALLOC
+#if defined(LFS_FREE)
+    LFS_FREE(p);
+#elif !defined(LFS_NO_MALLOC)
     free(p);
 #else
     (void)p;
@@ -161,3 +270,4 @@ static inline void lfs_free(void *p) {
 #endif
 
 #endif
+#endif
diff --git a/pico_hal.c b/pico_hal.c
index db169c5..f816716 100644
--- a/pico_hal.c
+++ b/pico_hal.c
@@ -19,22 +19,34 @@
 
 #include "pico_hal.h"
 
+#ifndef FS_SIZE
 #define FS_SIZE (256 * 1024)
+#endif
+
+#ifndef UNUSED
+#define UNUSED(x) { (void)(x); }
+#endif
 
-static int pico_hal_read(lfs_block_t block, lfs_off_t off, void* buffer, lfs_size_t size);
-static int pico_hal_prog(lfs_block_t block, lfs_off_t off, const void* buffer, lfs_size_t size);
-static int pico_hal_erase(lfs_block_t block);
-static int pico_lock(void);
-static int pico_unlock(void);
+static lfs_t pic_lfs_ctx;
+
+static int pico_hal_read(const struct lfs_config *cfg, lfs_block_t block, lfs_off_t off, void* buffer, lfs_size_t size);
+static int pico_hal_prog(const struct lfs_config *cfg, lfs_block_t block, lfs_off_t off, const void* buffer, lfs_size_t size);
+static int pico_hal_erase(const struct lfs_config *cfg, lfs_block_t block);
+static int pico_hal_sync(const struct lfs_config *cfg);
+#if LIB_PICO_MULTICORE
+static int pico_lock(const struct lfs_config *cfg);
+static int pico_unlock(const struct lfs_config *cfg);
+#endif
 
 // configuration of the filesystem is provided by this struct
 // for Pico: prog size = 256, block size = 4096, so cache is 8K
 // minimum cache = block size, must be multiple
-struct lfs_config pico_cfg = {
+static struct lfs_config pico_cfg = {
     // block device operations
     .read = pico_hal_read,
     .prog = pico_hal_prog,
     .erase = pico_hal_erase,
+    .sync = pico_hal_sync,
 #if LIB_PICO_MULTICORE
     .lock = pico_lock,
     .unlock = pico_unlock,
@@ -46,14 +58,16 @@ struct lfs_config pico_cfg = {
     .block_count = FS_SIZE / FLASH_SECTOR_SIZE,
     .cache_size = FLASH_SECTOR_SIZE / 4,
     .lookahead_size = 32,
-    .block_cycles = 500};
+    .block_cycles = 500,
+    .compact_thresh = -1};
 
 // Pico specific hardware abstraction functions
 
 // file system offset in flash
 const char* FS_BASE = (char*)(PICO_FLASH_SIZE_BYTES - FS_SIZE);
 
-static int pico_hal_read(lfs_block_t block, lfs_off_t off, void* buffer, lfs_size_t size) {
+static int pico_hal_read(const struct lfs_config *cfg, lfs_block_t block, lfs_off_t off, void* buffer, lfs_size_t size) {
+    UNUSED(cfg);
     assert(block < pico_cfg.block_count);
     assert(off + size <= pico_cfg.block_size);
     // read flash via XIP mapped space
@@ -61,7 +75,8 @@ static int pico_hal_read(lfs_block_t block, lfs_off_t off, void* buffer, lfs_siz
     return LFS_ERR_OK;
 }
 
-static int pico_hal_prog(lfs_block_t block, lfs_off_t off, const void* buffer, lfs_size_t size) {
+static int pico_hal_prog(const struct lfs_config *cfg, lfs_block_t block, lfs_off_t off, const void* buffer, lfs_size_t size) {
+    UNUSED(cfg);
     assert(block < pico_cfg.block_count);
     // program with SDK
     uint32_t p = (uint32_t)FS_BASE + (block * pico_cfg.block_size) + off;
@@ -71,7 +86,8 @@ static int pico_hal_prog(lfs_block_t block, lfs_off_t off, const void* buffer, l
     return LFS_ERR_OK;
 }
 
-static int pico_hal_erase(lfs_block_t block) {
+static int pico_hal_erase(const struct lfs_config *cfg, lfs_block_t block) {
+    UNUSED(cfg);
     assert(block < pico_cfg.block_count);
     // erase with SDK
     uint32_t p = (uint32_t)FS_BASE + block * pico_cfg.block_size;
@@ -81,16 +97,24 @@ static int pico_hal_erase(lfs_block_t block) {
     return LFS_ERR_OK;
 }
 
+static int pico_hal_sync(const struct lfs_config *cfg)
+{
+    UNUSED(cfg);
+    return LFS_ERR_OK;
+}
+
 #if LIB_PICO_MULTICORE
 
 static recursive_mutex_t fs_mtx;
 
-static int pico_lock(void) {
+static int pico_lock(const struct lfs_config *cfg) {
+    UNUSED(cfg);
     recursive_mutex_enter_blocking(&fs_mtx);
     return LFS_ERR_OK;
 }
 
-static int pico_unlock(void) {
+static int pico_unlock(const struct lfs_config *cfg) {
+    UNUSED(cfg);
     recursive_mutex_exit(&fs_mtx);
     return LFS_ERR_OK;
 }
@@ -111,16 +135,16 @@ int pico_mount(bool format) {
     recursive_mutex_init(&fs_mtx);
 #endif
     if (format)
-        lfs_format(&pico_cfg);
+        lfs_format(&pic_lfs_ctx, &pico_cfg);
     // mount the filesystem
-    return lfs_mount(&pico_cfg);
+    return lfs_mount(&pic_lfs_ctx, &pico_cfg);
 }
 
 int pico_open(const char* path, int flags) {
     lfs_file_t* file = lfs_malloc(sizeof(lfs_file_t));
     if (file == NULL)
         return LFS_ERR_NOMEM;
-    int err = lfs_file_open(file, path, flags);
+    int err = lfs_file_open(&pic_lfs_ctx, file, path, flags);
     if (err != LFS_ERR_OK){
         lfs_free(file);
         return err;
@@ -129,69 +153,69 @@ int pico_open(const char* path, int flags) {
 }
 
 int pico_close(int file) {
-    int res = lfs_file_close((lfs_file_t*)file);
+    int res = lfs_file_close(&pic_lfs_ctx, (lfs_file_t*)file);
     lfs_free((lfs_file_t*)file);
     return res;
 }
 
 lfs_size_t pico_write(int file, const void* buffer, lfs_size_t size) {
-    return lfs_file_write((lfs_file_t*)file, buffer, size);
+    return lfs_file_write(&pic_lfs_ctx, (lfs_file_t*)file, buffer, size);
 }
 
 lfs_size_t pico_read(int file, void* buffer, lfs_size_t size) {
-    return lfs_file_read((lfs_file_t*)file, buffer, size);
+    return lfs_file_read(&pic_lfs_ctx, (lfs_file_t*)file, buffer, size);
 }
 
-int pico_rewind(int file) { return lfs_file_rewind((lfs_file_t*)file); }
+int pico_rewind(int file) { return lfs_file_rewind(&pic_lfs_ctx, (lfs_file_t*)file); }
 
-int pico_unmount(void) { return lfs_unmount(); }
+int pico_unmount(void) { return lfs_unmount(&pic_lfs_ctx); }
 
-int pico_remove(const char* path) { return lfs_remove(path); }
+int pico_remove(const char* path) { return lfs_remove(&pic_lfs_ctx, path); }
 
-int pico_rename(const char* oldpath, const char* newpath) { return lfs_rename(oldpath, newpath); }
+int pico_rename(const char* oldpath, const char* newpath) { return lfs_rename(&pic_lfs_ctx, oldpath, newpath); }
 
 int pico_fsstat(struct pico_fsstat_t* stat) {
     stat->block_count = pico_cfg.block_count;
     stat->block_size = pico_cfg.block_size;
-    stat->blocks_used = lfs_fs_size();
+    stat->blocks_used = lfs_fs_size(&pic_lfs_ctx);
     return LFS_ERR_OK;
 }
 
 lfs_soff_t pico_lseek(int file, lfs_soff_t off, int whence) {
-    return lfs_file_seek((lfs_file_t*)file, off, whence);
+    return lfs_file_seek(&pic_lfs_ctx, (lfs_file_t*)file, off, whence);
 }
 
-int pico_truncate(int file, lfs_off_t size) { return lfs_file_truncate((lfs_file_t*)file, size); }
+int pico_truncate(int file, lfs_off_t size) { return lfs_file_truncate(&pic_lfs_ctx, (lfs_file_t*)file, size); }
 
-lfs_soff_t pico_tell(int file) { return lfs_file_tell((lfs_file_t*)file); }
+lfs_soff_t pico_tell(int file) { return lfs_file_tell(&pic_lfs_ctx, (lfs_file_t*)file); }
 
-int pico_stat(const char* path, struct lfs_info* info) { return lfs_stat(path, info); }
+int pico_stat(const char* path, struct lfs_info* info) { return lfs_stat(&pic_lfs_ctx, path, info); }
 
 lfs_ssize_t pico_getattr(const char* path, uint8_t type, void* buffer, lfs_size_t size) {
-    return lfs_getattr(path, type, buffer, size);
+    return lfs_getattr(&pic_lfs_ctx, path, type, buffer, size);
 }
 
 int pico_setattr(const char* path, uint8_t type, const void* buffer, lfs_size_t size) {
-    return lfs_setattr(path, type, buffer, size);
+    return lfs_setattr(&pic_lfs_ctx, path, type, buffer, size);
 }
 
-int pico_removeattr(const char* path, uint8_t type) { return lfs_removeattr(path, type); }
+int pico_removeattr(const char* path, uint8_t type) { return lfs_removeattr(&pic_lfs_ctx, path, type); }
 
 int pico_opencfg(int file, const char* path, int flags, const struct lfs_file_config* config) {
-    return lfs_file_opencfg((lfs_file_t*)file, path, flags, config);
+    return lfs_file_opencfg(&pic_lfs_ctx, (lfs_file_t*)file, path, flags, config);
 }
 
-int pico_fflush(int file) { return lfs_file_sync((lfs_file_t*)file); }
+int pico_fflush(int file) { return lfs_file_sync(&pic_lfs_ctx, (lfs_file_t*)file); }
 
-lfs_soff_t pico_size(int file) { return lfs_file_size((lfs_file_t*)file); }
+lfs_soff_t pico_size(int file) { return lfs_file_size(&pic_lfs_ctx, (lfs_file_t*)file); }
 
-int pico_mkdir(const char* path) { return lfs_mkdir(path); }
+int pico_mkdir(const char* path) { return lfs_mkdir(&pic_lfs_ctx, path); }
 
 int pico_dir_open(const char* path) {
 	lfs_dir_t* dir = lfs_malloc(sizeof(lfs_dir_t));
 	if (dir == NULL)
 		return -1;
-	if (lfs_dir_open(dir, path) != LFS_ERR_OK) {
+	if (lfs_dir_open(&pic_lfs_ctx, dir, path) != LFS_ERR_OK) {
 		lfs_free(dir);
 		return -1;
 	}
@@ -199,17 +223,17 @@ int pico_dir_open(const char* path) {
 }
 
 int pico_dir_close(int dir) {
-	return lfs_dir_close((lfs_dir_t*)dir);
+	return lfs_dir_close(&pic_lfs_ctx, (lfs_dir_t*)dir);
 	lfs_free((void*)dir);
 }
 
-int pico_dir_read(int dir, struct lfs_info* info) { return lfs_dir_read((lfs_dir_t*)dir, info); }
+int pico_dir_read(int dir, struct lfs_info* info) { return lfs_dir_read(&pic_lfs_ctx, (lfs_dir_t*)dir, info); }
 
-int pico_dir_seek(int dir, lfs_off_t off) { return lfs_dir_seek((lfs_dir_t*)dir, off); }
+int pico_dir_seek(int dir, lfs_off_t off) { return lfs_dir_seek(&pic_lfs_ctx, (lfs_dir_t*)dir, off); }
 
-lfs_soff_t pico_dir_tell(int dir) { return lfs_dir_tell((lfs_dir_t*)dir); }
+lfs_soff_t pico_dir_tell(int dir) { return lfs_dir_tell(&pic_lfs_ctx, (lfs_dir_t*)dir); }
 
-int pico_dir_rewind(int dir) { return lfs_dir_rewind((lfs_dir_t*)dir); }
+int pico_dir_rewind(int dir) { return lfs_dir_rewind(&pic_lfs_ctx, (lfs_dir_t*)dir); }
 
 const char* pico_errmsg(int err) {
     static const struct {
@@ -231,7 +255,7 @@ const char* pico_errmsg(int err) {
                  {LFS_ERR_NOATTR, "No data/attr available"},
                  {LFS_ERR_NAMETOOLONG, "File name too long"}};
 
-    for (int i = 0; i < sizeof(mesgs) / sizeof(mesgs[0]); i++)
+    for (unsigned int i = 0; i < sizeof(mesgs) / sizeof(mesgs[0]); i++)
         if (err == mesgs[i].err)
             return mesgs[i].text;
     return "Unknown error";
-- 
2.48.1

